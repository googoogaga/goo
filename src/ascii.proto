;;  -*- Mode: Scheme; Syntax: Scheme; Package: Scheme; -*-
;;  Copyright (c) 1993, 1994 Richard Kelsey and Jonathan Rees.  See file COPYING.
;;  Portable definitions of char->ascii and ascii->char
;;  Don't detabify this file!
;;  This module defines char->ascii and ascii->char in terms of
;;  char->integer and integer->char, with no assumptions about the encoding.
;;  Portable except maybe for the strings that contain tab, page, and
;;  carriage return characters.  Those can be flushed if necessary.
(dv ascii-limit 128)

(dv (ascii-chars <vec>)
  (let ((ascii-chars
	 (fill (fab <vec> ascii-limit) #f))
	(init
	 (fun (i s)
	   (rep loop ((i i) (j 0))
	     (unless (= j (len s))
	       (set (elt ascii-chars i) (elt s j))
	       (loop (+ i 1) (+ j 1)))))))
    ;; tab
    (init 9 "\t")
    ;; newline
    (init 10 "\n")
    ;; page
    (init 12 "\f")
    ;; carriage return
    (init 13 "\r")
    (init 32 " !\"#$%&'()*+,-./0123456789:;<=>?")
    (init 64 "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_")
    (init 96 "`abcdefghijklmnopqrstuvwxyz{|}~")
    ascii-chars))

(dm ascii->char ((n <int>) => <chr>)
  (or (elt ascii-chars n)
      (error "not a standard character's ASCII code: %=" n)))

(dm char->integer ((char <chr>) => <int>)
  (as <int> char))

(dm integer->char ((n <int>) => <chr>)
  (as <chr> n))

(dv (native-chars <lst>)
  (let ((end259 (len ascii-chars)))
    (rep loop ((i 0) (least #f) (greatest #f))
      (if (= i end259)
	  (let ((v (fill (fab <vec> (+ (- greatest least) 1)) #f)))
	    (rep loop ((i 0))
	      (if (= i end259)
		  (lst least v)
		  (let ((c (elt ascii-chars i)))
		    (if c (set (elt v (- (char->integer c) least)) i))
		    (loop (+ i 1))))))
	  (let ((c (elt ascii-chars i)))
	    (if c
		(let ((n (char->integer c)))
		  (loop (+ i 1) (if least (min least n) n)
			(if greatest (max greatest n) n)))
		(loop (+ i 1) least greatest)))))))

(dm char->ascii ((char <chr>) => <int>)
  (or (elt (head (tail native-chars))
	   (- (char->integer char) (head native-chars)))
      (error "not a standard character: %=" char)))

(dv ascii-whitespaces '(32 10 9 12 13))

;; str-eval("(str-to-num \"1\"):");

(dm str-to-num ((string <str>) => <any>) ;; (false-or <num>)
  (let ((s 1)
	(d 0)
	(n 0)
	(i 0)
	(scale 1)
	(length (len string))
	(seen-decimal-point? #f)
	(radix 10))
    (loc ((match (char)
	    (if (and (< i length) (= (elt string i) char))
		(seq (set i (+ i 1)) #t)
		#f))
	  (match-digit! (_)
	    (lab return
	      (loc ((fail!! () ;; (write-char-out #\f)
		      (return #f)))
		(if (>= i length) (fail!!))
		(let ((char (elt string i)))
		  (if (= char #\.)
		      (if seen-decimal-point?
			  (error "string->number: Two decimal points: %="
				 string)
			  (seq ;; (write-char-out #\.)
			   (set seen-decimal-point? #t)
			   (set i (+ i 1))
			   (if (>= i length) (fail!!))
			   (set char (elt string i)))))
		  (if (not (numeric? char)) (fail!!))
		  (set d (to-digit (elt string i)))
		  (set i (+ i 1))
		  (if seen-decimal-point?
		      (set scale (* scale radix)))
		  ;; (write-char-out #\d)
		  #t))))
	  (looking-at-alphabetic? ()
	    (if (and (< i length) 
		     (alphabetic? (elt string i)))
		;; (write-char-out #\a)
		#t;
		;; (write-char-out #\n)
		#f)))
  ;; Now we get to use all this matching machinery
  (and (or (match #\+)
	   (and (match #\-) (set s -1))
	   #t)
       (and (match-digit! d) (set n d))
       (rep loop ()
	 (if (and (match-digit! d) (set n (+ (* n radix) d)))
	     (loop)
	     #t))
       (= i length) ;; consumed all chars
       (let ((f (* (as <flo> s) (/ (as <flo> n) (as <flo> scale)))))
	 (if seen-decimal-point? f (1st (truncate f))))))))

