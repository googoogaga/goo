;; CURRENT ENVIRONMENT
;; TODO: DYNAMIC BINDING
(dv *env* $the-empty-environment)

(df env () *env*)

(ds (with-env ,new-env ,@body)
  `(seq (dlet ((*env* ,new-env)) ,@body)))

(dm ast-eval-in ((e <program>) (env <environment>))
  (with-env env (ast-eval e env)))

(dg ast-eval ((e <program>) (env <environment>)))

(dm ast-eval ((e <constant>) (env <environment>))
  (constant-value e))

(dm ast-eval ((e <raw-constant>) (env <environment>))
  (constant-value e))

(dm ast-eval ((e <compile-time>) (ee <environment>))
  (ast-eval (compile-time-program e) (rt-env)))

(dm ast-eval-specs 
    ((specs <lst>) (nary? <log>) (env <environment>) => <any>)
  (let ((nreq (if nary? (- (len specs) 1) (len specs))))
    (rep loop ((res '()) (specs specs) (i 0))
      (if (= i nreq)
	  (rev! res)
	  (let ((spec (head specs))
		(type (if spec (ast-eval spec env) <any>)))
	    (loop (pair type res) (tail specs) (+ i 1)))))))

(dm export-proto-method (f names specs nary? body env)
  (let ((efun
	 (select (len names)
	   ((0) (fun ()
		  (let ((nenv (env-frame! env f '() '())))
		    (with-env nenv (body nenv)))))
	   ((1) (fun (a1)
		  (let ((nenv (env-frame! env f names (lst a1))))
		    (with-env nenv (body nenv)))))
	   ((2) (fun (a1 a2)
		  (let ((nenv (env-frame! env f names (lst a1 a2))))
		    (with-env nenv (body nenv)))))
	   ((3) (fun (a1 a2 a3)
		  (let ((nenv (env-frame! env f names (lst a1 a2 a3))))
		    (with-env nenv (body nenv)))))
	   ((4) (fun (a1 a2 a3 a4)
		  (let ((nenv (env-frame! env f names (lst a1 a2 a3 a4))))
		    (with-env nenv (body nenv)))))
	   ((5) (fun (a1 a2 a3 a4 a5)
		  (let ((nenv (env-frame! env f names (lst a1 a2 a3 a4 a5))))
		    (with-env nenv (body nenv)))))
	   ((6) (fun (a1 a2 a3 a4 a5 a6)
		  (let ((nenv (env-frame! env f names (lst a1 a2 a3 a4 a5 a6))))
		    (with-env nenv (body nenv)))))
	   ((7) (fun (a1 a2 a3 a4 a5 a6 a7)
		  (let ((nenv (env-frame! env f names (lst a1 a2 a3 a4 a5 a6 a7))))
		    (with-env nenv (body nenv))))))))
    ;; TODO: HANDLE MORE THAN 7 CASE
    (set (fun-nary? efun) nary?)
    (set (fun-specs efun) (ast-eval-specs specs nary? env))
    efun))

(dm ast-eval ((e <ast-method>) (env <environment>))
  (let ((params (function-bindings e))
	(eval   (fun ((env <environment>)) (ast-eval (function-body e) env))))
    (export-proto-method
     e (map binding-name params) (map binding-type params) 
     (function-nary? e) eval env)))

;; (dm ast-eval ((e <ast-primitive>) (env <environment>))
;;   (let ((params (function-bindings e))
;; 	   (eval   (fun ((env <environment>)) (ast-eval (function-body e) env))))
;;     (make-primitive (map binding-name params) (function-nary? e) eval env)))

(dm ast-eval ((e <ast-generic>) (env <environment>))
  (let ((params (function-bindings e))
	(nary?  (function-nary? e))
	(specs  (ast-eval-specs (map binding-type params) nary? env))
	(efun   (isa <gen>)))
    (set (fun-nary? efun) nary?)
    (set (fun-specs efun)       
	 (if nary? (sub specs 0 (- (len specs) 1)) specs))
    efun
    ;; (isa <gen>
    ;;   (set fun-specs specs)
    ;;   (set fun-nary? nary?) 
    ;;   (set fun-mets '()))
    ))

(dm ast-eval ((e <reference>) (env <environment>))
  (env-binding-value
    env (binding-name (reference-binding e))))

(dv $unbound (lst "UNBOUND"))

(dm ast-eval ((e <bound?>) (env <environment>))
  (let ((value
	 (env-binding-value-defaulted
	  env (binding-name (reference-binding (bound?-reference e)))
	  (fun (x) $unbound))))
    (~== value $unbound)))

(dm ast-eval ((e <global-assignment>) (env <environment>))
  (let ((value (ast-eval (assignment-form e) env)))
    (set (env-binding-value env (binding-name (assignment-binding e))) value)))

(dm ast-eval ((e <local-assignment>) (env <environment>))
  (let ((value   (ast-eval (assignment-form e) env))
	(binding (reference-binding (assignment-reference e))))
    (set (env-binding-value env (binding-name binding)) value)))

(dm ast-eval ((e <definition>) (env <environment>))
  (let ((value (ast-eval (assignment-form e) env)))
    (env-define-binding!
     env (binding-name (assignment-binding e)) value)
    #f))

(dv <box> (isa <any>))
  (slot <box> box-value)

;; (dm ast-eval ((e <box-read>) (env <environment>))
;;   (box-value (ast-eval (box-reference e) env)))
;; 
;; (dm ast-eval ((e <box-write>) (env <environment>))
;;   (set (box-value (ast-eval (box-reference e) env))
;;        (ast-eval (box-form e) env)))
;; 
;; (dm ast-eval ((e <box-creation>) (env <environment>))
;;   (set (env-binding-value 
;;          env (binding-name (reference-binding (box-reference e))))
;;        (isa <box>)))

(dm ast-eval ((e <alternative>) (env <environment>))
  (if (ast-eval (alternative-condition e) env)
      (ast-eval (alternative-consequent e) env)
      (ast-eval (alternative-alternant e) env)))

(dm ast-eval ((e <sequential>) (env <environment>))
  (rep eval ((e e))
    (let ((nxt (sequential-tail e))
	  (val (ast-eval (sequential-head e) env)))
      (if (empty-sequential? nxt)
	  val
	  (eval nxt)))))

(dm ast-eval ((e <argument-list>) (env <environment>))
  (rep eval ((res '()) (args e))
    (if (empty-argument-list? args)
	(rev! res)
	(eval (pair (ast-eval (arguments-head args) env) res) 
	      (arguments-tail args)))))

(dm ast-eval ((e <regular-application>) (env <environment>))
  (let ((f    (ast-eval (application-function e) env))
	(args (ast-eval (application-arguments e) env)))
    (apply f args)))

(dm ast-eval ((e <predefined-application>) (env <environment>))
  (let ((f    (env-binding-value env (binding-name (application-binding e))))
	(args (ast-eval (application-arguments e) env)))
    (apply f args)))

(dm ast-eval ((e <fix-let>) (env <environment>))
  (let ((args (ast-eval (fix-let-arguments e) env))
	(nenv (env-frame! env #f (map binding-name (fix-let-bindings e)) args)))
    (with-env nenv (ast-eval (fix-let-body e) nenv))))

(dm ast-eval ((e <locals>) (env <environment>))
  (let ((bindings
	 (locals-bindings e))
	(new-env 
	 (env-frame!
	  env #f (map binding-name bindings) (map (always nul) bindings))))
    (with-env new-env
      (do2 (fun (name value) (set (env-binding-value new-env name) value))
	   (map binding-name bindings) 
	   (map (rcurry ast-eval new-env) (locals-functions e)))
      (ast-eval (locals-body e) new-env))))

(dm ast-eval ((e <bind-exit>) (env <environment>))
  (lab return
    (let ((rproc (fun ((env <environment>)) 
		   (return (env-binding-value env 'x))))
	  (exit  (export-proto-method rproc (lst 'x) (lst #f) #f rproc env)))
      ((ast-eval (bind-exit-main-fun e) env) exit))))

(dm ast-eval ((e <unwind-protect>) (env <environment>))
  (fin ((ast-eval (unwind-protect-protected-thunk e) env))
       ((ast-eval (unwind-protect-cleanup-thunk(e)) env))))

(dm ast-eval ((e <monitor>) (env <environment>))
  (apply (env-binding-value env '%with-monitor)
	 (list (ast-eval (monitor-handler e) env)
	       (ast-eval (monitor-main-thunk e) env))))

;;; ENVIRONMENT

(dv *rt-base-env* (make-rt-base-env))

(dv *rt-env* (env-extend! *rt-base-env* '() '() 'global))

(df rt-env () *rt-env*)

(df rt-env-setter (env) (set *env* env))

(df ast-read-eval (x) (ast-eval-in (objectify x (ct-env)) (rt-env)))

;; (dv *boot-env* (env-extend! $the-empty-environment '() '() 'global))

;; (df boot-env () *boot-env*)

;; (df boot-env-setter (env) (set *boot-env* env))

