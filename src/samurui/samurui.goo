(use goo)
(use goo/system)
(use goo/boot)

(use samurui/gtk.swig)
(use samurui/gtkcallbacks)

(dv gtk_true 1)
(dv gtk_false 0)

(dv NULL (%lb 0))
(dv null_loc NULL)

(df okie? (l|<loc> m|<str>)
  (when (== l null_loc)
    (msg out m)
    (msg out "\n"))
  )

(ds (debugstr ,@body)
  `(msg out ,@body)
  )

(dg ad! (to thing))

; ----

(dc <interface-info> (<any>))

(dv root-interface (new <interface-info>))

(dc <interface-action> (<interface-info>))
  (dp name (<interface-action> => <str>))
  (dp method (<interface-action> => <any>))
  (dp description (<interface-action> => <any>))

(dm interface-action (new-name new-method new-description => <interface-action>)
  (let ((action (new <interface-action>)))
    (set (name action) new-name)
    (set (method action) new-method)
    (set (description action) new-description)
    action
    )
  )

(dc <interface-property> (<interface-info>))
  (dp name (<interface-property> => <any>))
  (dp type (<interface-property> => <class>))
  (dp getter (<interface-property> => <any>))
  (dp setter (<interface-property> => <any>))
  (dp description (<interface-property> => <any>))

(dm interface-property (new-name new-type new-getter new-setter new-description => <interface-property>)
  (let ((property (new <interface-property>)))
    (set (name property) new-name)
    (set (type property) new-type)
    (set (getter property) new-getter)
    (set (setter property) new-setter)
    (set (description property) new-description)
    property)
  )

; Maps class of object to a vector of potential interface-models
(dv interface-models (fab <tab> 0))

(dc <interface-class-info> (<any>))
  (dp properties (<interface-class-info> => <str-tab>))
  (dp actions (<interface-class-info> => <str-tab>))

(dm interface-class-info ( => <interface-class-info>)
  (let ((info (new <interface-class-info>)))
    (set (properties info) (fab <str-tab> 0))
    (set (actions info) (fab <str-tab> 0))
    info
    )
)

; An interface model is just a tup
(dv <interface-model> <tup>)

(dm interface-model ((eval-func <fun>) (factory <fun>) => <interface-model>)
  (tup eval-func factory)
)

(dm interface-model ((eval-func <fun>) (list <lst>) => <interface-model>)
  (tup eval-func list)
)

(dv imodel-eval 1st)
(dv imodel-payload 2nd)

; Maps class of object to <interface-class-info> object for that class
(dv interface-infos (fab <tab> 0))

; --
; --- User Macros 
; -- 

(ds (iprop ,class ,binding ,type ,desc)
  `(seq
     (dp ,binding (,class => ,type))
     (add-property ,class (interface-property ,(as <str> binding) ,type ,binding ,(fab-setter-name binding) ,desc))
     )
  )

(ds (iaction ,class ,binding ,this-name ,desc ,@body)
  `(seq
     (dm ,binding ((,this-name ,class)) ,@body)
     (add-action ,class (interface-action ,(as <str> binding) ,binding ,desc))
     )
  )

(ds (imodel ,class ,@body)
  `(register-interface-model ,class (interface-model (fun (x) 1)
                                                     (quote (,@body))))
  )

; Drawing areas are a recognition that no matter how many auto-magic visualization
;  interfaces we provide, there will always be a need to be able to have custom 
;  drawing interfaces.  In fact, this is how we intend to allow extension for
;  auto-magic visualization.  Additionally, it's hard to make a drawing program 
;  without something like this.
; Drawing areas are implicitly associated with a type of object to render, the assoc-class.
; Additionally, they must have an implementation class which is derived from interface-drawing-area,
;  which is specified as class.  If all you want to do is have a drawing widget or something equally
;  inane, you can happily have the associated class and the class be the same thing.

; Oy, now how to bind the drawer dude into interface models.  The associativity clearly indicates that
;  the place of the drawing area is analogous to that of the interface model.  Of course, so are button
;  bindings and text bindings.  My initial thought was that those would be handled via the renderize
;  generic protocol.  Basically there are two approaches then.  The first is the renderize protocol, where
;  the idraw would also define a renderize method.  The problem is that we still need an inert class type 
;  (such as a singelton) to dispatch on that.  The alternative is to extend the concept of the interface
;  model.  If we re-evaluate the current implementation right now, we should consider the need to figure out
;  which of the many possible interface models to use.  Possible methods include allowing the interface
;  model to carry a heuristic function with it, or perhaps just an id so we can only use the right-click menu.
;  More extensive tricks such as range-constraint and such could easily fit within the heuristic function model,
;  which merely leads to pre-init'ing our interface model as opposed to trying to stuff the base-cases into
;  pure-code form.
; The current methedology uses a recursive recipe technique; We start out with the interface model in list form
;  and then process each element using multi-method dispatch, which may quite possibly be another list.  Symbols
;  are looked up against our registered properties and actions.
; An alternative, hypothetical method is this.  Interface models consist of an evaluation function and either
;  either a list or function for the model.  If the model is a list, we recursively process the list in the current
;  style.  That is, strings are directly transformed to labels, special symbols such as 'columns' still work,
;  and other symbols are looked up against our class information so that we can find a proper interface model for
;  them.  In the case the model is a function, it is expected to be a factory method equivalent to our current
;  renderize dude.  Specifically, it must return a gui object, and must take a class (not outrightly needed, but
;  we'll considering it future-proofing) and the list of updaters that should be added to as needed.

(ds (idrawmodel ,assoc-class ,class ,@body)
  `(seq
     (dc ,class (<interface-drawing-area>))
     (register-interface-model ,assoc-class (interface-model (fun (x) 1)
                                                       (fun (info parent-class updaters)
                                                         ; -- stolen from gui-imagebox fabber...
                                                         ; need to ask how to piggy-back on someone else's fab...
                                                         (let ((imagebox (new ,class)))
                                                           (set (paintbox imagebox) (gui-paintbox))
                                                           (set (canvas imagebox) (gui-canvas (paintbox imagebox)))
                                                           ; make the paintbox handle the default handle we use...
                                                           (set (handle imagebox) (handle (paintbox imagebox))) 
                                                           ; Bind it
                                                           (ad! updaters (bind imagebox (getter info) (setter info)))

                                                           ; User setup-code
                                                           ,@body

                                                           ; Events
                                                           (hookify imagebox)
                                                           imagebox
                                                           )
                                                         )
                                                       )
                               )
     )
  )

; --
; --- Macro Support Functionality
; --

(dm register-interface-model ((class <class>) (the-model <interface-model>))
  (let ((models (or (elt-or interface-models class #f) (set (elt interface-models class) (fab <vec> 0)))))
    ; put it in the list
    (ad! models the-model))
  )

(dm has-interface-model? ((class <class>))
  (let ((models (elt-or interface-models class #f)))
    models) ; Should both verify that it is non-nul and non-zero in length
  )
         
; return an arbitrary model associated directly with the given class
(dm get-interface-model ((class <class>) (info <interface-info>))
  (let ((models (elt interface-models class))
        (best-score 0)
        (best-model #f))
    (do 
     (fun (model)
       (let ((cur-score ((imodel-eval model) info)))
         (if (> cur-score best-score)
             (seq
               (set best-score cur-score)
               (set best-model model)
               )
             )
         )
       )

     models)
    best-model            
    )
  )

(dm get-interface-models ((class <class>))
  (let ((models (elt interface-models class)))
    models
    )
  )

; Note! We assume that the most specific set of interface models forms the complete set
;  that we want to consider.  An alternate implementation might mush them all together
;  and then check them each out, but since there is nothing preventing someone from
;  copying an interface-model (or models) down from higher in the hierarchy, this seems
;  like the optimal solution.
(dm find-interface-model ((class <class>) (info <interface-info>) => <interface-model>)
  (let ((first-class (find-first-class has-interface-model? class)))
    (get-interface-model first-class info)
    )
  )

; Utility
(dm add-all! (to from)
  (do (fun (x)
        (ad! to x)
        )
      from)
  )

(dm add-all-opt! (to from)
  (do (fun (x)
        (case-by x isa?
          ((<gui-widget>)
           (ad-opt! to x (attrs x))
           )
          (#t
           (ad! to x)
           )
          )
        )
      from)
  )

; eh, so it exists already, but only for collections! I still like the above, and the name, so...
;(dm add-all! ((to <col>) (from <col>))
;  (alter to from)
;  )

(dm add-all! ((to <tab>) (from <tab>))
  (do (fun (key)
        (set (elt to key) (elt from key))
        )
      (keys from)
      )
  )
  

; Utility:Pull Out
; Takes a function that is to be tested on a class and all of its ancestors
 ; in an arbitrary order (basically working its way up)
(dm find-first-class ((func <fun>) (base-class <class>) => <class>)
  (if (func base-class)
      base-class
      (let ((queue (class-parents base-class)))
        (esc found-it
          (do (fun ((cur-class <class>))
                (if (func cur-class)
                    (found-it cur-class)
                    (add-all! queue (class-parents cur-class))
                    ))
                queue
              )
          )
        )
      )
  )

(dm get-class-info ((class <class>) => <interface-class-info>)
  (let ((info (or (elt-or interface-infos class #f) (set (elt interface-infos class) (interface-class-info)))))
    info)
  )

(dm add-property ((class <class>) (property <interface-property>))
  (let ((info (get-class-info class)))
    ; Add the property to the properties hash using its name as the key
    (set (elt (properties info) (name property)) property)
    )
  )

(dm add-action ((class <class>) (action <interface-action>))
  (let ((info (get-class-info class)))
    (set (elt (actions info) (name action)) action)
    )
  )
  
; Returns the actions directly associated with the given class.
;  (Eg, does not handle ancestral actions.)
(dm get-class-actions ((class <class>) => <col>)
  (actions (get-class-info class))
  )
  
(dm get-all-actions ((class <class>) => <col>)
  (let ((actions (fab <str-tab> 0)))
    (do (fun (c)
          (add-all! actions (get-class-actions c))
          )
        (add (class-parents class) class)
        )
    actions
    )
  )

(dm find-action ((class <class>) (name <str>) => <any>) ; should be false-or <interface-action>
  (elt-or (get-all-actions class) name #f)
  )

(dm get-class-properties ((class <class>) => <col>)
  (properties (get-class-info class))
  )

(dm get-all-properties ((class <class>) => <col>)
  (let ((properties (fab <str-tab> 0)))
    (do (fun (c)
          (add-all! properties (get-class-properties c))
          )        
        (add (class-parents class) class) ; need the class in there too!
        )
    properties
    )
  )


(dm find-property ((class <class>) (name <str>) => <any>) ; should be (false-or <interface-property>)
  (elt-or (get-all-properties class) name #f)
  )

; --
; --- Present (like presentation, not gift or here)
; --

(dm rebind-interface-model ((updaters <col>) (obj <any>))
  (do (fun ((updater-tup <tup>))
        ((1st updater-tup) obj))
      updaters
      )
  )

(dm update-interface-model ((updaters <col>))
  (do (fun ((updater-tup <tup>))
        ((2nd updater-tup))
        )
      updaters
      )
  )

; Presentation constructs a top-level window to display the object.
(df kill-gtk (x)
  (gtk_main_quit)
)

(dm present (obj)
  (let ((window (gui-window))
        (kill-gtk-cb (goo_safeCreateCallback kill-gtk 0))
        (class (object-class obj))
        (model (find-interface-model class root-interface))
        (updaters (fab <vec> 0))
        )
    ; set up the window for death on destroy
    (gtk_signal_connect (handle window) "destroy" (gtk_getGtkCallback) kill-gtk-cb)
    (msg out "About to add-all\n")
    (ad! window (renderize-model model root-interface class updaters (fab <str-tab> 0)))
    (msg out "About to rebind\n")
    (rebind-interface-model updaters obj)
    (msg out "About to update\n")
    (update-interface-model updaters)
    (msg out "About to show\n")
    (show window)
    )
  )

; -
; -- Limited GUI Wrappers
; -

(dc <gui> (<any>))
  (dp handle (<gui> => <loc>))

(dc <gui-widget> (<gui>))
 (dp attrs (<gui-widget> => (t? <col>)) #f)

(dm log-to-gtk ((log <log>) => <int>)
  (if log
      gtk_true
      gtk_false)
  )

(dm gtk-to-log (gtk-val|<int> => <log>)
  (gtk-val == gtk_true)
  )

(dm free ((gui-obj <gui>))
  (unless (= (handle gui-obj) NULL)
    (g_object_unref (handle gui-obj))
    (set (handle gui-obj) NULL)
    )
  )

; -- Widget stuff

(dm gui-width (widget|<gui-widget> => <int>)
  (_GdkRectangle_width_get (_GtkWidget_allocation_get (handle widget)))
  )

(dm gui-height (widget|<gui-widget> => <int>)
  (_GdkRectangle_height_get (_GtkWidget_allocation_get (handle widget)))
  )

; -- Containers

(dc <gui-container> (<gui-widget>))
  (dp children (<gui-container> => <vec>) (fab <vec> 0))

(dm free (container|<gui-container>)
  ;; Kill off the kids
  (do (fun (kid) (free kid)) (children container))
  (zap! (children container))

  ;; Kill off our own handle
  (unless (= (handle gui-obj) NULL)
    (g_object_unref (handle gui-obj))
    (set (handle gui-obj) NULL)
    )
  )

(dc <gui-window> (<gui-container>))

(dm gui-window ( => <gui-window>)
  (let ((window (new <gui-window>))
        (handle (gtk_window_new GTK_WINDOW_TOPLEVEL)))
    (set (handle window) handle)
    ; tweak some GTK-level settings
    (gtk_container_set_border_width handle 8)
    window
    )
  )

(dc <gui-frame> (<gui-container>))

(dm gui-frame (label|<str> => <gui-frame>)
  (def f (new <gui-frame>))
  (def da-frame (gtk_frame_new label))
  (set (handle f) da-frame)
  f
  )

(dc <gui-box> (<gui-container>))

(dc <gui-vbox> (<gui-box>))

(dm gui-vbox ( => <gui-vbox>)
  (let ((vbox (new <gui-vbox>))
        (handle (gtk_vbox_new gtk_false 8)))
    (set (handle vbox) handle)
    ; tweak some GTK-level settings
    (gtk_container_set_border_width handle 8)
    vbox
    )
  )

(dc <gui-hbox> (<gui-box>))

(dm gui-hbox ( => <gui-hbox>)
  (let ((hbox (new <gui-hbox>))
        (handle (gtk_hbox_new gtk_false 8)))
    (set (handle hbox) handle)
    ; tweak some GTK-level settings
    (gtk_container_set_border_width handle 8)
    hbox
    )
  )

(dm ad! (to thing)
  (add! to thing)
  )

(dm ad! ((container <gui-container>) (item <gui>))
  ;;(debugstr "Adding %= to gui-container %=.\n" item container)
  (gtk_container_add (handle container) (handle item))
  (add! (children container) item)
  )

(dm rem! (container|<gui-container> item|<gui>)
  (gtk_container_remove (handle container) (handle item))
  (set (children container) (del-vals (children container) item))
  )

(dm ad! ((container <gui-box>) (item <gui>))
  (debugstr "Adding %= to gui-box %=.\n" item container)
  (gtk_box_pack_start (handle container) (handle item) gtk_false gtk_false 8)
  (add! (children container) item)
  )

(dm ad-opt! (container|<gui-box> item|<gui> opt|(t? <col>))
  (def fill (when opt (mem? opt 'fill))) ; default to false
  (debugstr "Adding with options %= which I think means fill: %= (%=)\n" opt fill (log-to-gtk fill))
  (debugstr "Adding %= to gui-box %=.\n" item container)
  (gtk_box_pack_start (handle container) (handle item) (log-to-gtk fill) (log-to-gtk fill) 8)
  (add! (children container) item)
  )

; was going to do cool iteration, then I discovered that I knew about the show_all func
(dm show ((widget <gui-widget>))
  (gtk_widget_show (handle widget))
  )

(dm show ((window <gui-window>))
  (debugstr "Going to show %=\n" window)
  (gtk_widget_show_all (handle window))
  ) 

(dm show-all ((widget <gui-widget>))
  (gtk_widget_show_all (handle widget))
  ) 

; -- Items

;; ;;;;;; ;;
;; Button ;;
;; ;;;;;; ;;

(dc <gui-button> (<gui-widget>))

(dm gui-button ((label <str>) => <gui-button>)
  (let ((button (new <gui-button>))
        (handle (gtk_button_new_with_label label)))
    (set (handle button) handle)
    button
    )
  )

(dm connect ((button <gui-button>) (func <fun>) val-to-pass)
  (gtk_signal_connect (handle button)
                      "clicked"
                      (gtk_getGtkCallback)
                      (goo_safeCreateCallback func val-to-pass))
  )

;; ;;;;;;;;;;;;;;;;;;;;; ;;
;; Radio / Toggle Button ;;
;; ;;;;;;;;;;;;;;;;;;;;; ;;

(dc <gui-toggle-button> (<gui-button>))

(dc <gui-check-button> (<gui-toggle-button>))

(dm gui-check-button ((label <str>) => <gui-check-button>)
  (let ((button (new <gui-check-button>))
        (handle (gtk_check_button_new_with_label label)))
    (set (handle button) handle)
    button
    )
  )

(dm connect ((button <gui-toggle-button>) (func <fun>) val-to-pass)
  (gtk_signal_connect (handle button)
                      "toggled"
                      (gtk_getGtkCallback)
                      (goo_safeCreateCallback func val-to-pass))
  )

;; ;;;;; ;;
;; Label ;;
;; ;;;;; ;;

(dc <gui-label> (<gui-widget>))

(dm gui-label ((label-text <str>) => <gui-label>)
  (let ((label (new <gui-label>))
        (handle (gtk_label_new label-text)))
    (set (handle label) handle)
    label
    )
  )

;; ;;;;;;; ;;
;; Textbox ;;
;; ;;;;;;; ;;
(dc <gui-textbox> (<gui-widget>))

(dm gui-textbox ( => <gui-textbox>)
  (let ((textbox (new <gui-textbox>))
        (handle (gtk_entry_new)))
    (set (handle textbox) handle)
    textbox
    )
  )

;; ;;;; ;;
;; Menu ;;
;; ;;;; ;;
(dc <gui-menu> (<gui-container>))

(dm gui-menu (=> <gui-menu>)
  (def menu (new <gui-menu>))
  (def h (gtk_menu_new))
  (set (handle menu) h)
  menu
  )


(dm popup (menu|<gui-menu> button|<int> button-time|<int>)
  ;;(debugstr "Going to try and pop up a menu now...\n")
  (gtk_menu_popup (handle menu) 
                  NULL
                  NULL
                  NULL
                  NULL
                  button
                  button-time)
  ;;(debugstr "Done trying to pop up a menu now...\n")
  )

;; ;;;;;;;;;;;;;;;;; ;;
;; Menu Item : Label ;;
;; ;;;;;;;;;;;;;;;;; ;;

(dc <gui-menu-item> (<gui-widget>))

(dc <gui-menu-item-label> (<gui-menu-item>))

(dm ad! ((da-menu <gui-menu>) (item <gui-menu-item>))
  (debugstr "Adding menu item to menu.\n")
  (gtk_menu_shell_append (handle da-menu) (handle item))
  (add! (children da-menu) item)
  #t
  )

(dm gui-menu-item-label (label-text|<str> => <gui-menu-item-label>)
  (def mi (new <gui-menu-item-label>))
  (def h (gtk_menu_item_new_with_label label-text))
  (set (handle mi) h)
  mi
  )

(dm connect (menu-item|<gui-menu-item> func|<fun> val-to-pass)
  (gtk_signal_connect (handle menu-item)
                      "activate"
                      (gtk_getGtkCallback)
                      (goo_safeCreateCallback func val-to-pass))
  )

;; ;;;;;;;;;; ;;
;; Rectangles ;;
;; ;;;;;;;;;; ;;

(dc <rectangle> (<any>))

(dc <gdk-rect> (<gui> <rectangle>))

(dm gdk-rect ((x <int>) (y <int>) (w <int>) (h <int>)  => <gdk-rect>)
  (let ((rectangle (new <gdk-rect>))
        (handle (new__GdkRectangle)))
    ; Set the handle
    (set (handle rectangle) handle)
    (_GdkRectangle_x_set handle x)
    (_GdkRectangle_y_set handle y)
    (_GdkRectangle_width_set handle w)
    (_GdkRectangle_height_set handle h)
    rectangle
    )
  )

(dm rect-x ((r <gdk-rect>) => <int>)
  (_GdkRectangle_x_get (handle r)))

(dm rect-y ((r <gdk-rect>) => <int>)
  (_GdkRectangle_y_get (handle r)))

(dm rect-w ((r <gdk-rect>) => <int>)
  (_GdkRectangle_width_get (handle r)))

(dm rect-h ((r <gdk-rect>) => <int>)
  (_GdkRectangle_height_get (handle r)))

(dm grow! ((r <gdk-rect>) (size <int>))
  (let ((hr (handle r)))
    (_GdkRectangle_x_set hr (- (_GdkRectangle_x_get hr) size))
    (_GdkRectangle_y_set hr (- (_GdkRectangle_y_get hr) size))
    (_GdkRectangle_width_set hr (+ (_GdkRectangle_width_get hr) (* size 2)))
    (_GdkRectangle_height_set hr (+ (_GdkRectangle_height_get hr) (* size 2)))
    )
  )

(dm free ((rect <gdk-rect>))
  (delete__GdkRectangle (handle rect))
  )

(dc <gui-rect> (<rectangle>))
 (dp rect-x (<gui-rect> => <int>))
 (dp rect-y (<gui-rect> => <int>))
 (dp rect-w (<gui-rect> => <int>))
 (dp rect-h (<gui-rect> => <int>))

(dm rect (x|<int> y|<int> w|<int> h|<int> => <gui-rect>)
  (def r (new <gui-rect>))
  (set (rect-x r) x)
  (set (rect-y r) y)
  (set (rect-w r) w)
  (set (rect-h r) h)
  r
  )

(dm rect-around (x|<int> y|<int> half-width|<int> half-vert|<int> => <gui-rect>)
  (rect (- x half-width)
        (- y half-vert)
        (* 2 half-width)
        (* 2 half-vert))
  )

(dm rect-to-gdk (r|<gui-rect> => <gdk-rect>)
  (gdk-rect (rect-x r) (rect-y r) (rect-w r) (rect-h r))
  )

(dm grow! ((r <gui-rect>) (size <int>))
  (decf (rect-x r) size)
  (decf (rect-y r) size)
  (incf (rect-w r) (* size 2))
  (incf (rect-h r) (* size 2))
  )

(dm shrink! ((r <gui-rect>) (size <int>))
  (grow! r (- 0 size))
  )

(dm free ((rect <gui-rect>))
  ;; NOP now
  )

(dc <point> (<any>))

(dc <gui-point> (<point>))
 (dp point-x (<gui-point> => <int>))
 (dp point-y (<gui-point> => <int>))

(dc <gui-point-flo> (<point>))
 (dp point-x (<gui-point-flo> => <flo>))
 (dp point-y (<gui-point-flo> => <flo>))

(dc <gdk-point> (<gui> <point>))

(dm point (x|<int> y|<int> => <gui-point>)
  (def p (new <gui-point>))
  (set (point-x p) x)
  (set (point-y p) y)
  p
  )

(dm point (x|<flo> y|<flo> => <gui-point-flo>)
  (def p (new <gui-point-flo>))
  (set (point-x p) x)
  (set (point-y p) y)
  p
  )

(dm point-in-rect (p|<point> r|<gui-rect>)
  (and (> (point-x p) (rect-x r))
       (> (point-y p) (rect-y r))
       (< (point-x p) (+ (rect-x r) (rect-w r)))
       (< (point-y p) (+ (rect-y r) (rect-h r)))
       )
  )

(dm point-to-gdk (p|<gui-point> => <gdk-point>)
  (gdk-point (point-x p) (point-y p)))

(dm gdk-point ((x <int>) (y <int>) => <gdk-point>)
  (let ((p (new <gui-point>))
        (handle (new__GdkPoint)))
    ; Set the handle
    (set (handle p) handle)
    (_GdkPoint_x_set handle x)
    (_GdkPoint_y_set handle y)
    p
    )
  )

(dm point-x ((p <gdk-point>) => <int>)
  (_GdkPoint_x_get (handle p))
  )

(dm point-y ((p <gdk-point>) => <int>)
  (_GdkPoint_y_get (handle p))
  )

(dm free (point|<gui-point>)
  )

(dm free ((point <gdk-point>))
  (delete__GdkPoint (handle point))
  )

(dc <gui-circle-flo> (<any>))
 (dp circle-p (<gui-circle-flo> => <gui-point-flo>))
 (dp circle-r (<gui-circle-flo> => <flo>))

(dm circle (x|<flo> y|<flo> r|<flo> => <gui-circle-flo>)
  (def c (new <gui-circle-flo>))
  (set (circle-p c) (point x y))
  (set (circle-r c) r)
  c
  )

(dc <gui-line> (<any>))
 (dp line-p1 (<gui-line> => <gui-point>))
 (dp line-p2 (<gui-line> => <gui-point>))

(dm line (p1|<gui-point> p2|<gui-point> => <gui-line>)
  (def l (new <gui-line>))
  (set (line-p1 l) p1)
  (set (line-p2 l) p2)
  l
  )

(dc <gui-line-flo> (<any>))
 (dp line-p1 (<gui-line-flo> => <gui-point-flo>))
 (dp line-p2 (<gui-line-flo> => <gui-point-flo>))

(dm line (p1|<gui-point-flo> p2|<gui-point-flo> => <gui-line-flo>)
  (def l (new <gui-line-flo>))
  (set (line-p1 l) p1)
  (set (line-p2 l) p2)
  l
  )

(dm dist (p1|<point> p2|<point> => <flo>)
  (def dx (- (point-x p1) (point-x p2)))
  (def dy (- (point-y p1) (point-y p2)))    
  (sqrt (+ (* dx dx)
           (* dy dy)))
  )

(dm sqdist (p1|<gui-point-flo> p2|<gui-point-flo> => <flo>)
  (def dx (- (point-x p1) (point-x p2)))
  (def dy (- (point-y p1) (point-y p2)))    
  (+ (* dx dx)
     (* dy dy))
  )

(dm intersect (c1|<gui-circle-flo> c2|<gui-circle-flo> => <any>)
  (def d (dist (circle-p c1) (circle-p c2)))
  (def a (/ (+ (- (* (circle-r c1) (circle-r c1))
                  (* (circle-r c2) (circle-r c2)))
               (* d d))
            (* 2 d)))
  (def p2 (point (+ (point-x (circle-p c1))
                    (/ (* a
                          (- (point-x (circle-p c2))
                             (point-x (circle-p c1))))
                       d))
                 (+ (point-y (circle-p c1))
                    (/ (* a
                          (- (point-y (circle-p c2))
                             (point-y (circle-p c1))))
                          d))
                 ))
  (def h (sqrt (abs (- (* (circle-r c1) (circle-r c1))
                  (* a a)))))
  (def rsx (/ (* h
                 (- (point-y (circle-p c2))
                    (point-y (circle-p c1))))
              d))
  (def rsy (/ (* h
                 (- (point-x (circle-p c2))
                    (point-x (circle-p c1))))
              d))
  
  (line (point (+ (point-x p2)
                  rsx)
               (- (point-y p2)
                  rsy))
        (point (- (point-x p2)
                  rsx)
               (+ (point-y p2)
                  rsy)))
  )

(dm line-point-by-param (l|<gui-line-flo> u|<flo> => <gui-point-flo>)
  (point (+ (point-x (line-p1 l))
            (* u (- (point-x (line-p2 l)) (point-x (line-p1 l)))))
         (+ (point-y (line-p1 l))
            (* u (- (point-y (line-p2 l)) (point-y (line-p1 l))))))
  )

;; Intersection of a circle and a point is returned as a vector
;;  as there can be 0, 1, or 2 points of intersection.
(dm intersect (c|<gui-circle-flo> l|<gui-line-flo> => <any>)
  (def p1 (line-p1 l))
  (def p2 (line-p2 l))
  (def p3 (circle-p c))
  (def a (+ (* (- (point-x p2) (point-x p1))
               (- (point-x p2) (point-x p1)))
            (* (- (point-y p2) (point-y p1))
               (- (point-y p2) (point-y p2)))))
  (def b (* 2
            (+ (* (- (point-x p2) (point-x p1))
                  (- (point-x p1) (point-x p3)))
               (* (- (point-y p2) (point-y p1))
                  (- (point-y p1) (point-y p3))))))
  (def c (fold+ +
                (vec
                 (* (point-x p3) (point-x p3))
                 (* (point-y p3) (point-y p3))
                 (* (point-x p1) (point-x p1))
                 (* (point-y p1) (point-y p1))
                 (* -2 (* (point-x p3) (point-x p1)))
                 (* -2 (* (point-y p3) (point-y p1)))
                 (* -1 (* (circle-r c) (circle-r c))))))
  (def det (- (* b b)
              (* (* 4 a)
                 c)))
  (cond
    ((< det 0) ;; No intersection
     (vec)
     )
    ((== det 0) ;; One point
     (vec (line-point-by-param l (/ (* -1 b) (* 2 a))))
     )
    ((> det 0) ;; Two points
     (def u1 (/ (+ (* -1 b)
                   (sqrt det))
                (* 2 a)))
     (def u2 (/ (- (* -1 b)
                   (sqrt det))
                (* 2 a)))
     (vec (line-point-by-param l u1)
          (line-point-by-param l u2))
     )
    )
  )

;; end fishy

; In the GDK, a drawable area is generally going to be implemented as:
;  - A GTK Drawing Area (gtk_drawing_area_new)
;  - Backed by a Pixmap

; We call our widget that is a drawable backed by a paintbox a... imagebox!

; When drawing, we need a Graphics Context (gc), which has a 
; Colormap.

(dc <gui-drawable> (<gui-widget>))

; Different prefix-space because this is implementation specific
(dc <gdk-colormap> (<gui>))

(dc <gdk-gc> (<gui>))
 (dp colormap (<gdk-gc> => <gdk-colormap>))

; <gui-drawable> slots
 (dp gc (<gui-drawable> => (t? <gdk-gc>)) #f)


(dc <gui-paintbox> (<gui-drawable>))

(dm gui-paintbox (=> <gui-paintbox>)
  (msg out "Constructing a paintbox...\n")
  (let ((paintbox (new <gui-paintbox>))
        (handle (gtk_drawing_area_new)))
    (set (handle paintbox) handle)
    (gtk_widget_set_size_request handle 320 200) ; SIZE!!!
    (gtk_widget_show handle)
    ; (set (gc paintbox) (gdk-gc paintbox))
    (msg out "Returning paintbox...\n")
    paintbox
    )
  )

; A canvas is equivalent to a GDK Pixmap
(dc <gui-canvas> (<gui-drawable>))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; FIX!
(dm gui-canvas ((paintbox <gui-paintbox>)  => <gui-canvas>)
  (msg out "Constructing a canvas for %=\n" paintbox)  
  (let ((canvas (new <gui-canvas>))
        (handle (gdk_pixmap_new (_GtkWidget_window_get (handle paintbox))
                                320
                                200
                                24))
        )
    (set (handle canvas) handle)
    (okie? handle "Canvas screwed")
    ; (set (gc canvas) (gdk-gc canvas))
    (msg out "Returning canvas...\n")
    canvas
    )
  )

(dm gui-canvas-ext ((paintbox <gui-paintbox>) (width <int>) (height <int>)  => <gui-canvas>)
  (msg out "Constructing a canvas for %=\n" paintbox)  
  (let ((canvas (new <gui-canvas>))
        (handle (gdk_pixmap_new (_GtkWidget_window_get (handle paintbox))
                                width
                                height
                                24))
        )
    (set (handle canvas) handle)
    (okie? handle "Canvas-ext screwed")
    ; (set (gc canvas) (gdk-gc canvas))
    (msg out "Returning canvas...\n")
    canvas
    )
  )

(dm free (canvas|<gui-canvas>)
  ; Liquidate gc
  (when (and (prop-bound? canvas gc)
             (gc canvas))
    (free (gc canvas))
    )
  ; Liquidate our handle
  (unless (= (handle canvas) NULL)
    (g_object_unref (handle canvas))
    (set (handle canvas) NULL))
  )

; note, does not call 'drawable' generic on the passed-in drawable.
; For a canvas, which is a drawable, we do not need to use the window. (a pixmap doesn't have one!)
(dm gdk-gc ((drawable <gui-drawable>) => <gdk-gc>)
  (msg out "Alloc'ing a gc for %=\n" drawable)
  (let ((gc (new <gdk-gc>))
        (handle (gdk_gc_new (drawable-handle drawable))))
    (set (handle gc) handle)
    (set (colormap gc) (gdk-colormap))
    (okie? handle "GC Screwed")
    (msg out "Returning the gc...\n")
    gc
    )
  )

(dm free ((gc <gdk-gc>))
  ; kill our colormap
  (free (colormap gc))
  ; Liquidate our handle
  (unless (= (handle gc) NULL)
    (g_object_unref (handle gc))
    (set (handle gc) NULL))
  )

; -colors-
; So working with colors is apparently a bitch. The GdkColor structure 
;  holds r,g,b, and pixel fields.  You fill in r,g, and b and then need
;  to have your color added to a colormap.  Although in true color a lot
;  of this behavior is probably NOP'ed out, it probably behooves us to 
;  implement things properly.  As such, gui-color runs into the craptastic
;  problem that the objects have state and must be realized into a colormap.
; My dubious kludge is this:
;  Colors will have a field that references the colormap they've been realized
;  into.  Before we use a color we make sure it's been realized into the 
;  current colormap, if it hasn't, we add it.  If it's been previously realized
;  into another dude, we remove the color from the colormap.  This may very
;  possibly yield horrible and bad behavior in somewhat simple cases, but since
;  we're going to assume that we're probably going to be on true color displays
;  anyways where this isn't needed, we're just playing it safe.


(dm gdk-colormap ( => <gdk-colormap>)
  (msg out "Alloc'ing a colormap...\n")
  (let ((colormap (new <gdk-colormap>))
        (handle (gdk_colormap_new (gdk_visual_get_system) gtk_true)))
;        (handle (gdk_colormap_new (handle visual) gtk_true)))
    (set (handle colormap) handle)
    (okie? handle "Colormap screwed")
    (msg out "Returning the colormap...")
    colormap
    )
  )

(dc <gui-color> (<gui>))
 (dp realized-into (<gui-color> => <any>) #f) ; <gdk-colormap> as type

; r, g, b range from 0 to 255
(dm color ((r <int>) (g <int>) (b <int>) => <gui-color>)
  (let ((color (new <gui-color>))
        (handle (new__GdkColor)))
    (set (handle color) handle)
    (okie? handle "Color screwed")
    (_GdkColor_red_set handle (* r 256))
    (_GdkColor_green_set handle (* g 256))
    (_GdkColor_blue_set handle (* 256 b))
    color
    )
  )

(dm color-hsb (hue|<flo> saturation|<flo> brightness|<flo>)
  (def h (* (- hue (as <flo> (floor hue)))
            6.0))
  (def f (- h (as <flo> (floor h))))
  (def p (* brightness (- 1.0 saturation)))
  (def q (* brightness (- 1.0 (* saturation f))))
  (def t (* brightness (- 1.0 (* saturation (- 1.0 f)))))

  (case (floor h)
    ((0)
     (color (floor (+ (* brightness 255.0) 0.5))
            (floor (+ (* t 255.0) 0.5))
            (floor (+ (* p 255.0) 0.5)))
     )
    ((1)
     (color (floor (+ (* q 255.0) 0.5))
            (floor (+ (* brightness 255.0) 0.5))
            (floor (+ (* p 255.0) 0.5)))
     )
    ((2)
     (color (floor (+ (* p 255.0) 0.5))
            (floor (+ (* brightness 255.0) 0.5))
            (floor (+ (* t 255.0) 0.5)))
     )
    ((3)
     (color (floor (+ (* p 255.0) 0.5))
            (floor (+ (* q 255.0) 0.5))
            (floor (+ (* brightness 255.0) 0.5)))
     )
    ((4)
     (color (floor (+ (* t 255.0) 0.5))
            (floor (+ (* p 255.0) 0.5))
            (floor (+ (* brightness 255.0) 0.5)))
     )
    ((5)
     (color (floor (+ (* brightness 255.0) 0.5))
            (floor (+ (* p 255.0) 0.5))
            (floor (+ (* q 255.0) 0.5)))
     )
    )
  )

(dm free ((color <gui-color>))
  (delete__GdkColor (handle color))
  )

(dm realize ((color <gui-color>) (colormap <gdk-colormap>))
  ; Only have work to do if it hasn't been realized into the current colormap.
  (unless (= (realized-into color) colormap)
    ; Kill off any prior realizations
    (if (realized-into color)
        (gdk_colormap_free_colors (handle (realized-into color)) (tup (handle color))))
    ; Now realize the color in
    (gdk_colormap_alloc_color (handle colormap) (handle color) gtk_false gtk_true)
    (set (realized-into color) colormap)
    )
  )

(dm fg-setter ((color <gui-color>) (gc <gdk-gc>))
  (realize color (colormap gc))
  (gdk_gc_set_foreground (handle gc) (handle color))
  )

(dm bg-setter ((color <gui-color>) (gc <gdk-gc>))
  (realize color (colormap gc))
  (gdk_gc_set_background (handle gc) (handle color))
  )

; Font abstraction stuff...
(dc <gui-font> (<gui>))

//(dv font-lucida "-*-lucida-medium-r-normal-*-14-*-*-*-p-*-*-1")
(dv font-lucida "-*-lucida-medium-r-normal-*-16-*-*-*-p-*-*-1")

(dm font (name|<str> => <gui-font>)
  (def da-font (new <gui-font>))
  (set (handle da-font) (gdk_font_load name))
  da-font
  )

(dm free (font|<gui-font>)
  (gdk_font_unref (handle font))
  (set (handle font) NULL)
  )

(dv *default-samurui-font* #f)

(dm get-default-samurui-font ()
  (unless *default-samurui-font*
    (set *default-samurui-font* (font font-lucida)))
  *default-samurui-font*
  )
                                    
; GUI ImageBox is a composite of gui-paintbox and gui-canvas
; I was very dubious about the relation of who owns whom, so for the time being
;  they're both the children of the imagebox.  Of course, I've got this little
;  voice telling me that the PaintBox should own the canvas, but that's much
;  more likely to mask errors and cause problems down the road.
; Dammit. I don't want the handle slot here. I guess this shows that I should actually
;  have the framework set up so that <gui> and its descendents are interfaces and then
;  there is a GTK signature that gets mixed in... I'll wait a bit longer before refactoring
;  though, as I'm sure I'll learn more.
(dc <gui-imagebox> (<gui-drawable>))
 (dp paintbox (<gui-imagebox> => <gui-paintbox>))
 (dp canvas (<gui-imagebox> => <gui-canvas>))

(dc <interface-drawing-area> (<gui-imagebox>))

(dm gui-imagebox (=> <gui-imagebox>)
  (let ((imagebox (new <gui-imagebox>)))
    (set (paintbox imagebox) (gui-paintbox))
    (set (canvas imagebox) (gui-canvas (paintbox imagebox)))
    (set (handle imagebox) (handle (paintbox imagebox))) ; make the paintbox handle the default handle we use...
    imagebox
    )
  )

(dm free ((imagebox <gui-imagebox>))
  (free (paintbox imagebox))
  (free (canvas imagebox))
  (set (handle imagebox) NULL) ; it belonged to the canvas anyways
  )

(dm reconfigure ((imagebox <gui-imagebox>) (gtk-widget <loc>))
  ; Kill off the canvas
  (free (canvas imagebox))

  (let ((width (_GdkRectangle_width_get (_GtkWidget_allocation_get (handle imagebox))))
        (height (_GdkRectangle_height_get (_GtkWidget_allocation_get (handle imagebox))))
        (style (_GtkWidget_style_get (handle imagebox)))
        )

    (debugstr "@@@ Reconfiguring imagebox for %= by %= @@@\n" width height) 

    (set (canvas imagebox) (gui-canvas-ext (paintbox imagebox) width height))

    (gdk_draw_rectangle (drawable-handle (canvas imagebox))
                        (_GtkStyle_white_gc_get style)
                        gtk_true
                        0
                        0
                        width
                        height)
    )
  )

(dm blank (imagebox|<gui-drawable>)
  (let ((width (_GdkRectangle_width_get (_GtkWidget_allocation_get (handle imagebox))))
        (height (_GdkRectangle_height_get (_GtkWidget_allocation_get (handle imagebox))))
        (style (_GtkWidget_style_get (handle imagebox)))
        )

    (gdk_draw_rectangle (drawable-handle (canvas imagebox))
                        (_GtkStyle_white_gc_get style)
                        gtk_true
                        0
                        0
                        width
                        height)
    )
  )

; Helper accessors to get drawable's (in case the thing we need is hidden away)
(dm drawable ((gui-drawable <gui-drawable>) => <gui-drawable>)
  gui-drawable
  )

(dm drawable ((gui-imagebox <gui-imagebox>) => <gui-drawable>)
  (canvas gui-imagebox)
  )

(dm get-gc ((drawable <gui-drawable>) => <gdk-gc>)
  (when (not (gc drawable))
    (set (gc drawable) (gdk-gc drawable))
    )
  (gc drawable)
  )

(dm get-gc ((gui-imagebox <gui-imagebox>) => <gdk-gc>)
  (get-gc (canvas gui-imagebox))
  )

; -event hooks-
; Provide default event hooks for widgets

(df hook-configure-event (data widget event)
  (debugstr "Got configure event!\n")
  (reconfigure data widget)
  #t
  )

(df hook-expose-event (data widget event)
    (let ((area (_GdkEventExpose_area_get event))
          (r-area (new <gdk-rect>)))
      (set (handle r-area) area)
      (repaint data r-area)
      )
    #t
    )

(dg mouse-press (widget x|<int> y|<int> button|<int> time|<int>))

(dg mouse-release (widget x|<int> y|<int> button|<int> time|<int>))

(dg mouse-move (widget x|<int> y|<int> state|<int>))

(df hook-mouse-press (data widget event)
  (mouse-press data ; data is our widget... widget is their widget!               
               (round (_GdkEventButton_x_get event))
               (round (_GdkEventButton_y_get event))
               (_GdkEventButton_button_get event)
               (_GdkEventButton_time_get event)
               )
  #t
  )

(df hook-mouse-release (data widget event)
  (mouse-release data ; data is our widget... widget is their widget!               
                 (round (_GdkEventButton_x_get event))
                 (round (_GdkEventButton_y_get event))
                 (_GdkEventButton_button_get event)
                 (_GdkEventButton_time_get event)
                 )
  #t
  )

(df hook-mouse-move (data widget event)
  (let ((vRet (gdk_window_get_pointer (_GdkEventMotion_window_get event)))
        (x (elt vRet 1))
        (y (elt vRet 2))
        (state (elt vRet 3)))
    (mouse-move data
                (round x)
                (round y)
                state)
    )
  #t
  )
              
(dm hookify ((imagebox <gui-imagebox>))
  (let ((hWidget (handle (paintbox imagebox)))
        (cb-mouse-press (goo_safeCreateCallback hook-mouse-press imagebox))
        (cb-mouse-release (goo_safeCreateCallback hook-mouse-release imagebox))
        (cb-mouse-move (goo_safeCreateCallback hook-mouse-move imagebox))
        (cb-expose-event (goo_safeCreateCallback hook-expose-event imagebox))
        (cb-configure-event (goo_safeCreateCallback hook-configure-event imagebox)))
    (g_signal_connect hWidget "button_press_event" (gtk_getBoolEventCallback) cb-mouse-press)
    (g_signal_connect hWidget "button_release_event" (gtk_getBoolEventCallback) cb-mouse-release)
    (g_signal_connect hWidget "motion_notify_event" (gtk_getBoolEventCallback) cb-mouse-move)
    (g_signal_connect hWidget "expose_event" (gtk_getBoolEventCallback) cb-expose-event)
    (g_signal_connect hWidget "configure_event" (gtk_getBoolEventCallback) cb-configure-event)
    
    ;; ask to receive events the drawing area doesn't normally subscribe to
    (gtk_widget_set_events hWidget (| (| (| (| (| (| (gtk_widget_get_events hWidget)
                                                     GDK_BUTTON_PRESS_MASK)
                                                  GDK_BUTTON_RELEASE_MASK)
                                               GDK_POINTER_MOTION_MASK)
                                            GDK_POINTER_MOTION_HINT_MASK)
                                         GDK_EXPOSURE_MASK)
                                      GDK_STRUCTURE_MASK))
    )
  )

(dm repaint ((widget <any>) (r <rectangle>))
  ;;(msg out "Dummy repaint...\n")
  #f)

(dm repaint ((imagebox <gui-imagebox>) (r <rectangle>))
  ;;(msg out "Repainting an imagebox...\n")
  (draw-blit (paintbox imagebox)
             (canvas imagebox)
             (rect-x r)
             (rect-y r)
             (rect-x r)
             (rect-y r)
             (rect-w r)
             (rect-h r)
             )
  )
             

(dm mouse-click ((widget <any>) (x <int>) (y <int>) (button <int>))
  #f)

(dm mouse-move ((widget <any>) (x <int>) (y <int>) (state <int>))
  #f)

; -drawing-

; I think this will resolve the problem with needing a drawable-handle off of someone
(dm drawable-handle ((canvas <gui-canvas>))
  (handle canvas)
  )

(dm drawable-handle ((paintbox <gui-paintbox>))
  (_GtkWidget_window_get (handle paintbox))
  )

(dm drawable-handle ((imagebox <gui-imagebox>))
  (drawable-handle (canvas imagebox))
  )

; All drawing routines take a drawable that we then call 'drawable' on to make sure we're
;  grabbing the right handle out.  This is important for compositions of widget and backing
;  buffer such as <gui-imagebox>

(dm draw-blit ((target <gui-drawable>) (source <gui-drawable>) (sx <int>) (sy <int>) (dx <int>) (dy <int>) (w <int>) (h <int>))
  (gdk_draw_drawable (drawable-handle target)
                     (handle (get-gc target))
                     (drawable-handle source)
                     sx sy dx dy w h
                     )
  )
                     
        
(dm draw-rect ((canvas <gui-drawable>) (rect <gui-rect>) (filled <log>) (color <gui-color>))
  (let ((gc (get-gc canvas)))
    ; Set the color
    (set (fg gc) color)
    ; Draw the rectangle
    (gdk_draw_rectangle (drawable-handle canvas)
                        (handle gc)
                        (log-to-gtk filled)
                        (rect-x rect)
                        (rect-y rect)
                        (rect-w rect)
                        (rect-h rect)
                        )
    )
  )

(dm draw-arc ((canvas <gui-drawable>) (rect <gui-rect>) (ang1 <flo>) (ang2 <flo>) (filled <log>) (color <gui-color>))
  (draw-arc canvas rect (round (* 64.0 ang1)) (round (* 64.0 ang2)) filled color)
  )

(dm draw-arc ((canvas <gui-drawable>) (rect <gui-rect>) (ang1 <int>) (ang2 <int>) (filled <log>) (color <gui-color>))
  (let ((gc (get-gc canvas)))
    ; Set the color
    (set (fg gc) color)
    ; Draw the rectangle
    (gdk_draw_arc (drawable-handle canvas)
                  (handle gc)
                  (log-to-gtk filled)
                  (rect-x rect)
                  (rect-y rect)
                  (rect-w rect)
                  (rect-h rect)
                  ang1
                  (- ang2 ang1))
    )
  )

(dm draw-line (canvas|<gui-drawable> x1|<int> y1|<int> x2|<int> y2|<int> color|<gui-color>)
  (let ((gc (get-gc canvas)))
    ;; Set the color
    (set (fg gc) color)
    ;; Draw the rectangle
    (gdk_draw_line (drawable-handle canvas)
                   (handle gc)
                   x1 y1 x2 y2)
    )
  )

(dm draw-string (canvas|<gui-drawable> font|<gui-font> x|<int> y|<int> string|<str> color|<gui-color>)
  (let ((gc (get-gc canvas)))
    ;; Set the color
    (set (fg gc) color)
    ;; Draw the rectangle
    (gdk_draw_string (drawable-handle canvas)
                     (handle font)
                     (handle gc)
                     x y string)
    )
  )

(dm string-width (font|<gui-font> string|<str> => <int>)
  (gdk_string_width (handle font) string)
  )

(dm string-height (font|<gui-font> string|<str> => <int>)
  (gdk_string_height (handle font) string)
  )

(dm font-ascent (font|<gui-font>)
  (_GdkFont_ascent_get (handle font))
  )

(dm font-height (font|<gui-font>)
  (+ (_GdkFont_ascent_get (handle font))
     (_GdkFont_descent_get (handle font)))
  )

(dm invalidate-all (widget|<gui-widget>)
  (invalidate widget (rect 0 0 (gui-width widget) (gui-height widget)))
  )

(dm invalidate ((imagebox <gui-imagebox>) (r <gui-rect>))
  (invalidate (paintbox imagebox) r)
  )

(dm invalidate ((window <gui-drawable>) (r <gui-rect>))
  (def my-gdk-rect (rect-to-gdk r))
  (invalidate window my-gdk-rect)
  (free my-gdk-rect)
  )

(dm invalidate ((window <gui-drawable>) (r <gdk-rect>))
  ;; (msg out "Invalidating a drawable...\n")
  (gdk_window_invalidate_rect (drawable-handle window) ; better not be a pixmap...
                              (handle r)
                              gtk_false
                              )
  )

; -bindings-
;
; The task of a binding can be thought of to be similar to an enzyme.  For it to
;  be useful it must lock onto both the GUI object in question and the object 
;  that is supposed to be represented.
;
; We want:
; * The GUI state to be initialized to conform with the state of the object
; * Updates to the GUI to be reflected in the object
; * Updates to the object to be reflected in the GUI.
;
; Given that the lifetime of the enzyme and GUI object should outlive the attachment
;  to the object, we want to be able to de-couple and re-couple easily and without
;  creating horrible memory and resource leaks.
;
; As such, we want a binding to provide three functions once initial setup has been done
; 1: Re-bind to a new object, so that GUI actions are triggered on the right objects.
; 2: Refresh the GUI state to be in-sync with the object.
; 3: De-bind
;
; Given the design of everything, it makes sense for bindings to exist on a property-level
;  granularity. 

(df nop () )

(dm bind ((gui-obj <gui>) (getter <fun>) (setter <fun>) => (tup <fun> <fun> <fun>))
  (tup identity nop identity)
  )

; Constructs a binding
(dm bind ((textbox <gui-textbox>) (getter <fun>) (setter <fun>) => (tup <fun> <fun> <fun>))
  (let ((cur-obj #f)
        (callback (fun (data widget)
                    ;(msg out "Callback!\n")
                    (setter (gtk_entry_get_text (handle textbox))
                            cur-obj)
                    (msg out "Callback done!\n")
                    )))

    ; Establish our hooks into the gui object
    (g_signal_connect (handle textbox)
                      "activate"
                      (gtk_getGtkCallback)
                      (goo_safeCreateCallback callback 0))

    ; Construct the helper functions
    (tup 
                                        ; Establish re-binder
     (fun (new-obj)
       ;(msg out "Rebinding!\n")
       (set cur-obj new-obj)
       )
                                        ; Establish refresher
     (fun ()
       ;(msg out "Refreshing!\n")
       (gtk_entry_set_text (handle textbox) (as <str> (getter cur-obj)))
       )

                                        ; This is where we would de-bind if memory 
                                        ; weren't so cheap that we don't need to 
                                        ; worry about memory leaks.
                                        ; (ha ha ha, I'm funny.)
                          ; But really, it would be a good idea to free stuff here.
     (fun ()
       ; free your mind!
       )
     )
    )
  )

; Constructs a binding
(dm bind ((toggle <gui-toggle-button>) (getter <fun>) (setter <fun>) => (tup <fun> <fun> <fun>))
  (let ((cur-obj #f)
        (callback (fun (data widget)
                    ;(msg out "Callback!\n")
                    (setter (gtk-to-log (gtk_toggle_button_get_active (handle toggle)))
                            cur-obj)
                    ;;(msg out "Callback done!\n")
                    )))

    ; Establish our hooks into the gui object
    (g_signal_connect (handle textbox)
                      "toggled"
                      (gtk_getGtkCallback)
                      (goo_safeCreateCallback callback 0))

    ; Construct the helper functions
    (tup 
                                        ; Establish re-binder
     (fun (new-obj)
       ;(msg out "Rebinding!\n")
       (set cur-obj new-obj)
       )
                                        ; Establish refresher
     (fun ()
       ;(msg out "Refreshing!\n")
       (gtk_entry_set_active (handle toggle) (log-to-gtk (getter cur-obj)))
       )

                                        ; This is where we would de-bind if memory 
                                        ; weren't so cheap that we don't need to 
                                        ; worry about memory leaks.
                                        ; (ha ha ha, I'm funny.)
                          ; But really, it would be a good idea to free stuff here.
     (fun ()
       ; free your mind!
       )
     )
    )
  )

;;; ----                     ----
;;; ------ VisiCollections ------
;;; ----                     ----

;;; The protocol for dealing with graphs/collections needs to be:
;;;  - Relatively Simple
;;;  - External to the nodes; ideally the collection should be backable by a database store,
;;;     allowing user interaction with a subset of the store at a time so as to prevent massive
;;;     thrash-death.
;;;  - Easily reducible to efficient tree-behavior.
;;;
;;; Support for these behaviors from a node perspective should be easy/transparent. To this end:
;;;  - Properties should be easily annotated to be _named_ edges.
;;;  
;;; NOTE! All collections returns are treated as if they are immutable, so for efficiency purposes
;;;  provides of the interface *can* expose internal reps safely.

;; ------------------------
;; Initial Node Information - we need a way to arbitrarily decide on an initial node
;;  in the case of db-backed collections.
;; ------------------------

(dc <visi-col> (<any>))

(dc <visi-wrap-col> (<visi-col>))
 (dp wrapped (<visi-wrap-col> => <col>))
 (dp parent-hash (<visi-wrap-col> => <tab>) (fab <tab> 0))

(dm visi-wrap-col (to-wrap|<col> => <visi-wrap-col>)
  (def vwc (new <visi-wrap-col>))
  (set (wrapped vwc) to-wrap)
  vwc
  )

(dm get-start-node (vwc|<visi-wrap-col> => <any>)
  (wrapped vwc)
  )

;; ----------------
;; Node-Information
;; ----------------

(dm node-label (c node => <str>)
  (to-str node)
  )

;; node-weight is expected to provide information for visualizations that rely on some form of magnitude to create a useful
;;  visualization.  eg treemap, starburst, etc.  All visualizations rely on container objects to provide the aggregate weight
;;  of the things it contains, and will not traverse the sub-structure to calculate it.  Eg, in the case of file-systems, 
;;  we expect that the visi-col will pre-calculate, or calculate on demand, the total disk usage of a given directory.

(dm node-weight (c node => <flo>)
  1.0
  )

(dm node-browsable (c node => <log>)
  #t
  )

;;; to-call should be of the form (fun (node) ...)
;;; it is assumed you will know what collection we are talking about.
;;;  (this is a dubious assumption to make, but arguably it is more
;;;  efficient for the variable to be closed-over than to be passed
;;;  every damn time.)
(dm register-node-add-notification(c to-call)
  #f
  )

(dm remove-node-add-notification (c was-called)
  #f
)

;;; to-call should be of the form: (fun (from to) ...)
;;; it is assumed you will know what collection we are talking about.
;;;  (this is a dubious assumption to make, but arguably it is more
;;;  efficient for the variable to be closed-over than to be passed
;;;  every damn time.)
(dm register-edge-add-notification(c to-call)
  #f
  )

(dm remove-edge-add-notification (c was-called)
  #f
)

;; It's generally good to have a simple label for a given node.  Note that we are not using to-str
;;  because that is a function of only the node, whereas we want the collection to be the control
;;  factor. The colleciton can of course defer to to-str if it is so inclined. 
(dm node-label (vwc|<visi-wrap-col> node => <str>)
  (if (and (isa? node <col>) (not (isa? node <str>)))
      "Collection"
      (to-str node)
      )
  )

;; Our weight is 1.0 if we are a leaf, or the sum of the weights of our children if we're a collection.
;;  Of course, we're screwed if there are loops/recursion in our structure.
(dm node-weight (vwc|<visi-wrap-col> node => <flo>)
  (if (and (isa? node <col>) (not (isa? node <str>)))
      (fold+ + (map (fun (x) (node-weight vwc x)) node))
      1.0)
  )

(dm node-browsable (vwc|<visi-wrap-col> node => <log>)
  (not (and (isa? node <col>) (not (isa? node <str>))))
  )

;; ----------------
;; Edge-Information
;; ----------------

;; Returns a list of the axes supported by the nodes
(dm node-axes (vwc|<visi-wrap-col> => <col>)
  (vec "implicit")
  )

;; Retrieves the edges associated with the given axis for the node.
(dm node-out-edges (vwc|<visi-wrap-col> axis node => <col>)
  (if (and (isa? node <col>) (not (isa? node <str>)))
      (seq
        ;; Make sure the parent links are there
        (do (fun (x) 
              (set (elt (parent-hash vwc) x) node))
            node)
        ;; Now return the collection
        node
        )
      (empty <vec>))
  )


(dm node-in-edges (vwc|<visi-wrap-col> axis node => <col>)
  (def node-parent (elt-or (parent-hash vwc) node #f))
  (if node-parent
      (tup node-parent)
      (empty <tup>))
  )

(dm cat-with-commas (c|<col>)
  (def did-first #f)
  (def str-so-far "")
  (do (fun (cur)
        (when did-first
          (set str-so-far (cat str-so-far ", "))
          )
        (set str-so-far (cat str-so-far cur))
        (set did-first #t)
        )
      c
      )
  str-so-far
  )

(dm axis-to-str (vc|<visi-col> axis node => <str>)
  (def axis-val (node-out-edges vc axis node))
  (case (len axis-val)
    ((0) "")
    ((1) (to-str (1st axis-val)))
    (#t (cat-with-commas (map to-str axis-val)))
    )
  )

(dc <gui-treeview-model> (<gui>))

(dc <gui-treeview> (<gui-widget>))
 (dp collection (<gui-treeview> => <visi-col>))
 (dp axis (<gui-treeview> => <any>) "implicit")
 (dp prop-axes (<gui-treeview> => <col>) (fab <vec> 0))
 (dp model (<gui-treeview> => <gui-treeview-model>))

(dm gui-treeview (=> <gui-treeview>)
  (def gtv (new <gui-treeview>))
  ; Dummy up the collection
  (set (collection gtv) (visi-wrap-col (vec "dummy-a" "dummy-b" "dummy-c")))
  ; Model
  (def gtv-model (new <gui-treeview-model>))
  (set (handle gtv-model) (gtk_tree_goo_new gtv))
  (set (model gtv) gtv-model)
  ; TreeView
  (set (handle gtv) (gtk_tree_view_new_with_model (handle gtv-model)))
  ; Add some columns for amusement purposes
  (def my-renderer (gtk_cell_renderer_text_new))
  (def column (gtk_tree_view_column_new))
  (gtk_tree_view_column_set_title column "Default")
  (gtk_tree_view_column_pack_start column my-renderer (log-to-gtk #t))
  (gtk_tree_view_column_add_attribute column my-renderer "text" 0)
  (gtk_tree_view_append_column (handle gtv) column)
  gtv
  )

(dm free (gtv|<gui-treeview>)
  (free (model gtv))
  (g_object_unref (handle gtv)) ; should set to NULL...
  )

; Constructs a binding
;; Rebind should update the underlying collection in the model
;; Refresh should tell the tree-view that it is getting the new / same model
;; Um, no freeing yet
(dm bind ((gtv <gui-treeview>) (getter <fun>) (setter <fun>) => (tup <fun> <fun> <fun>))
  (let ((my-gtv gtv)
        ;; Changed callback
        (callback (fun (selection data)
                    ;;Selection changed...
                    ;; (gtk_tree_selection_get_user_data selection)
                    )))

    ; Establish our hooks into the gui object
    (g_signal_connect (handle gtv)
                      "changed"
                      (gtk_getGtkCallback)
                      (goo_safeCreateCallback callback 0))

    ; Construct the helper functions
    (tup 
                                        ; Establish re-binder
     (fun (new-obj)
       ;(msg out "Rebinding!\n")
       (set (collection my-gtv) (visi-wrap-col (getter new-obj)))
       )
                                        ; Establish refresher
     (fun ()
       ;(msg out "Refreshing!\n")
       (gtk_tree_goo_refresh (handle (model my-gtv))) ;yes this does go first
       (gtk_tree_view_set_model (handle my-gtv) NULL)
       (gtk_tree_view_set_model (handle my-gtv) (handle (model my-gtv)))
       )

                                        ; This is where we would de-bind if memory 
                                        ; weren't so cheap that we don't need to 
                                        ; worry about memory leaks.
                                        ; (ha ha ha, I'm funny.)
                          ; But really, it would be a good idea to free stuff here.
     (fun ()
       ; free your mind!
       )
     )
    )
  )

;; /// TreeView Function Callees

(dm gtk-tv-get-n-columns (gtv|<gui-treeview>)
  (+ 1 (len (prop-axes gtv)))
  )

(dm gtk-tv-get-start-node (gtv|<gui-treeview>)
  (get-start-node (collection gtv))
  )

(dm gtk-tv-get-label (gtv|<gui-treeview> node column|<int>)
  (def my-result
    (if (== 0 column)
        ;; If it's the first column, just use the node itself. (eg, don't traverse fundamental axis)
        (to-str (node-label (collection gtv) node))
        (seq
          ;; Other column -> use property axes
          (def prop-axis (elt (prop-axes gtv) column))
          (def props (node-out-edges (collection gtv) prop-axis node))
        (if (< 0 (len props))
            (to-str (1st props))
            "props issue...")
        )
        )
    )
  ;;(msg out "!!! I am returning: %=\n" my-result)
  my-result
  )

(dm gtk-tv-iter-children (gtv|<gui-treeview> node)
  (def kids (node-out-edges (collection gtv) (axis gtv) node))
  (if (< 0 (len kids))
      (1st kids)
      #f)
  )

(dm gtk-tv-iter-has-child (gtv|<gui-treeview> node => <log>)
  (def has-child (< 0 (len (node-out-edges (collection gtv) (axis gtv) node))))
  (msg out "%= has child: %=\n" node has-child)
  has-child
  )

(dm gtk-tv-iter-n-children (gtv|<gui-treeview> node => <int>)
  (def num-kids (len (node-out-edges (collection gtv) (axis gtv) node)))
  (msg out "Reporting %= kids\n" num-kids)
  num-kids
  )

(dm gtk-tv-iter-nth-child (gtv|<gui-treeview> node n)
  (def num-kids (len (node-out-edges (collection gtv) (axis gtv) node)))
  (if (< n num-kids)      
      (elt (node-out-edges (collection gtv) (axis gtv) node) n)
      (seq
        (msg out "Out of bounds iter-nth-child access (%= of %=)\n" n num-kids)
        #f
        )
      )
  )

(dm gtk-tv-iter-next-child (gtv|<gui-treeview> node)
  (def parent (gtk-tv-iter-parent gtv node))
  (def n (+ 1 (gtk-tv-node-pos-in-parent gtv node parent)))
  (def edges (node-out-edges (collection gtv) (axis gtv) parent))
  (if (>= n (len edges))
      (seq
        (msg out "I am saying there is no next (%= of %=)\n" n (len edges))
        #f
        )
      (elt edges n)
      )
  )

(dm gtk-tv-iter-parent (gtv|<gui-treeview> node)
  (def da-parent (node-in-edges (collection gtv) (axis gtv) node))
  (if (and da-parent 
           (< 0 (len da-parent)))
      (1st da-parent)
      #f)
  )

(dm gtk-tv-iter-has-parent (gtv|<gui-treeview> node => <log>)
  (!= 0 (len (node-in-edges (collection gtv) (axis gtv) node)))
  )

(dm gtk-tv-node-pos-in-parent (gtv|<gui-treeview> node parent => <int>)
  (pos (node-out-edges (collection gtv) (axis gtv) parent) node)
  )

; ----           ----
; ------ Menus ------
; ----           ----

(dv *cached-menus* (fab <tab> 0))

;; indirection to avoid problem of statically connecting...
(dv *selected-menu-object* #f)

(dm gimme-menu (obj)
  (set *selected-menu-object* obj)
  (or (elt-or *cached-menus* (object-class obj) #f)
      (seq
        (def da-actions (get-all-actions (object-class obj)))
        
        (def da-menu (gui-menu))
        
        (do (fun (act)
              (def da-item (gui-menu-item-label (description act)))
;;              (connect da-item (method act) obj)
              (connect da-item 
                       (fun (x)
                         ((method act) *selected-menu-object*))
                       #f)
              (ad! da-menu da-item)
              (show da-item)
              )
            da-actions)
        
        (set (elt *cached-menus* (object-class obj)) da-menu)

        ;;(show-all da-menu)
        
        da-menu
        )
      )
  )

; ----                ----
; ------ Renderize! ------
; -----              -----

(dm renderize-model ((model <interface-model>) (info <interface-info>) (class <class>) (updaters <col>) (masters <tab>))
  (let ((payload (imodel-payload model)))
    (if (isa? payload <fun>)
        (payload info class updaters)
        (renderize payload class updaters masters)
        )
    )
  )

;; The master/slave thing requires some form of imodel-instantiation specific scratch space.
;;
;; Perhaps a runtime DOM-type tree is in order to store GUI configuration information...
;; 
;; The goal of master/slave is of course to allow the navigation of graph/collection structures,
;;  with the currently selected node displayed in the slave space.  Issues include:
;; - We want the collection to be able to be wildly heterogeneous, which means that the slave area
;;   must be instantiated at run-time.  (This requires better cleanup code certainly.)
;; - A master must be passed in a function to invoke when the currently selected node changes.  This
;;   should allow the slave to be transparently updated.  The only question is whether the slave should
;;   be allowed to persist configuration data in some way.  However, this seems clearly orthogonal 
;;   to the master/slave issue, as it's mainly a persistence issue that merely comes to the forefront
;;   when things are reinitialized extremely frequently.
;; * The simplest solution would be to cluster them together so that the 'master' item actually could
;;   have direct references to the slaves, but that would place a lot of un-needed limitations on 
;;   GUI design.
;; 
;; When we change the object represented in a slaved area, we want to kill off the people in there.
;;  This involves telling all the updaters to free, and killing off the objects in question.  Since
;;  we need to maintain a list of the updaters associated with an instantiated interface-model, it
;;  suggests that each instantiated interface model should have a control structure with the following:
;; - List of updaters
;; - Placeholder container
;; - Interface-model container that sits in the place-holder
;; - Method to change object reference, which:
;;    - Calls free on all updaters
;;    - Destroys the components in the interface-model container, as well as that container
;;    - Unlinks the interface-model container
;;    - Generates the new interface-model, and assumes its state.
;; 
;; This suggests that when it comes to creating master/slave pairs, we'll construct:
;; - A master object which maintains a list of slaves
;; - A slave object for each instantiation, as described above, which is added to the master's list.
;; To provide the master to the instantiated master block, we will define a bind-master generic.

(dc <gui-slave> (<any>))
 (dp slave-inited (<gui-slave> => <log>) #f)
 (dp slave-updaters (<gui-slave> => <col>))
 (dp placeholder (<gui-slave> => <gui-container>))
 (dp active-container (<gui-slave> => <gui-container>))
 (dp slave-object (<gui-slave> => <any>) #f)

(dm update-slave (slave|<gui-slave> new-obj|<any>)
  (cond 
    ;; First time
    ((not (slave-inited slave))
     (def model (find-interface-model (object-class new-obj) root-interface))
     (set (slave-updaters slave) (vec))
     (set (active-container slave) 
          (renderize-model model root-interface (object-class new-obj) (slave-updaters slave) (fab <str-tab> 0)))
     (ad! (placeholder slave) (active-container slave))
     (show-all (placeholder slave))
     (set (slave-inited slave) #t)
     (set (slave-object slave) new-obj)
     
     ;; Rebind and refresh
     (do (fun (cur-updater)
           ;; Rebind
           ((1st cur-updater) new-obj)
           ;; Refresh
           ((2nd cur-updater))
               )
         (slave-updaters slave)
         )
     )

    ;; Different object, same interface
    ((and (slave-object slave)
          (= (object-class (slave-object slave))
             (object-class new-obj)))
     ;; Just rebind and refresh
     (do (fun (cur-updater)
           ;; Rebind
           ((1st cur-updater) new-obj)
           ;; Refresh
           ((2nd cur-updater))
               )
         (slave-updaters slave)
         )
     
     (set (slave-object slave) new-obj)
     )

    ;; New object, go hard-core
    (#t
     ;; Free updaters
     (do (fun (cur-updater)
           ((3rd cur-updater))
           )
         (slave-updaters slave)
         )
     
     ;; Destroy components
     (rem! (placeholder slave) (active-container slave))
     ;; ...
     
     ;;
     )
    )
  )

(dc <gui-master> (<any>))
 (dp slaves (<gui-master> => <col>) (vec))

(dm master-update-slaves (master|<gui-master> new-obj|<any>)
  (do (fun (slave)
        (update-slave slave new-obj))
      (slaves master)
      )
  )

(dg bind-master (obj|<any> master|<gui-master>))

(dm renderize ((model-list <lst>) (class <class>) (updaters <col>) (masters <tab>))
  (let ((renderize-this (fun (thing)
                          (renderize thing class updaters masters)
                          )
                        ))    
    (cond
      ;; COLUMNS
      ((= (1st model-list) 'columns)
        ; Multiple parallel columns!
        ; Create an hbox and stick everything we fab in it
        (let ((hbox (gui-hbox))
              (comps (map renderize-this (tail model-list))))
          (add-all-opt! hbox comps)
          hbox))

      ;; MASTER
      ((= (1st model-list) 'master)
       (def m-name (as <str> (2nd model-list)))
       (def master (new <gui-master>))
       (set (elt masters m-name) master)
       ;; Renderize the third param. (Can be a list of just a node.)
       (def gui-obj (renderize (3rd model-list) class updaters masters))
       (bind-master gui-obj master)
       gui-obj
       )

      ;; SLAVE
      ((= (1st model-list) 'slave)
       (def s-name (as <str> (2nd model-list)))
       (def slave (new <gui-slave>))
       (add! (slaves (elt masters s-name)) slave)
       (set (placeholder slave) (gui-frame "Child..."))
       (placeholder slave)
       )
 
      ;; Attr
      ((= (1st model-list) 'attr)
       (def my-comp (renderize (elt model-list 1) class updaters masters))
       (set (attrs my-comp) (tail (tail model-list)))
       my-comp
       )

      ;; DEFAULT: VBOX
      (#t
       (let ((vbox (gui-vbox))
             (comps (map renderize-this model-list)))
         (add-all-opt! vbox comps)
         vbox
         )
       )
      )
    )
  )

(dm renderize ((act <interface-action>) (class <class>) (updaters <col>) (masters <tab>))
  (let ((button (gui-button (description act))))
    (let ((cur-obj #f))
      (connect button (fun (x) ((method act) cur-obj)) 0)

      (add!
       updaters
       (tup
        ;; Rebind
        (fun (new-obj)
          (set cur-obj new-obj))
        ;; Refresh
        (fun ()
          )
        ;; Free
        (fun ()
          )
        )
       )
      )
    button
    )
  )

(dm renderize ((text <str>) (class <class>) (updaters <col>) (masters <tab>))
  (gui-label text)
  )

(dm renderize ((sym <sym>) (class <class>) (updaters <col>) (masters <tab>))
  (let ((name (as <str> sym)))
;    (msg out "Find-action was: %=\n" (find-action class name))
;    (msg out "Find-property was: %=\n" (find-property class name))
;    (msg out "Was attempting to renderize the symbol %= (name %=)\n" sym name)
    (cond ((find-action class name)
           (renderize (find-action class name) class updaters masters))
          ((find-property class name)
           (let ((info (find-property class name)))
             (renderize-model (find-interface-model (type info) info) info class updaters masters)))
          )
    )
  )

(register-interface-model <str> (interface-model 
                                 (fun (x) 1)
                                 (fun (info class updaters)
                                   (let ((textbox (gui-textbox))
                                         (textbox-updater (bind textbox (getter info) (setter info))))
                                     (ad! updaters textbox-updater)
                                     textbox
                                     )
                                   )
                                 )
                          )

(register-interface-model <log> (interface-model 
                                 (fun (x) 1)
                                 (fun (info class updaters)
                                   (let ((checkbox (gui-check-button (description info)))
                                         (checkbox-updater (bind checkbox (getter info) (setter info))))
                                     (ad! updaters checkbox-updater)
                                     checkbox
                                     )
                                   )
                                 )
                          )

;(register-interface-model <col> (interface-model
;                                 (fun (x) 1)
;                                 (fun (info class updaters)
;                                   (def my-gtv (gui-treeview))
;                                   (def gtv-updater (bind my-gtv (getter info) (setter info)))
;                                   (ad! updaters gtv-updater)
;                                   my-gtv
;                                   )
;                                 )
;                          )

;;;;;;; EXPORTS
(export
  *default-samurui-font*
  get-default-samurui-font
  )



;; Classes
(export
  <interface-info>
  <interface-action>
  <interface-property>
  <interface-class-info>
  <interface-model>
  
  <gui>
  <gui-widget>
  
  <gui-container>
  <gui-window>
  <gui-box>
  <gui-vbox>
  <gui-hbox>

  <gui-button>
  <gui-toggle-button>
  <gui-check-button>
  
  <gui-label>
  <gui-textbox>

  <gui-menu>
  <gui-menu-item>
  <gui-menu-item-label>

  <rectangle>
  <gdk-rect>
  <gui-rect>

  <point>
  <gui-point>
  <gui-point-flo>
  <gdk-point>

  <gui-circle-flo>
  <gui-line-flo>

  <gui-drawable>
  <gdk-colormap>
  <gdk-gc>
  <gui-paintbox>
  <gui-canvas>
  <gui-color>
  <gui-font>
  <gui-imagebox>
  
  <interface-drawing-area>

  <visi-col>
  <visi-wrap-col>

  <gui-treeview-model>
  <gui-treeview>
  
  <gui-master>
  <gui-slave>
  )

;; Glorious functions
(export
  interface-action
  interface-property
  interface-class-info
  interface-model
  imodel-eval
  imodel-payload
  register-interface-model
  has-interface-model?
  get-interface-model
  get-interface-models
  find-interface-model
  
  add-all!
  add-all-opt!
  
  find-first-class
  get-class-info
  add-property
  add-action
  get-class-actions
  get-all-actions
  find-action
  get-class-properties
  get-all-properties
  find-property
  rebind-interface-model
  update-interface-model
  kill-gtk
  present
  
  log-to-gtk
  gtk-to-log
  free

  gui-width
  gui-height

  gui-window
  gui-vbox
  gui-hbox
  ad!
  ad-opt!
  show
  show-all
  gui-button
  connect
  gui-check-button
  gui-label
  gui-textbox
  gui-menu
  popup
  gui-menu-item-label
  gdk-rect
  rect-x
  rect-y
  rect-w
  rect-h
  grow!
  free
  rect
  rect-around
  rect-to-gdk
  shrink!
  point
  point-in-rect
  point-to-gdk
  gdk-point
  point-x
  point-y
  circle
  circle-p
  circle-p-setter
  circle-r
  circle-r-setter
  line
  line-p1
  line-p1-setter
  line-p2
  line-p2-setter
  dist
  sqdist
  intersect
  line-point-by-param
  gui-paintbox
  gui-canvas
  gui-canvas-ext
  gdk-gc
  gdk-colormap
  color
  color-hsb
  realize
  fg-setter
  bg-setter
  font
  gui-imagebox
  reconfigure
  blank
  drawable
  get-gc
  hookify
  repaint
  mouse-click
  mouse-move
  drawable-handle
  draw-blit
  draw-rect
  draw-arc
  draw-line
  draw-string
  string-width
  string-height
  font-ascent
  font-height
  invalidate-all
  invalidate
  bind
  visi-wrap-col
  get-start-node
  node-label
  node-weight
  node-browsable
  register-node-add-notification
  remove-node-add-notification
  register-edge-add-notification
  remove-edge-add-notification
  node-axes
  node-out-edges
  node-in-edges

  axis-to-str
  
  gui-treeview
  gtk-tv-get-n-columns
  gtk-tv-get-start-node
  gtk-tv-get-label
  gtk-tv-iter-children
  gtk-tv-iter-has-child
  gtk-tv-iter-n-children
  gtk-tv-iter-nth-child
  gtk-tv-iter-next-child
  gtk-tv-iter-parent
  gtk-tv-iter-has-parent
  gtk-tv-node-pos-in-parent
  
  gimme-menu
  renderize-model
  renderize

  mouse-press
  mouse-release
  mouse-move
  )

(export
  name
  name-setter
  method
  method-setter
  description
  description-setter
  type
  type-setter
  getter
  getter-setter
  setter
  setter-setter
  properties
  properties-setter
  actions
  actions-setter
  handle
  handle-setter
  attrs
  attrs-setter
  children
  children-setter
  colormap
  colormap-setter
  gc
  gc-setter
  realized-into
  realized-into-setter
  paintbox
  paintbox-setter
  canvas
  canvas-setter
  wrapped
  wrapped-setter
  parent-hash
  parent-hash-setter
  collection
  collection-setter
  axis
  axis-setter
  prop-axes
  prop-axes-setter
  model
  model-setter
  children
  children-setter
  bind-master
  master-update-slaves
  )

(export 
  debugstr
  iprop
  iaction
  imodel
  idrawmodel
  )

(export
  font-lucida
  )