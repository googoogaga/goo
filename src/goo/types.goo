;;;; Copyright 2002, Jonathan Bachrach.  See file TERMS.

(use goo/boot)
(use goo/macros)

;;; TYPE PROTOCOL
(exported
 ;; 3.9 TYPES
 <type>        ;; (dc <type> (<any>))
 isa?          ;; (dg isa?     (x|<any> t|<type> => <log>))
 subtype?      ;; (dg subtype? (t1|<type> t2|<type> => <log>))
 
 ;; 3.9.1 SINGLETONS
 <singleton>   ;; (dc <singleton> (<type>))
 type-object   ;; (dg type-object (x|<singleton> => <any>))
 (df t= (x))

 ;; 3.9.2 SUBCLASS
 <subclass>    ;; (dc <subclass> (<type>))
 type-class    ;; (dg type-class (x|<subclass> => <class>))
 (df t< (x))
 
 ;; 3.9.3 UNION
 <union>       ;; (dc <union> (<type>))
 union-elts    ;; (dp union-elts (x|<union> => <lst>))
 (df t+ (args|...))

 ;; 3.9.3 PRODUCT
 <product>    ;; (dc <product> (<type>))
 product-elts ;; (dp product-elts (<product> => <tup>))
 t*           ;; (df t* (args|...))

 ;; 3.9.4 CLASSES
 <class>               ;; (dc <class> (<type>))
 class-name            ;; (dg class-name (x|<class> => <sym>))
 class-parents         ;; (dg class-parents (x|<class> => <lst>))
 class-ancestors       ;; (dg class-ancestors (x|<class> => <lst>))
 class-direct-props    ;; (dg class-direct-props (x|<class> => <lst>))
 class-props           ;; (dg class-props (x|<class> => <lst>))
 class-descendents     ;; (dg class-descendents (x|<class> => <lst>))

 (df t? (x))
)

;; FIXME: should union-elts really be <lst> instead of <seq> and also
;; fix compiler to automatically copy optionals.
(df t+ (args|...) (new <union> union-elts (as <lst> args)))

(df t= (x) (new <singleton> type-object x))

(df t< (x) (new <subclass>  type-class x))

(df t? (x) (t+ x (t= #f)))

(need-implementation as len 2nd any? all2?)
