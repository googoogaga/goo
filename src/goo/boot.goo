;;;; Copyright (c) 2001 Jonathan Bachrach

;;; GOALS
;;;
;;; SIMPLEST POSSIBLE
;;; DYNAMIC ORDER FORM BY FORM
;;; MINIMIZE OBJECT SYSTEM BOOT OBFUSCATION
;;;
;;; TODO
;;; 
;;; o RENAME LOW PRIMITIVES TO HAVE TWO %%'s
;;; o INVENT NAMING CONVENTION FOR COMPILE TIME THINGS SAY &...?
;;; 

;; Early definitions, so we at least know false != true
(dv %false (%raw 0)) 
(dv %true (%raw 1))
(dv %check-types? (%raw 0))

(dv %*used-symbols-too-early* (%raw 0))

;;;
;;; BOOT OBJECTS
;;;

;; ALL PROTO'S NEEDED FOR BOOT ARE DEFINED HERE
;; THEY ARE DEFINED AS THEY WOULD BE OUTSIDE BOOT

(ct (df %boot-defs ()
      '((dv <any>    (isa <any>))
	(dv nul      (isa <any>))
	(dv nul-slot (isa <any>))
	(dv <log>    (isa <any>))
	(dv %true    (isa <log>))
	(dv %false   (isa <log>))
	(dv <chr> (isa <any>))
	  (slot <chr> (%chr-val <int>))
	(dv <num> (isa <any>))
	(dv <int> (isa <num>))
	  (slot <int> (%int-val <any>))
	(dv <flo> (isa <num>))
	  (slot <flo> (%flo-val <any>))
	(dv <loc> (isa <any>))
	  (slot <loc> (%loc-val <any>))
	(dv <col> (isa <any>))
	(dv <bag> (isa <col>)) ;; TODO: Gets redefined in runtime.proto???
	(dv <seq> (isa <col>))
	(dv <lst> (isa <seq>))
	(dv nil (isa <lst>))
	  (slot <lst> (head <any>) nil)
	  (slot <lst> (tail <lst>) nil)
	(dv <flat> (isa <seq>))
	(dv <vec> (isa <flat>))
	  (slot <vec> (%%vec-dat <any>)) ;; TODO: SHOULD RENAME LOWLEVEL
	(dv <str> (isa <flat>))
	  (slot <str> (%%str-dat <any>)) ;; TODO: SHOULD RENAME LOWLEVEL
	(dv <sym> (isa <any>))
	  (slot <sym> (sym-name <str>))
	(dv <traits> (isa <any>))
	  (slot <traits> (traits-owner <any>))
	  (slot <traits> (traits-direct-parents <lst>)  nil)
	  (slot <traits> (traits-direct-slots <lst>)    nil)
	  (slot <traits> (traits-parents <lst>)         nil)
	  (slot <traits> (traits-slots <lst>)           nil)
	  (slot <traits> (traits-direct-children <lst>) nil)
	  ;; ULTIMATELY NEED GENS TO BE FLUSHED DURING CLASS REDEF
	  ;; KEEP BOTH GENS/METS CAUSE NO MET->GEN MAP
	  ;; WANT TO PRUNE OUT UNNECESSARY GENS BASED ON ACTUAL METS
	  (slot <traits> (traits-gens <lst>)            nil)
	  (slot <traits> (traits-mets <lst>)            nil)
	  (slot <traits> (traits-forward <any>)         #f)
	(dv <slot> (isa <any>))
	  (slot <slot> (slot-owner <any>))
	  (slot <slot> (slot-getter <fun>))
	  (slot <slot> (slot-setter <fun>))
	  (slot <slot> (slot-type  <any>))
	  (slot <slot> (slot-init  <fun>) (fun (x) nul-slot))
	(dv <gen-cache> (isa <any>))
	  (slot <gen-cache> (gen-cache-singletons <lst>) nil)
	  (slot <gen-cache> (gen-cache-classes <lst>)    nil)
        (dv <sig> (isa <any>))
	  (slot <sig> (sig-names <lst>) nil)
	  (slot <sig> (sig-specs <lst>) nil)
	  (slot <sig> (sig-nary? <log>) %false)
	  (slot <sig> (sig-arity <int>) 0)
	  (slot <sig> (sig-value <any>) <any>)
	(dv <fun> (isa <any>))
	  (slot <fun> (fun-code <any>)  %false)
	  (slot <fun> (fun-name <any>)  %false)
	  (slot <fun> (fun-sig <sig>))
	(dv <met> (isa <fun>))
	  (slot <met> (fun-env <any>)   %false)
	(dv <gen> (isa <fun>))
	  (slot <gen> (fun-mets <lst>)  nil)
	  (slot <gen> (fun-cache <any>) %false))))

;; RETURN PROTO DEFS FROM BOOT DEFS

(ct (df %map-boot-protos (f)
      (rep loop ((res '()) (defs (%boot-defs)))
        (if (empty? defs)
	    (rev! res)
	    (loop (mif ((dv ,name (isa ,parent)) (head defs))
		       (pair (f name parent) res)
		       res)
		  (tail defs))))))

;; RETURN SLOT DEFS FROM BOOT DEFS

(ct (df %map-boot-slots (f)
      (rep loop ((res '()) (defs (%boot-defs)))
        (if (empty? defs)
	    (rev! res)
	    (loop (mif ((slot ,owner (,name ,type) ,@maybe-init) (head defs))
		       (let ((init (if (empty? maybe-init) 
	                               'nul-slot 
	                               (head maybe-init))))
			 (pair (f owner name type init) res)) 
		       res)
		  (tail defs))))))

;;;
;;; 1. BUILD EMPTY PROTOTYPE OBJECTS WITH TRAITS
;;;

(dv %traits-size         (%raw 9)) ;; DEP ON TRAITS LAYOUT
(dv %traits-owner-offset (%raw 0)) ;; DEP ON TRAITS LAYOUT

;; BUILD BASIC TRAITS OBJECT WITH OWNER RECORDED
;; TO BE COMPLETELY REPLACE IN DEFINE PARENTS BELOW

(dp %%traits (owner)
  (let ((traits (%make-object)))
    (%install-object-values traits %traits-size)
    (set (%slot-elt traits %traits-owner-offset) owner)
    traits))

;; BUILD BASIC STANDIN FOR PROTO 
;; REAL SLOTS AND TRAITS TO BE FILLED IN

(dp %object-shell ()
  (let ((proto (%make-object)))
    (set (%object-traits proto) (%%traits proto))
    proto))

(dss (%object-shells)
  `(seq ,@(%map-boot-protos 
	    (fun (name parent)
              `(dv ,name (%object-shell))))))

(%object-shells)

;; now false and true have their permanent values.

(dv %check-types?   #f) ;; READY FOR TYPE-CHECKING?
(dv %symbols-ready? #f) ;; READY TO BUILD SYMBOLS?

;;;
;;; 2. SETUP LST BASICS
;;;

;; CONSTRUCTION MACHINERY FOR BUILDING EARLY OBJECTS

(dp %object-of (owner size)
  (let ((proto (%make-object)))
    (set (%object-traits proto) (%object-traits owner))
    (set (%object-values proto) (%make-object-values size))
    proto))

;; STRUCTURES ARE OBJECT TEMPLATES WITH 
;;   PRIMITIVES FOR ACCESSORS AND 
;;   A PRIMITIVE REQUIRED ONLY CONSTRUCTOR

;; DEFINE ACCESSORS NAMED SLOT-NAMES AT INCREASING OFFSETS

(dss (%define-structure-accessors ,@slot-names)
  (loc ((getter (name offset) 
          `(dp ,(make-sym "%" name) (x)
             (%slot-elt x (%raw ,offset))))
        (setter (name offset)
          `(dp ,(make-sym "%" name "-setter") (z x)
             (set (%slot-elt x (%raw ,offset)) z))))
    (rep loop ((res '()) (i 0) (names slot-names))
      (if (== names '())
          `(seq ,@(rev! res))
          (let ((name (head names)))
            (loop (pair (getter name i) (pair (setter name i) res))
                  (+ i 1) (tail names)))))))

;; DEFINE STRUCTURE BASE WITH PREFIX FOR CONSTRUCTOR NAME

(dss (%define-structure ,prefix ,proto-base-name ,@slot-names)
  (loc ((constructor (name inits)
	  (let ((proto-name (make-sym "<" name ">")))
	    `(dp ,(make-sym prefix name) (,@slot-names) 
	       (let ((proto (%object-of ,proto-name (%raw ,(len slot-names)))))
		 ,@inits
		 proto)))))
    (rep loop ((inits '()) (i 0) (names slot-names))
      (if (== names '())
	  `(seq (%define-structure-accessors ,@slot-names)
		,(constructor proto-base-name inits))
	  (let ((name (head names)))
	    (loop (pair `(set (%slot-elt proto (%raw ,i)) ,name) inits)
		  (+ i 1) (tail names)))))))

;;; LST BASICS

(%define-structure % lst head tail)

(dp %pair (head tail) (%lst head tail))

(dp %empty? (x) (%bb (%eq? x nil)))

(dp %%len (x) 
  (if (%empty? x) (%raw 0) (%i+ (%%len (%tail x)) (%raw 1))))
  ;; (rep loop ((i (%iu 0)) (x x))
  ;;   (if (%empty? x) count (loop (%i+ count (%iu 1)) (%tail x)))

;;; MET BASICS


(%define-structure % sig 
   sig-names sig-specs sig-nary? sig-arity sig-value)

(%define-structure % met 
   met-code met-name met-sig met-env)

;;;
;;; 3. SETUP HIERARCHY
;;;

;; TRAITS -- PROTO VERSION OF CLASSES

(%define-structure % traits
 traits-owner traits-direct-parents traits-direct-slots
 traits-parents traits-slots traits-direct-children 
 traits-gens traits-mets traits-forward)

;; COMPUTE ALL PARENTS FROM DIRECT PARENTS ASSUMING SINGLE INHERITANCE

(dp %compute-parents (parent)
  (let ((traits (%object-traits parent)))
    (if (%bb (%eq? traits (%object-traits <any>)))
        (%pair <any> nil)
        (%pair (%traits-owner traits) 
	       (%compute-parents (%head (%traits-direct-parents traits)))))))

;; DEFINE CHILD / PARENT RELATIONSHIP
;; INSTALL REAL TRAITS OBJECTS WITH INHERITANCE INFO ONLY

(dp %define-parent (owner direct-parent)
  (let ((direct-parents (%pair direct-parent nil))
	(parents        (%pair owner (%compute-parents direct-parent)))
	(parent-traits  (%object-traits direct-parent)))
    (set (%traits-direct-children parent-traits)
	 (%pair owner (%traits-direct-children parent-traits)))
    (set (%object-traits owner)
	 (%traits owner direct-parents nil parents nil nil nil nil #f))))

;; DEFINES SINGLE INHERITANCE HIERARCHY FROM TOP TO BOTTOM

(dss (%define-hierarchy)
  `(seq ,@(%map-boot-protos 
	    (fun (name parent) `(%define-parent ,name ,parent)))))

(%define-hierarchy)

;; PATCH <ANY>'S PARENTS

(set (%traits-parents (%object-traits <any>)) (%pair <any> nil))

;; TRAIT PARENT LISTS DON'T HAVE PROPER TRAITS SO PATCH THEM
;; TODO: THIS COULD BE REMOVED IF ORIGINAL TRAITS AREN'T DISCARDED

(dp %copy (x) (if (%empty? x) x (%pair (%head x) (%copy (%tail x)))))

(dv <traits>-traits (%object-traits <traits>))

(dp %patch-parent (obj)
  (let ((traits (%object-traits obj)))
    (set (%object-traits traits) 
         <traits>-traits)
    (set (%traits-parents traits)
         (%copy (%traits-parents traits)))
    (set (%traits-direct-children traits)
         (%copy (%traits-direct-children traits)))
    (set (%traits-direct-parents traits) 
         (%copy (%traits-direct-parents traits)))))

(dss (%patch-parents)
  `(seq ,@(%map-boot-protos 
	    (fun (name parent) `(%patch-parent ,name)))))

(%patch-parents)

;;; 
;;; 4. TAGGED OBJECTS
;;; 

;; TAGGED OBJECTS ARE IMMEDIATE OBJECTS WHOSE TYPE AND DATA
;; ARE ENCODED IN ADDRESS
;; USES TWO TAG BITS WITH ADDRESSES HAVING TAG ZERO

(dv $direct-object-traits (%raw-alloc (%raw 4)))

(dv $tag-msk (%raw 3))

(dv $tag-len (%raw 2))

(dp %tag-bits (x) (%i& x $tag-msk))

(dp %tag (x t) (%iv (%i<< x $tag-len) t))

(dp %untag (x) (%i>> x $tag-len))

(dss ($adr-tag) `(%raw 0))

(dp %indirect-object? (x) (%i= (%tag-bits x) ($adr-tag)))

(dp %traits-of (x)
  (let ((tag (%tag-bits x)))
    (if (%bb (%i= tag ($adr-tag)))
        (%object-traits x)
        (%elt $direct-object-traits tag))))

;; DEFINE EARLY TAGGED PROTO 
;;   WHERE CODE IS ABBREVIATION PREFIX FOR OPS
;;   DEFINES TAG/FAB AND UNTAG OPS
;;   DEFINES TAG2TRAITS ENTRY FOR MAP

(dss (%define-tagged-structure ,name ,code ,tag)
  (let ((proto-name (make-sym "<" name ">"))
	(fab-name   (make-sym "%" name))
	(tag-name   (make-sym "%" code "b"))
	(untag-name (make-sym "%" code "u")))
    `(seq (dp ,tag-name (x) (%tag x (%raw ,tag)))
	  (dp ,fab-name (x) (,tag-name x))
	  (dp ,untag-name (x) (%untag x))
	  (set (%elt $direct-object-traits (%raw ,tag)) 
	       (%object-traits ,proto-name))
	  )))

(%define-tagged-structure int i 1) ;; INTEGERS

(%define-tagged-structure chr c 2) ;; CHARACTERS

(%define-tagged-structure loc l 3) ;; LOCATIVES

;;; 
;;;  REPEATED OBJECTS
;;; 

;; DEF STRUCT'S WITH INDEXED ELEMENTS W/ DATA STORED IN DATA SLOT
;;   DEFINING CONSTRUCTORS,ACCESSORS,LEN,BOX/UNBOX'ERS(FOR FFI),

(dss (%define-repeated-structure ,name ,elt ,code ,init)
  (let ((proto-name (make-sym "<"  name ">"))
	(nul        (make-sym "%"  code "nul"))
	(base-dat   (make-sym name "-dat"))
	(dat        (make-sym "%"  base-dat))
	(raw-elt    (make-sym "%%" code "elt"))
	(elt        (make-sym "%"  code "elt"))
	(elt-setter (make-sym "%"  code "elt-setter"))
	(raw-len    (make-sym "%%" code "len"))
	(len        (make-sym "%"  code "len"))
	(box        (make-sym "%"  code "b"))
	(unbox      (make-sym "%"  code "u"))
	(fab        (make-sym "%"  name))
	(fab!       (make-sym "%"  name "!"))
	(raw-fab    (make-sym "%%" code "fab")))
    `(seq (%define-structure-accessors ,base-dat)
          (dp ,fab! (len)
            (let ((proto (%object-of ,proto-name (%raw 1))))
	      (set (,dat proto) (,raw-fab len ,init)) proto))
	  (dv ,nul (,fab! (%raw 0)))
	  (dp ,fab (len) 
	    (if (%bb (%i= len (%raw 0))) ,nul (,fab! len)))
	  (dp ,box (x) 
            (let ((proto (%object-of ,proto-name (%raw 1))))
	      (set (,dat proto) x) proto))
	  (dp ,unbox (x) (,dat x))
	  (dp ,len (x) (,raw-len (,dat x)))
	  (dp ,elt (x i) (,raw-elt (,dat x) i))
	  (dp ,elt-setter (z x i) (set (,raw-elt (,dat x) i) z)))))

(%define-repeated-structure str <chr> s (%cu #\Space))

(%define-repeated-structure vec <any> v nul) 

;; can't use rep yet because symbols aren't real
(dp %str-eq?-loop (s1 s2 len i)
  (or (%bb (%i= i len))
      (let ((c1 (%selt s1 i)) (c2 (%selt s2 i)))
        (and (%bb (%c= c1 c2))
             (%str-eq?-loop s1 s2 len (%i+ i (%raw 1)))))))

(dp %str-eq? (s1 s2)
  (let ((len (%slen s1)))
    (and (%bb (%i= len (%slen s2)))
         (%str-eq?-loop s1 s2 len (%raw 0)))))

;;
;;  SYMBOLS
;;

;; Get symbol fab up ASAP so we don't have to patch the names of
;; a bunch of objects.

(dp %%sym (raw-str)      ;; Called in code generated by compiler
  (if %symbols-ready?
     (fab-sym (%sb raw-str))
     (set %*used-symbols-too-early* #t)
     #f))

(%define-structure % sym sym-nam)

(dv %symbols nil)

;; EARLY VERSION (PRE TAB) OF SYM CONSING USING LST SET
(if (%bb (%eq? %*used-symbols-too-early* #t))
    (%write-string (%current-output-port) (%su
	"Warning: symbols were created in the boot image before the symbol-creation was setup. (Probably from a df or rep)\n")))


;; this first version doesn't have proper symbols, but it works..
(dv fab-sym
  (fun (name)
    (rep lookup ((s %symbols))
      (if (%empty? s)
          (let ((sym (%sym name)))
            (set %symbols (%pair sym %symbols))
            sym)
          (let ((sym (%head s)))
            (if (%str-eq? (%sym-nam sym) name)
                sym
                (lookup (%tail s))))))))

(set %symbols-ready? #t) ;; READY TO CONS SYMBOLS

;; do the same thing, this time the symbols will be filled in
(df fab-sym (name)
  (rep lookup ((s %symbols))
    (if (%empty? s)
        (let ((sym (%sym name)))
          (set %symbols (%pair sym %symbols))
          sym)
        (let ((sym (%head s)))
          (if (%str-eq? (%sym-nam sym) name)
              sym
              (lookup (%tail s)))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; !!! Below here we can use functions !!! ;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; MORE LST UTILITIES BUT NOW USING LOCAL METHODS

(dp %rev! (c)
  (rep loop ((l c) (r '()))
    (if (%empty? l)
	r
	(let ((t (%tail l)))
	  (set (%tail l) r)
	  (loop t l)))))

(dp %cat2 (x y) 
  (rep colx ((lx nil) (x x))
    (if (%empty? x)
	(rep coly ((lxy lx) (y y))
	  (if (%empty? y)
	      (%rev! lxy)
	      (coly (%pair (%head y) lxy) (%tail y))))
	(colx (%pair (%head x) lx) (%tail x)))))


;;; 
;;; 5. BOXED OBJECTS
;;; 

(dss (%define-boxed-structure ,name ,code)
  (let ((proto-name (make-sym "<" name ">"))
	(dat-name   (make-sym name "-dat"))
	(fab-name   (make-sym "%" name))
	(box-name   (make-sym "%" code "b"))
	(unbox-name (make-sym "%" code "u")))
    `(seq (%define-structure % ,name ,dat-name)
	  (dp ,box-name (x) (,fab-name x))
	  (dp ,unbox-name (x) (%slot-elt x (%raw 0)))
	  )))

(%define-boxed-structure flo f)

;; (%define-boxed-structure chr c)

;; (%define-boxed-structure int i)

;; (%define-boxed-structure loc l)

;;;
;;; 6. MAKE SLOTS AND ACCESSORS
;;; 

;; DEF SLOT'S

(%define-structure %% slot
  slot-owner slot-getter slot-setter slot-type slot-init)

;; GENERIC DISPATCH CACHES 
;;   USED IN HIERARCHY DECISION TREE
;;   MAP KEYS TO SUBTREES WHERE KEYS ARE EITHER OBJECTS OR TRAITS
;;   AND SUBTREES ARE EITHER OTHER CACHES OR METHODS OR SLOT OFFSETS

(%define-structure % gen-cache 
   gen-cache-arg-pos gen-cache-singletons gen-cache-classes)

(dv $gen-cache-singletons-offset 1) ;; TODO: USED IN CACHE UPDATE
(dv $gen-cache-classes-offset    2)

;;; DEF GENERIC'S
 
(%define-structure % gen 
   gen-code gen-name gen-sig gen-mets fun-cache)

(df %slot-offset (owner getter)
  (rep loop ((i (%raw 0)) (slots (%traits-slots (%object-traits owner))))
    (if (%empty? slots)
	(%iu -1)
	(let ((slot (%head slots)))
	  (if (%bb (%eq? (%slot-getter slot) getter))
	      i
	      (loop (%i+ i (%raw 1)) (%tail slots)))))))

;; &PAIRIZE CONSTRUCTS CODE THAT BUILDS A LIST OF GIVEN ARGS WITH CALLS TO %PAIR

(ct (df &pairize (args)
      (if (empty? args)
	  'nil
	  `(%pair ,(head args) ,(&pairize (tail args))))))

;; EARLY DISPATCH ERRORS OUT

(df %early-dispatch ((args ...))
  (let ((gen (%fun-reg)))
    (%write-string (%current-output-port)
                   (%su "ERROR: Generic function dispatch called before it existed."))
    ;; die (is there a better way?)
    ((%raw 0))))

(df %add-met (gen met)
  (set (%gen-mets gen) (%pair met (%gen-mets gen))))

;; DEFINE EARLY GENERIC METHOD FOR ACCESSORS

(dss (%define-accessor ,name (,@sig) ,@body)
  (let ((params  (sexpr-signature-parameters sig))
	(specs   (&pairize (map (always '<any>) params))))
    `(seq (dv ,name 
	    (%gen %early-dispatch ',name 
	          (%sig '() ,specs #f ,(len params) <any>) '() #f))
	  (let ((accessor (fun (,@sig) ,@body)))
	    (%add-met ,name accessor)
	    accessor))))

(dss (%define-getter ,name ,owner ,type)
  `(%define-accessor ,name ((x ,owner))
      (%slot-elt x (%slot-offset ,owner ,name))))

(dss (%define-setter ,name ,owner ,type)
  `(%define-accessor ,(make-sym name "-setter") ((z ,type) (x ,owner))
     (set (%slot-elt x (%slot-offset ,owner ,name)) z)))

;; EARLY ADD-SLOT JUST ADDS SLOT TO DIRECT-SLOTS

(df %add-slot (owner slot)
  (let ((traits (%object-traits owner)))
    (set (%traits-direct-slots traits)
	 (%pair slot (%traits-direct-slots traits)))))

;; DEF GETTER/SETTER/SLOTS FOR ALL BOOT PROTO SLOTS
;; N.B. SLOT METHODS CLOSE OVER SLOT

(dss (%define-slots)
  `(seq ,@(%map-boot-slots 
	    (fun (owner name type init) 
	      `(let ((getter (%define-getter ,name ,owner ,type))
		     (setter (%define-setter ,name ,owner ,type))
		     ;; TODO: X FROM OWNER VAR
		     (slot   (%%slot ,owner ,name ,(make-sym name "-setter") 
                                     ,type (fun (x) ,init))))
		 (set (%met-env getter) slot)
		 (set (%met-env setter) slot)
		 (%add-slot ,owner slot))))))

(%define-slots)

;;;
;;; 7. FINALIZE SLOTS
;;;

;; NEED TO SET ALL SLOTS TRAITS SLOT

(df %collect-direct-slots (traits)
  (let ((parent (%head (%traits-direct-parents traits))))
    (%cat2 (%traits-slots (%object-traits parent))
	   (%traits-direct-slots traits))))

(df %finalize-slots! (owner)
  (let ((traits (%object-traits owner)))
    (set (%traits-direct-slots traits)
	 (%rev! (%traits-direct-slots traits)))
    (set (%traits-slots traits)
	 (%collect-direct-slots traits))
    (%adjust-object-values-size owner (%%len (%traits-slots traits)) owner)
    owner))

(dss (%finalize-slots)
  `(seq ,@(%map-boot-protos (fun (name parent) `(%finalize-slots! ,name)))))

(%finalize-slots)

;;;
;;; 8. PATCH INSTANCES
;;;

;; UNFORTUNATELY NIL IS INCORRECTLY SET IN <LST> BECAUSE OF BOOT ORDER

(dp %patch-lst (x) 
  (set (%head x) '())
  (set (%tail x) '()))

(%patch-lst '())
(%patch-lst <lst>)

;;;
;;; 11. FUNCTION PREP
;;; 

;; NEED TO DEF A SLEW OF MONOVARIANT FUN'S 
;;   PRE GENERICS AND IN ORDER TO AVOID CIRCULARITIES
;;   USE PRIMITIVES FOR SPEED FOR NOW

(dp @head ((x <lst>) => <any>) (%head x))

(dp @head-setter (z (x <lst>)) (set (%head x) z))

(dp @tail ((x <lst>) => <lst>) (%tail x))

(dp @tail-setter ((z <lst>) (x <lst>)) (set (%tail x) z))

(dp @= ((x <int>) (y <int>) => <log>)
  (%bb (%i= (%iu x) (%iu y))))

(dp @< ((x <int>) (y <int>) => <log>)
  (%bb (%i< (%iu x) (%iu y))))

(dp @+ ((x <int>) (y <int>) => <int>)
  (%ib (%i+ (%iu x) (%iu y))))

(dp @== ((x <any>) (y <any>) => <log>) (%bb (%eq? x y)))

(df @@== ((x <any>) (y <any>) => <log>) (%bb (%eq? x y)))

(df not ((x <any>) => <log>) (%bb (%eq? x #f)))

(dp @not ((x <any>) => <log>) (%bb (%eq? x #f)))

(dp @empty? ((x <lst>) => <log>) (%empty? x))

(df @@empty? ((x <lst>) => <log>) (%empty? x))

(df @rev! ((x <lst>) => <lst>) (%rev! x))

(dp @len ((x <lst>) => <int>) (%ib (%%len x)))

(df @all? ((test <fun>) (c <lst>) => <log>)
  (rep fnd ((p c))
    (if (@empty? p) #t (if (test (@head p)) (fnd (@tail p)) #f))))

(df @all2? ((test <fun>) (x <lst>) (y <lst>) => <log>)
  (rep fnd ((px x) (py y))
    (if (@empty? px) 
	(@empty? py)
	(if (@empty? py)
	    #f
	    (if (test (@head px) (@head py)) 
		(fnd (@tail px) (@tail py))
		#f)))))

(df @elt ((x <lst>) (key <int>) => <any>)
  (rep fnd (((count <int>) 0) ((x <lst>) x))
    (if (@== x '())
        nul
        (if (@= count key) (@head x) (fnd (@+ count 1) (@tail x))))))

(df @fill ((x <lst>) (f <fun>) => <lst>)
  (rep loop ((p x))
    (if (@empty? p) x (seq (set (@head p) f) (loop (@tail p))))))

(df @any? ((test <fun>) (c <lst>) => <any>) ;; TODO: => <log>
  (rep fnd ((p c))
    (if (@empty? p) #f (or (test (@head p)) (fnd (@tail p))))))

(dp @pair ((h <any>) (t <lst>) => <lst>) (isa <lst> (set head h) (set tail t)))

(dp @add ((c <lst>) (e <any>) => <lst>) (@pair e c))

(dp @add-new ((c <lst>) (e <any>) => <lst>) 
  (if (@mem? c e) c (@pair e c)))

(df @map ((f <fun>) (x <lst>) => <lst>)
  (rep do ((x x) (res '()))
    (if (@empty? x)
	(@rev! res)
	(do (@tail x) (@pair (f (@head x)) res)))))

(df @do ((f <fun>) (x <lst>) => <any>) ;; TODO: => (tup)
  (rep do ((x x))
    (if (@empty? x)
	#f
	(seq (f (@head x)) (do (@tail x))))))

(df @alter ((dst <lst>) (src <lst>) => <lst>)
  (rep in ((ds dst) (ss src))
    (if (or (@empty? ds) (@empty? ss))
        dst
        (seq (set (@head ds) (@head ss))
             (in (@tail ds) (@tail ss))))))

(df @fab ((x <lst>) (s <int>) => <lst>)
  (rep fab (((i <int>) s) ((res <lst>) '()))
    (if (@< i 0) res (fab (@+ i -1) (@pair nul res)))))

(df @reduce ((combine <fun>) (init <any>) (c <lst>) => <lst>)
  (rep red ((res init) (c c))
    (if (@empty? c)
        res
        (red (combine res (@head c)) (@tail c)))))

(df @cat2 ((x <lst>) (y <lst>) => <lst>)
  (%cat2 x y))

(df @find-key ((f <fun>) (c <lst>) => <any>) ;; TODO: => <int>
  (rep fnd ((c c) (i 0))
    (if (@empty? c)
	nul
	(if (f (@head c))
	    i
	    (fnd (@tail c) (@+ i 1))))))

(df @mem? ((c <lst>) (x <any>) => <log>)
  (not (@== (@find-key (fun (y) (@== x y)) c) nul)))

(df @del-dups ((x <lst>) => <lst>)
  (@reduce (fun (s e) (if (@mem? s e) s (@pair e s))) '() x))

(df @lst ((objects ...)) objects)

(df @fun-names ((x <fun>) => <lst>) (%sig-names (%gen-sig x)))

(df @fun-specs ((x <fun>) => <lst>) (%sig-specs (%gen-sig x)))

(df @fun-nary? ((x <fun>) => <log>) (%sig-nary? (%gen-sig x)))

(df @fun-arity ((x <fun>) => <int>) (%sig-arity (%gen-sig x)))

(df @fun-value ((x <fun>) => <any>) (%sig-value (%gen-sig x)))

(df @fun-mets ((x <fun>) => <lst>) (%gen-mets x))

(df @fun-mets-setter ((z <lst>) (x <fun>)) (set (%gen-mets x) z))

;;; 
;;; 12. FUNCTIONS
;;; 

(dv <env>   <any>)
(dv <specs> <lst>)
(dv <body>  <any>)

(df fun-spec ((x <met>) (i <int>) => <any>)
  (@elt (@fun-specs x) i))

(dv <mets> <lst>)

(df fun-same-met? ((x <met>) (y <met>) => <log>)
  (@all2? @@== (@fun-specs x) (@fun-specs y)))

(df fun-congruent? ((x <fun>) (y <fun>) => <log>)
  (and (@=  (@fun-arity x) (@fun-arity y))
       (@== (@fun-nary? x) (@fun-nary? y))
       (@all2? isa? (@fun-specs x) (@fun-specs y))))

;; TODO: NEED RESTART FOR CHANGING GEN TO FIX INCONGRUENCIES 

(df gen-add-met ((g <gen>) (m <met>) => <gen>)
  (set (%fun-cache g) #f)
  (unless (fun-congruent? m g)
    (error "Method %= Incongruent with Generic %=" m g))
  ;; DEP TRACK MET/GEN IN ALL REAL SPECS -- USED FOR REDEFINITION
  (rep lop ((specs (@fun-specs m)))
    (unless (@empty? specs)
      (let ((spec (@head specs)))
	(unless (or (singleton-spec? spec) (@== spec <any>))
	  (let ((spec-traits (%object-traits spec)))
 	    (set (%traits-gens spec-traits)
	         (@add-new (%traits-gens spec-traits) g))
 	    (set (%traits-mets spec-traits)
	         (@add-new (%traits-mets spec-traits) m)))
	  (lop (@tail specs))))))
  ;; ACTUALLY PERFORM ADDITION KEEPING TRACK OF IT BEING A REPLACEMENT OR NOT
  (rep col ((mets '()) (same? #f) ((gms <mets>) (@fun-mets g)))
    (if (@empty? gms)
	(set (%gen-mets g) (@rev! (if same? mets (@add mets m))))
	(let ((gm          (@head gms))
	      (now-same?   (fun-same-met? gm m)))
	  (col (@add mets (if now-same? m gm)) 
	       (or now-same? same?) (@tail gms)))))
  g)

(dv <args> <lst>)

(dp %%isa? (o1 o2 ps => <log>)
  (if (%empty? ps)
      #f
      (if (@== (%head ps) o2)
	  #t
	  (%%isa? o1 o2 (%tail ps)))))

(dp %object-parents (x => <parents>)
  (%traits-parents (%traits-of x)))

(dp %isa? (o1 o2 => <log>)
  (or (@== o2 <any>)
      (@== o1 o2)
      (%%isa? o1 o2 (%object-parents o1))))

(df isa? (o1 o2 => <log>)
  (%isa? o1 o2))

(df object< (o1 o2 wrt => <log>)
  (if (@== wrt o1)
      #t
      (if (@== wrt o2)
	  #f
	  (rep find ((ps (object-parents wrt)))
	    (if (@empty? ps)
		(error "can't order specializers - arg/reference object %= is "
		       "neither %= nor %=" wrt o1 o2) 
		(let ((o (@head ps)))
		  (if (@== o o1)
		      #t
		      (if (@== o o2)
			  #f
			  (find (@tail ps))))))))))

(dv <tup> <lst>)
(dv @tup  @lst)

(df order-specs (t1 t2 arg => (tup (order <sym>) canonical-type))
  (if (@== t1 t2) 
      (@tup '= t1)
      (if (object< t1 t2 arg)
	  (@tup '< t1)
	  (@tup '> t2))))

(df order-mets ((m1 <met>) (m2 <met>) (args <args>) => (order <sym>))
  (let (((arity <int>) (@fun-arity m1)))
    (rep loop (((state <sym>) '=) ((idx <int>) 0))
      (if (@= idx arity)
	  state
	  (let ((m1spec (fun-spec m1 idx))
		(m2spec (fun-spec m2 idx))
		((cmp+typ <tup>) (order-specs m1spec m2spec (@elt args idx)))
		((cmp <sym>) (@elt cmp+typ 0))
		((idx <int>) (@+ idx 1)))
	    (if (@== cmp '=)
		(loop state idx)
		(if (and (not (@== cmp '<>))
			 (or (@== state '=) (@== cmp state)))
		    (loop cmp idx)
		    '<>)))))))

(df sorted-app-mets-1
      ((mets <lst>) (args <args>) (order-mets <fun>)
       => (tup (ordered <lst>) (ambig <lst>)))
  (let (((ohead <lst>) (@pair #f '()))
	((ahead <lst>) (@pair #f '())))
    (rep loop (((mets <lst>) mets))
      (unless (@== mets '())
	(let (((met <met>) (@head mets)))
	  (loc ((make-ambiguous ((headed-list <lst>))
		  (rep loop (((l <lst>) (@tail headed-list)))
		    (or (@== l '())
			(let ((t1 (@tail l)))
			  (set (@tail l) (@tail ahead))
			  (set (@tail ahead) l)
			  (loop t1))))
		  (set (@tail headed-list) '())
		  (set (@tail ahead) (@pair met (@tail ahead))))
		(precedes-all? ((l <lst>))
                  (rep loop (((l <lst>) l))
		    (if (@== l '())
			#t
			 (if (@== (order-mets met (@head l) args) '<)
			     (loop (@tail l))
			     #f))))
		(check-subsequent-ambiguities ((oprev <lst>))
		  (if (or (not (precedes-all? (@tail oprev)))
			  (not (precedes-all? (@tail ahead))))
		      (make-ambiguous oprev)
		      (set (@tail oprev) (@pair met (@tail oprev)))))
		(insert ((oprev <lst>) (osub <lst>))
		  (if (@empty? osub)
		      (check-subsequent-ambiguities oprev)
		      (let ((indic (order-mets met (@head osub) args)))
			(if (@== indic '<)     ;; comes before current one.
			    (check-subsequent-ambiguities oprev)
			    (if (@== indic '>) ;; comes after, check further.
				(insert osub (@tail osub))
				(make-ambiguous oprev)))))))
	    (insert ohead (@tail ohead))
	    (loop (@tail mets))))))
    (@tup (@tail ohead) (@tail ahead))))

(df met-app? ((met <met>) (args <args>) => <log>)
  (let (((n <int>) (@fun-arity met)))
    (rep loop (((i <int>) 0))
      (if (@= i n)
	  #t
	  (if (isa? (@elt args i) (fun-spec met i))
	      (loop (@+ i 1))
	      #f)))))

(df sorted-app-mets
      ((gf <gen>) (args <args>) => (tup (ordered <lst>) (ambig <lst>)))
  (let ((considered-mets
	 (rep col ((ans '()) (ms (@fun-mets gf)))
	   (if (@empty? ms)
	       ans
	       (let ((m (@head ms))
		     (ans (if (met-app? m args) (@pair m ans) ans)))
		 (col ans (@tail ms)))))))
    (sorted-app-mets-1 considered-mets args order-mets)))

(df opt-args ((n <int>) (args <args>) => <args>)
  (rep col (((i <int>) 0) ((l <args>) '()) ((p <args>) args))
    (if (@= i n)
	(if (@empty? l)
	    (@lst p)
	    (seq (set (@tail l) (@lst p)) args))
	(col (@+ i 1) p (@tail p)))))

(df @gen-cache-arg-pos (x)             (%gen-cache-arg-pos x))
(df @gen-cache-arg-pos-setter (z x)    (set (%gen-cache-arg-pos x) z))
(df @gen-cache-singletons (x)          (%gen-cache-singletons x))
(df @gen-cache-singletons-setter (z x) (set (%gen-cache-singletons x) z))
(df @gen-cache-classes (x)             (%gen-cache-classes x))
(df @gen-cache-classes-setter (z x)    (set (%gen-cache-classes x) z))

(df gen-unspecialized-at? ((gen <gen>) (pos <int>) => <log>)
  (@all? (fun (met) (@= (fun-spec met pos) <any>)) (%gen-mets gen)))

(df gen-lookup-miss-1-using
    (key (all-assocs <fun>) (all-assocs-setter <fun>) 
     (gen <gen>) cache (met <met>) (mets <lst>)
     (i <int>) (n <int>) 
     (args <lst>) (specs <lst>))
  (if (or (and cache (@< i (%gen-cache-arg-pos cache)))
	  (gen-unspecialized-at? gen i))
      (gen-lookup-miss-1 gen cache met mets (@+ i 1) n args specs)
      (let ((cache (or cache (%gen-cache i nil nil))))
	(rep loop ((assocs (all-assocs cache)))
	  (if (@empty? assocs) ;; miss
	      ;; could be a stale object
	      (if (and (@== all-assocs @gen-cache-classes)
		       (%traits-forward key))
		  (let ((arg (@elt args i)))
		    (update-instance-for-changed-prototype arg)
		    (set key (%traits-of arg)) ; reset key to new traits
		    (loop (all-assocs cache))) ; restart search cause might hit
		  (let ((val (gen-lookup-miss-1
			      gen #f met mets (@+ i 1) n args specs)))
		    (set (all-assocs cache)
			 (@pair key (@pair val (all-assocs cache))))))
	      (let ((k (@head assocs))
		    (v (@head (@tail assocs))))
		(if (@== k key)
		    (gen-lookup-miss-1 gen v met mets (@+ i 1) n args specs)
		    (loop (@tail (@tail assocs)))))))
	cache)))

(df singleton-spec? (x)
  (not (@== (%traits-owner (%traits-of x)) x)))

(dv <slot>-traits (%object-traits <slot>))

;; GIVEN MET/GEN AND ARGS FIND SLOT-OFFSET -- USING SLOT IN MET ENV

(df method-accessor-offset ((gen <gen>) (met <met>) (args <lst>))
  (let ((slot  (%met-env met))
	(slot? (and slot (@== (%traits-of slot) <slot>-traits)))
	(n     (@len args)))
    (and slot?
	 (if (@= n 1) ;; getter?
	     (slot-offset (%head args) gen)
	     (slot-offset (%head (%tail args)) (%slot-getter slot))))))

(df gen-lookup-miss-1
    ((gen <gen>) cache (met <met>) (mets <lst>)
     (i <int>) (n <int>) (args <lst>) (specs <lst>))
  (if (@= i n)
      (or (method-accessor-offset gen met args) mets)
      (let ((spec (@elt specs i)))
	(if (singleton-spec? spec)
	    (gen-lookup-miss-1-using
	     spec @gen-cache-singletons @gen-cache-singletons-setter
	     gen cache met mets i n args specs)
	    (gen-lookup-miss-1-using
	     (%traits-of (@elt args i)) 
	     @gen-cache-classes @gen-cache-classes-setter
	     gen cache met mets i n args specs)))))

(dp gen-lookup-1) ;; FORWARD DECL

(dp gen-lookup ((gen <gen>) (args <lst>))
  (let ((n (%sig-arity (%gen-sig gen)))
	(c (%fun-cache gen)))
    (gen-lookup-1 gen c 0 n args args)))

(dv <int>-traits (%traits-of <int>))

(dp slot-value-at (object (offset <int>) => <any>)
  (let ((val (%slot-elt object (%iu offset))))
    (if (@== val nul-slot)
	(let ((slots (object-slots object)))
	  (set (%slot-elt object (%iu offset))
	       ((%slot-init (@elt slots offset)) object)))
	val)))

(dp slot-value-at-setter (z object (offset <int>))
  (set (%slot-elt object (%iu offset)) z))

(dv $missed-dispatch (%pair nil nil))

;; MAIN DISPATCH ARG STEP (FOR SINGLETONS AND CLASSES) RESULTING IN HIT OR MISS
;; HIT RETURNS ASSOCD VALUE AND REORDERS ASSOCS PUT KEY AT FRONT REFLECTIN FREQS
;; MISS ADDS KEYS (UNLESS MISSABLE) AND THEN RERUNS LOOKUP FROM BEGINNING

(dp gen-lookup-1-using
    (key (prev-assocs <lst>) (assocs <lst>) missable? (cache-offset <int>) 
     (gen <gen>) cache (i <int>) (n <int>) (args <lst>) (all-args <lst>))
  (if (@empty? assocs) ;; miss
      (if missable?
	  $missed-dispatch
	  (seq (set (%fun-cache gen) (gen-lookup-miss gen all-args))
	       (gen-lookup gen all-args)))
      (let ((k           (%head assocs))
	    (tail-assocs (%tail assocs)))
	(if (@== k key)
	    (let ((v          (%head tail-assocs))
		  (old-assocs (%slot-elt cache (%iu cache-offset))))
	      (if (@== old-assocs assocs) ;; already at front?
		  #f
		  (let ((nxt-assocs (%tail tail-assocs)))
		    (set (%slot-elt cache (%iu cache-offset)) assocs)
		    (set (%tail tail-assocs)                  old-assocs)
		    (set (%tail (%tail prev-assocs))          nxt-assocs)))
	      (gen-lookup-1 gen v (@+ i 1) n (%tail args) all-args))
	    (gen-lookup-1-using
	     key assocs (%tail tail-assocs) missable? cache-offset
	     gen cache i n args all-args)))))

;; DISPATCH ARG STEP RUNNING BOTH SINGLETON AND CLASS DISPATCH
;; IF HIT THEN 
;;   IF LAST ARG THEN LEAF WITH INT MEANING SLOT-OFFSET ELSE METHOD
;;               ELSE RECURSE WITH NEXT ARG

(dp gen-lookup-1 
      ((gen <gen>) cache (i <int>) (n <int>) (args <lst>) (all-args <lst>))
  (if cache
      (if (@= i n)
	  (if (@== (%traits-of cache) <int>-traits) ;; int?
	      (if (@= n 1) ;; getter?
		  (slot-value-at (%head all-args) cache)
		  (set (slot-value-at (%head (%tail all-args)) cache) 
		       (%head all-args)))
	      (%%mep-apply (%head cache) (%tail cache) all-args))
	  (if (@= i (%gen-cache-arg-pos cache))
	      (let ((arg (%head args))
		    (val (let ((assocs (%gen-cache-singletons cache)))
			   (gen-lookup-1-using
			    arg assocs assocs #t $gen-cache-singletons-offset
			    gen cache i n args all-args))))
		(if (@== val $missed-dispatch)
		    (let ((assocs (%gen-cache-classes cache)))
		      (gen-lookup-1-using
		       (%traits-of arg) assocs assocs #f
		       $gen-cache-classes-offset gen cache i n args all-args))
		    val))
	      (gen-lookup-1 gen cache (@+ i 1) n (%tail args) all-args)))
      (seq (set (%fun-cache gen) (gen-lookup-miss gen all-args))
	   (gen-lookup gen all-args))))

;; TODO: CONDITIONS FOR THESE ERRORS

(df choose-methods ((gen <gen>) (args <lst>) => <lst>)
  (let ((ord-amb-mets   (sorted-app-mets gen args))
	(sorted-mets    (@elt ord-amb-mets 0))
	(ambiguous-mets (@elt ord-amb-mets 1)))
    (if (@< 0 (@len ambiguous-mets))
	(error "Ambiguous Method Error when calling %= on %=" gen args)
	(if (@empty? sorted-mets)
	    (error "No Applicable Methods Error when calling %= on %=" gen args)
	    sorted-mets))))

(df met< ((m1 <met>) (m2 <met>) => <log>)
  (if (@== m1 m2)
      #f
      (@all2? isa? (@fun-specs m1) (@fun-specs m2))))

(df met-has-singleton-specs? ((m <met>) => <log>)
  (@any? singleton-spec? (@fun-specs m)))

(df find-app-singleton-mets ((gen <gen>) (met <met>) => <lst>)
  (rep loop ((res '()) (mets (@fun-mets gen)))
    (if (@empty? mets)
	res
	(let ((m (@head mets))
	      (singleton-app? (and (met-has-singleton-specs? m) (met< m met))))
	  (loop (if singleton-app? (@pair m res) res) (@tail mets))))))

(df gen-lookup-miss ((gen <gen>) (args <lst>) => <any>) 
  (let ((mets  (choose-methods gen args)) ;; TODO: => (or <met> <gen-cache>)
	(met   (@head mets))
	(specs (@fun-specs met))
	(n     (@fun-arity gen))
	(cache (gen-lookup-miss-1 gen (%fun-cache gen) met mets 0 n args specs))
	(app-singleton-mets (find-app-singleton-mets gen met)))
    (@do (fun (m) 
	   (gen-lookup-miss-1 gen cache m mets 0 n args (@fun-specs m)))
	 app-singleton-mets)
    cache))

(df %dispatch ((args ...))
  (gen-lookup (%fun-reg) args))

;; READY TO REPLACE EARLY DISPATCHER WITH REAL DISPATCHER IN EARLY GEN'S

(df %patch-early-generic ((generic <gen>))
  (set (%gen-code generic) (%met-code %dispatch)))

(dss (%patch-early-generics)
  `(seq ,@(%map-boot-slots 
	    (fun (owner name type init) 
	      `(seq 
                 (%patch-early-generic ,name)
                 (%patch-early-generic ,(make-sym name "-setter")))))))

(%patch-early-generic <gen>)
(%patch-early-generics)

(dv <opts> <lst>)

;; TODO: NARY APPLY

(df apply ((proc <fun>) (args <opts>))
  (%%apply proc #f args))

(df %apply-next-method (next-mets (args <opts>))
  (if next-mets
      (%%apply (%head next-mets) (%tail next-mets) args)
      (error "No next methods")))

(df %call-next-method (next-mets (args ...))
  (%apply-next-method next-mets args))

(df fapply (fproc (args <opts>))
  (%fapply fproc args))

;; SIG TRAMPOLINES THROUGH FUN'S

(dss (def-fun/sig-accessor ,name)
  `(seq (df ,(make-sym "fun-" name) (x)
	  (,(make-sym "sig-" name) (fun-sig x)))
	(df ,(make-sym "fun-" name "-setter") (z x) 
	  (set (,(make-sym "sig-" name) (fun-sig x)) z))))

(def-fun/sig-accessor names)
(def-fun/sig-accessor specs)
(def-fun/sig-accessor nary?)
(def-fun/sig-accessor arity)
(def-fun/sig-accessor value)

;;; 
;;; 13. OBJECTS
;;; 

(dv <parents> <lst>)
(dv <slots>   <lst>)

(df object-traits (x) (%traits-of x))

(df traits-ordered-parents ((o <traits>) => <parents>)
  (loc ((merge-lists ((partial-cpl <lst>) (remaining-lists <lst>))
          ;; the partial-cpl is in reverse order at this point.
	 (if (@all? @@empty? remaining-lists)
	     (@rev! partial-cpl)
	     (loc ((unconstrained-proto (p)
		    (loc ((p-in-and-unconstrained-in? ((l <lst>))
			   (@== (@head l) p))
			  (p-unconstrained-in? ((l <lst>))
  		           (or (@== (@head l) p) (not (@mem? (@tail l) p)))))
		      (and (@any? p-in-and-unconstrained-in? remaining-lists)
			   (@all? p-unconstrained-in? remaining-lists)
			   p)))
		   (unconstrained-object-in-parents ((o <any>))
		     (@any? unconstrained-proto (object-direct-parents o))))
	       (let ((next (@any? unconstrained-object-in-parents partial-cpl)))
		 (if next
		      (loc ((remove-next ((l <lst>))
			      (if (@== (@head l) next) (@tail l) l)))
			(merge-lists 
			 (@pair next partial-cpl)
			 ;; (@alter remaining-lists 
			   (@map remove-next remaining-lists)
			 ;; )
			 ))
		      (error "inconsistent precedence graph")))))))
     (let ((parents (%traits-direct-parents o)))
       (if (or (@empty? parents)
	       (and (@= (@len parents) 1)
		    (@== (@elt parents 0) (%traits-owner o))))
	   parents
	   (merge-lists (@lst (%traits-owner o))
			(@add (@map object-parents parents) parents))))))

(df traits-ordered-slots ((x <traits>) => <slots>)
  (@del-dups
    (@reduce @cat2 '() (@map object-direct-slots (%traits-parents x)))))

(df make-traits ((parents <parents>) (slots <slots>) owner => <traits>)
  (let ((x (%traits owner parents slots '() '() '() '() '() #f)))
    (set (%object-traits owner) x)
    (if (@empty? (%traits-direct-parents x)) ;; ONLY FOR <ANY> TODO: WHY?
        (set (%traits-direct-parents x) (@lst (%traits-owner x))))
    (@do (fun (parent) 
	   (let ((parent-traits (%object-traits parent)))
	     (set (%traits-direct-children parent-traits)
		  (@add-new (%traits-direct-children parent-traits) x))))
	 (%traits-direct-parents x))
    (set (%traits-parents x) (traits-ordered-parents x))
    (set (%traits-slots x)   (traits-ordered-slots x))
    x))

;; TRAMPOLINE META METHODS

(dss (def-object-traits-accessor ,name)
  `(df ,(make-sym "object-" name) (x) 
     (,(make-sym "%traits-" name) (%traits-of x))))

(def-object-traits-accessor direct-slots)
(def-object-traits-accessor direct-parents)
(def-object-traits-accessor slots)
(def-object-traits-accessor parents)
(def-object-traits-accessor direct-children)

;;;
;;; SLOTS
;;;

(dv $getter-not-found -1)

(df ensure-fresh-object (x)
  (when (%traits-forward (%traits-of x)) ;; stale object?
    (update-instance-for-changed-prototype x)))

(df slot-offset (object (getter <fun>) => <int>)
  (rep loop ((i 0) (slots (object-slots object)))
    (if (@empty? slots)
	$getter-not-found
	(if (@== (%slot-getter (@head slots)) getter)
	    i
	    (loop (@+ i 1) (@tail slots))))))

(df slot-value (object (getter <fun>) => <any>)
  (ensure-fresh-object object)
  (let ((offset (slot-offset object getter)))
    (if (@= offset $getter-not-found)
	(error "slot %s not found in %=" getter object)
	(slot-value-at object offset))))

(df slot-value-setter (z object (getter <fun>))
  (ensure-fresh-object object)
  (let ((offset (slot-offset object getter)))
    (if (@= offset $getter-not-found)
	(error "slot %s not found in %=" getter object)
	(set (slot-value-at object offset) z))))

;; IT IS NOW CRUCIAL THAT OBJECT HAS ITS VERY OWN TRAITS SO THAT ITS TRAITS
;; CAN DEPART FROM ITS PARENTS.  THIS IS FOR COPY ON WRITE BEHAVIOR.

(df ensure-traits (x => <any>)
  (unless (@== (%traits-owner (%object-traits x)) x)
    (set (%object-traits x)
	 (make-traits (@lst (%traits-owner (%object-traits x))) '() x)))
  x)

(df %isa ((parents <lst>) (getters <lst>) (vals <lst>) => <any>)
  (let ((object (%make-object)))
    (if (@= (@len parents) 1)
	;; SINGLE INHERITANCE
	(let ((parent (@head parents))
	      (traits (%object-traits (ensure-traits parent))))
	  (set (%object-traits object) traits)
	  (%adjust-object-values-size
	   object (%%len (%traits-slots traits)) parent))
	;; MULTIPLE INHERITANCE
	(let ((traits (make-traits (@map ensure-traits parents) '() object)))
	  (%install-object-values object (%%len (%traits-slots traits)))
	  ;; CLONE CURRENT VALUES OF PARENTS' SLOTS IN CPL ORDER
	  (rep loop-slots ((slots (%traits-slots traits)))
	    (unless (@empty? slots)
	      (let ((slot (@head slots)))
		(rep loop-parents ((parents (%traits-parents traits)))
		  (unless (@empty? parents)
		    (let ((parent (@head parents))
			  (getter (%slot-getter slot))
			  (offset (slot-offset parent getter)))
		      (if (@= offset $getter-not-found)
			  (loop-parents (@tail parents))
			  (seq (set (slot-value object getter)
				    (slot-value-at parent offset))
			       (loop-slots (@tail slots))))))))))))
    ;; SET SLOT-VALUES FROM ISA ARGUMENTS
    (rep loop ((getters getters) (vals vals))
      (unless (or (@== getters '()) (@== vals '()))
        (seq (set (slot-value object (@head getters)) (@head vals))
	     (loop (@tail getters) (@tail vals)))))
    object))

(df find-getter (owner (getter <gen>) => <met>)
  (rep loop ((mets (@fun-mets getter)))
    (if (@empty? mets)
	(error "COULDN'T FIND GETTER")
	(let ((met (@head mets)))
	  (if (@== (fun-spec met 0) owner)
	      met
	      (loop (@tail mets)))))))

(df find-setter (owner type (zetter <gen>) => <met>)
  (rep loop ((mets (@fun-mets zetter)))
    (if (@empty? mets)
	(error "COULDN'T FIND SETTER")
	(let ((met (@head mets)))
	  (if (and (@== (fun-spec met 1) owner) (@== (fun-spec met 0) type))
	      met
	      (loop (@tail mets)))))))

;; CREATE CLONE OF TRAITS AND MARK THEM AS FORWARDED CLONE OF ORIGINAL TRAITS
;; ALSO CLEAR ALL ASSOC'D GENERIC DISPATCH CACHES SO THAT THEY TRAP NEXT TIME

(df forward-traits (x)
  (let ((old-traits (%object-traits x))
        (new-traits (%clone old-traits))) ;; TODO: %CLONE
    (@do (fun (g) (set (%fun-cache g) #f))
         (%traits-gens old-traits))
    (set (%traits-forward old-traits) new-traits)
    (set (%object-traits x) new-traits)))

(df @do-children (f x)
  (let ((visited '()))
    (rep visit ((x x))
      (unless (@mem? visited x)
        (set visited (@add visited x))
        (f x) 
        (@do visit (%traits-direct-children (%object-traits x)))))))

(df %slot (owner (getter <gen>) (setter <gen>) type (init <fun>))
  (if (singleton-spec? owner)
      (ensure-traits owner)
      (@do-children forward-traits owner))
  (let ((traits     (%object-traits owner))
	(slot       (isa <slot> (set slot-owner owner)
		      (set slot-getter getter) (set slot-setter setter)
		      (set slot-type   type)   (set slot-init   init)))
	(getter-met (find-getter owner getter))
	(setter-met (find-setter owner type setter)))
    ;; ACCESSORS STORE SLOT IN THEIR ENVIRONMENT
    (set (%met-env getter-met) slot)
    (set (%met-env setter-met) slot)
    (set (%traits-direct-slots traits)
	 (@cat2 (%traits-direct-slots traits) (@lst slot)))
    (set (%traits-slots traits)
	 (traits-ordered-slots traits))
    ;; FLUSH ACCESSOR GENERIC CACHES CAUSE THEY HOLD POTENTIALLY 
    ;; OUTDATED SLOT OFFSETS 
    (@do (fun (slot) (set (%fun-cache (%slot-getter slot)) #f))
	 (%traits-slots traits)) 
    (%adjust-object-values-size owner (%%len (object-slots owner)) owner)
    slot))

(dp %update-instance-for-changed-prototype (new-object)
  (let ((old-traits (%traits-of new-object))
	(new-traits (%traits-forward old-traits))
	(old-object (%make-object)))
    ;; capture old values in temporary container
    (set (%object-values old-object) (%object-values new-object))
    ;; allocate new values in existing object and set new traits
    (%install-object-values new-object (%%len (%traits-slots new-traits)))
    (set (%object-traits new-object) new-traits)
    ;; copy correlated slot values from old to new
    (rep loop-old-slots ((old-slots (%traits-slots old-traits)) (old-offset 0))
      (unless (@empty? old-slots)
        (let ((old-slot   (@head old-slots))
	      (getter     (%slot-getter old-slot))
	      (new-offset (slot-offset new-object getter)))
	  (unless (@= new-offset $getter-not-found)
	    (set (slot-value-at new-object new-offset) 
		 (slot-value-at old-object old-offset))
	    (loop-old-slots (@tail old-slots) (@+ old-offset 1))))))
    new-object))

(df update-instance-for-changed-prototype (object)
  (%update-instance-for-changed-prototype object))

(dv add-slot %slot)

(set %check-types? #t)

;; USED FROM COMPILER TO BUILD GEN'S
;; TODO: NEED FUN-VALUE AS WELL

(df fab-gen
  ((name <sym>) (names <lst>) (specs <lst>) (nary? <log>) (mets <lst>) 
   => <gen>)
  (isa <gen>
    (set fun-code (fun-code %dispatch))
    (set fun-name name)
    (set fun-sig (isa <sig>
                   (set sig-names names)
                   (set sig-specs specs)
                   (set sig-nary? nary?)
                   (set sig-arity (@len specs))
                   (set sig-value <any>)))
    (set fun-mets mets)))

(df gen-from-met ((x <met>) => <gen>)
  (let ((specs (@map (fun (x) <any>) (@fun-specs x))))
    (fab-gen (fun-name x) '() specs (@fun-nary? x) '())))

;; CALLED FROM COMPILER/INTERPRETER

(df %define-method (gen (met <met>) => <gen>)
  (let ((gen (or gen (gen-from-met met))))
    (gen-add-met gen met)
    gen))



;;; 
;;; 14. MACROS
;;; 

(dv *boot-macro-names*     '())
(dv *boot-macro-expanders* '())
(dv *macros-ok?*           #f)  ;; ENOUGH OF WORLD BOOTED TO DEFINE MACROS?

(dp %macro (name expander)
  (if *macros-ok?*
      (%%macro name expander) ;; DEFINED IN AST.PROTO
      (seq ;; REMEMBER NAMES/EXPANDERS FOR LATER INSTALLATION
	(set *boot-macro-names*     (@pair name     *boot-macro-names*))
	(set *boot-macro-expanders* (@pair expander *boot-macro-expanders*)))))

;;;
;;; 15. EXPORTS
;;;

;; Some functions are called directly from prt.c.  For now, we generate
;; artificial free bindings for these symbols in the boot module--and
;; export them--so that other modules will define them under the
;; correct C names.  Please feel free to redesign this if you wish.
;; TODO - It might be worth dumping (mangle-runtime-name ...) in
;; p2c.proto and using this mechanism instead.
(dss (force-names-into-boot-module ,@names)
  (if (empty? names)
      #f
      `(seq (if #f ,(head names))
            (export ,(head names))
            (force-names-into-boot-module ,@(tail names)))))

(force-names-into-boot-module
  unknown-function-error
  file-opening-error
  type-error
  wrong-number-arguments-error
  keyboard-interrupt)  

;; Forward references.
;; TODO - These would normally be defined using need-implementation, but we
;; haven't defined that yet.
(export
  %%macro
  error)

;; Compiler magic.
(export
  use
  export
  mif
  macro-expand
  quasiquote
  dp
  ct
  slot
  isa
  try
  fin
  lab
  rep
  loc
  let
  bound?
  fun
  df
  dg
  dm
  dss
  ds
  dv
  set
  quote
  %raw
  seq
  if)

;; Primitives used in other modules.
(export
  %app-args
  %app-filename
  %bb
  %binding-name
  %c<
  %c=
  %char-ready?
  %close-input-port
  %close-output-port
  %current-input-port
  %current-output-port
  %do-runtime-bindings
  %do-stack-frames
  %eof-object
  %eq?
  %f*
  %f+
  %f-
  %f/
  %f<
  %f=
  %fi2f
  %flo-bits
  %force-output
  %ft
  %i!
  %i&
  %i*
  %i+
  %i-
  %i<
  %i<<
  %i<<<
  %i=
  %i>>
  %i>>>
  %i?
  %i^
  %im
  %invoke-debugger
  %it/
  %iv
  %locative-value
  %locative-value-setter
  %next-methods
  %open-input-file
  %open-output-file
  %os-binding-value
  %os-binding-value-setter
  %os-name
  %pair
  %peek-char
  %read-char
  %write-char
  %write-string)

;; Regular exports.
(export
  <any>
  <bag>
  <chr>
  <col>
  <flat>
  <flo>
  <fun>
  <gen>
  <int>
  <loc>
  <log>
  <lst>
  <met>
  <num>
  <opts>
  <traits>
  <seq>
  <sig>
  <slot>
  <str>
  <sym>
  <tup>
  <vec>

;; tagged structures
  %cb
  %cu
  %fb
  %fu
  %ib
  %iu
  %lu

;; repeated structures
  %sb
  %selt
  %selt-setter
  %slen
  %snul
  %str
  %su
  %vec
  %velt
  %velt-setter
  %vlen
  %vnul

  apply				;; %%apply
  *boot-macro-expanders*	;;var
  *boot-macro-names*		;;var
  %define-method		
  fab-gen
  fab-sym
  fun-arity
  fun-name
  fun-name-setter
  fun-names
  fun-sig-setter
  fun-specs
  fun-value
  head
  head-setter
  %isa
  isa?
  *macros-ok?*
  not
  nul
  object-parents
  object-slots
  %slot
  slot-value ;; TODO remove this when it can be called directly w/o being exported
  slot-value-setter ;; me too
  slot-getter
  slot-setter
  sig-names
  sig-specs
  sig-nary?
  sig-arity
  sig-value
  sym-name
  %symbols
  tail
  tail-setter
)
