;;;; Copyright 2002, Jonathan Bachrach.  See file TERMS.
;;;;
;;;; GOALS
;;;;
;;;; SIMPLEST POSSIBLE
;;;; DYNAMIC ORDER FORM BY FORM
;;;; MINIMIZE OBJECT SYSTEM BOOT OBFUSCATION
;;;;
;;;; TODO
;;;; 
;;;; o RENAME LOW PRIMITIVES TO HAVE TWO %%'s
;;;; o INVENT NAMING CONVENTION FOR COMPILE TIME THINGS SAY &...?
;;;; 

;; Define the primitives whose code is in prt.c
(dss (%define-primitives)
  `(seq ,@(map (fun (name) `(dl ,name)) primitive-names)))

(ct (dv primitive-names
      '(
        %eq? %bb
        %i= %i< %i+ %i- %i* %im %ir %it/ %iv %i^ %i& %i! %i?
        %i<< %i>> %i<<< %i>>>
        %fi2f %f= %f< %f+ %f* %f- %f/ %ft %ft/ %ff %fc %flo-bits
        %fpow %flog %fsqrt 
        %fsin %fcos %ftan 
        %fasin %facos %fatan %fatan2
        %fsinh %fcosh %ftanh
        %c= %c<
        %create-directory
        %current-out-port %current-in-port
        %open-in-file %open-out-file 
        %close-out-port %close-in-port
        %put %puts %file-mtime
        %file-type %file-exists?
        %force-out %ready?
        %get %newline %eof-object %eof-object
        %peek %ready
        %object-class %object-class-setter
        %raw-alloc %object-of %clone
        %prop-elt %prop-elt-setter %prop-dat-at
        %elt %elt-setter
        %slen %selt %selt-setter %%sfab %su %sb
        %rlen %relt %relt-setter %%rfab %ru
        %tlen %telt %telt-setter %%tfab %tu
        %fab-code-refs %code-ref
        %app-filename %app-args
        %loc-val %loc-val-setter %invoke-debugger
        %os-name %os-val %os-val-setter        
        %break %binding-name %fun-reg
        %trace-on %trace-off
        %%apply %%mep-apply %next-methods %fapply
        %do-stack-frames 
        %unexec
        %build-runtime-modules %process-module
        %loc-off %loc-off-setter %raw-call %check-call-types
        %sp-reg %sp-reg-setter %fp-reg %fp-reg-setter %unlink-stack
        %new
        )
))

(%define-primitives)

;; (dss (poo) (error "POO")) (poo) ;; TRIGGER A COMPILER BLOWOUT

;; (ct (dv cat-sym make-sym))

;; Early definitions, so we at least know false != true
(dv %false (%raw 0)) 
(dv %true (%raw 1))

(dv %*used-symbols-too-early* (%raw 0))

;;; Temporary, compile-time-only macros.  These are used by this file only--
;;; we never export them.  The real definitions live in macros.goo.

(dss (unless ,test ,@body)
  `(if (not ,test) (seq ,@body)))

(dss (when ,test ,@body)
  `(if ,test (seq ,@body)))

(dss (or ,@rest)
  (mif ((,x ,@rest) rest)
       (mif (() rest)
            x
            `(let ((tmp ,x))
               (if tmp tmp (or ,@rest))))
       #f))

(dss (and ,@rest)
  (mif ((,x ,@rest) rest)
       (mif (() rest)
            x
            `(let ((tmp ,x))
               (if tmp (and ,@rest) #f)))
       #t))

(dss (cond ,@cases)
  (if (empty? cases)
      #f
      (mif ((,cond ,@body) (head cases))
           `(if ,cond
                (seq ,@body)
                (cond ,@(tail cases)))
           ;; TODO: NEED SYNTAX ERROR CONDITIONS
           (error "COND: SYNTAX ERROR BAD CASE" (head cases)))))

;;;
;;; BOOT OBJECTS
;;;

;; ALL PROTO'S NEEDED FOR BOOT ARE DEFINED HERE
;; THEY ARE DEFINED AS THEY WOULD BE OUTSIDE BOOT

(ct (df %boot-defs ()
      '((dc <any>    (<any>))
        (dv nul      (new <any>))
        (dv nul-prop (new <any>))
        (dc <log>    (<any>))
        (dv %true    (new <log>))
        (dv %false   (new <log>))
        (dc <mag> (<any>))
        (dc <chr> (<mag>))
        ;; (dc <%chr> (<chr>))
        (dc <num> (<mag>))
        (dc <int> (<num>))
        ;; (dc <%int> (<int>))
        (dc <flo> (<num>))
        ;; (dc <%flo> (<flo>))
        (dc <loc> (<any>))
        (dc <rep> (<any>))
        (dc <col> (<any>))
        (dc <col.> (<col>))
        (dc <col!> (<col>))
        (dc <seq> (<col>))
        (dc <seq.> (<seq> <col.>))
        (dc <seq!> (<seq> <col!>))
        (dc <lst> (<seq!>))
        (dv nil (new <lst>))
          (dp head (<lst> => <any>) nil)
          (dp tail (<lst> => <lst>) nil)
        (dc <flat> (<seq>))
        (dc <tup> (<flat> <seq.>))
        (dc <str> (<flat> <seq.> <mag>))
        (dc <sym> (<mag>))
          (dp sym-name (<sym> => <str>))
        (dc <type> (<any>))
        (dc <class> (<type>))
          (dp class-prop-len (<class> => <int>)        0)
          (dp class-name (<class> => <sym>))
          (dp class-parents (<class> => <lst>)         nil)
          (dp class-direct-props (<class> => <lst>)    nil)
          (dp class-ancestors (<class> => <lst>)       nil)
          (dp class-props (<class> => <lst>)           nil)
          (dp class-descendents (<class> => <lst>)     nil)
          ;; ULTIMATELY NEED GENS TO BE FLUSHED DURING CLASS REDEF
          ;; KEEP BOTH GENS/METS CAUSE NO MET->GEN MAP
          ;; WANT TO PRUNE OUT UNNECESSARY GENS BASED ON ACTUAL METS
          (dp class-gens (<class> => <lst>)            nil)
          (dp class-mets (<class> => <lst>)            nil)
          (dp class-forward (<class> => <any>)         #f)
          (dp class-type-cache (<class> => <any>)      #f)
          (dp class-id (<class> => <int>)              -1)
          (dp class-row (<class> => <tup>)             nul)
        (dc <singleton> (<type>))
          (dp type-object (<singleton> => <any>))
        (dc <subclass> (<type>))
          (dp type-class (<subclass> => <class>))
        (dc <union> (<type>))
          (dp type-elts (<union> => <lst>)             nil)
        (dc <prop> (<any>))
          (dp prop-owner (<prop> => <any>))
          (dp prop-getter (<prop> => <fun>))
          (dp prop-setter (<prop> => <fun>))
          (dp prop-type (<prop> =>  <type>))
          (dp prop-init (<prop> =>  <fun>) (fun (x) nul-prop))
        (dc <gen-cache> (<any>))
          (dp gen-cache-missable? (<gen-cache> => <log>)  #f)
          (dp gen-cache-arg-pos (<gen-cache> => <int>)    0)
          (dp gen-cache-singletons (<gen-cache> => <lst>) nil)
          (dp gen-cache-classes (<gen-cache> => <lst>)    nil)
        (dc <sig> (<any>))
          (dp sig-names (<sig> => <lst>) nil)
          (dp sig-specs (<sig> => <lst>) nil)
          (dp sig-nary? (<sig> => <log>) %false)
          (dp sig-arity (<sig> => <int>) 0)
          (dp sig-val   (<sig> => <any>) <any>)
          (dp sig-unification-vars (<sig> => <lst>) nil)
        (dc <fun> (<any>))
          (dp fun-code (<fun> => <any>)  %false)
          (dp fun-name (<fun> => <any>)  %false)
          (dp fun-sig (<fun> => <sig>))
        (dc <met> (<fun>))
          (dp fun-env (<met> => <any>)   %false)
          (dp fun-refs (<met> => <any>)  %false)
          (dp fun-src (<met> => <any>)   %false)
        (dc <gen> (<fun>))
          (dp fun-mets (<gen> => <lst>)  nil)
          (dp fun-cache (<gen> => <any>) %false)
          (dp gen-refs (<gen> => <tup>)  nul)
          (dp gen-src (<gen> => <any>)   %false)
    (dc <opts> (<flat> <seq.>))
      (dp opts-location (<opts> => <loc>) 0)
      (dp opts-count (<opts> => <int>) 0)
    (dc <opts-tup> (<opts>))
      (dp opts-tup-storage (<opts-tup> => <tup>) nul)
)))

;; RETURN CLASS DEFS FROM BOOT DEFS

(ct (df %map-boot-classes (f)
      (rep loop ((res '()) (defs (%boot-defs)))
        (if (empty? defs)
            (rev! res)
            (loop (mif ((dc ,name (,@parents)) (head defs))
                       (pair (f name parents) res)
                       res)
                  (tail defs))))))

;; RETURN OBJECTS DEFS FROM BOOT DEFS

(ct (df %map-boot-objects (f)
      (rep loop ((res '()) (defs (%boot-defs)))
        (if (empty? defs)
            (rev! res)
            (loop (mif ((dv ,name (new ,class)) (head defs))
                       (pair (f name class) res)
                       res)
                  (tail defs))))))

;; RETURN PROP DEFS FROM BOOT DEFS

(ct (df %map-boot-props (f)
      (rep loop ((res '()) (defs (%boot-defs)))
        (if (empty? defs)
            (rev! res)
            (loop (mif ((dp ,name (,owner => ,type) ,@maybe-init)
                        (head defs))
                       (let ((init (if (empty? maybe-init) 
                                       'nul-prop 
                                       (head maybe-init))))
                         (pair (f owner name type init) res)) 
                       res)
                  (tail defs))))))

;;;
;;; 1. CONSTRUCTION MACHINERY FOR BUILDING EARLY OBJECTS
;;;

(dl %allocate-stack (num)
  (def ret (%sp-reg))
  (set (%sp-reg) (%i+ (%sp-reg) (%i* (%raw 4) num)))
  ret)

;; STRUCTURES ARE OBJECT TEMPLATES WITH 
;;   PRIMITIVES FOR ACCESSORS AND 
;;   A PRIMITIVE REQUIRED ONLY CONSTRUCTOR

;; DEFINE ACCESSORS NAMED PROP-NAMES AT INCREASING OFFSETS

(dss (%define-structure-accessors ,@prop-names)
  (loc ((getter (name offset) 
          `(dl ,(cat-sym "%" name) (x)
             (%prop-elt x (%raw ,offset))))
        (setter (name offset)
          `(dl ,(cat-sym "%" name "-setter") (z x)
             (set (%prop-elt x (%raw ,offset)) z))))
    (rep loop ((res '()) (i 0) (names prop-names))
      (if (== names '())
          `(seq ,@(rev! res))
          (let ((name (head names)))
            (loop (pair (getter name i) (pair (setter name i) res))
                  (+ i 1) (tail names)))))))

;; DEFINE STRUCTURE BASE WITH PREFIX FOR CONSTRUCTOR NAME

(dss (%define-structure ,prefix ,class-base-name ,@prop-names)
  (loc ((constructor (name inits)
          (def class-name (cat-sym "<" name ">"))
          `(dl ,(cat-sym prefix name) (,@prop-names) 
             (def class (%object-of ,class-name (%raw ,(len prop-names))))
             ,@inits
             class)))
    (rep loop ((inits '()) (i 0) (names prop-names))
      (if (== names '())
          `(seq (%define-structure-accessors ,@prop-names)
                ,(constructor class-base-name inits))
          (let ((name (head names)))
            (loop (pair `(set (%prop-elt class (%raw ,i)) ,name) inits)
                  (+ i 1) (tail names)))))))

;;;
;;; 2. SETUP EARLY CLASS
;;;

(%define-structure % class
 class-prop-len class-name 
 class-parents class-direct-props
 class-ancestors class-props class-descendents 
 class-gens class-mets class-forward
 class-type-cache class-id class-row)

(%define-structure % singleton type-object)
(%define-structure % subclass  type-class)
(%define-structure % union     type-elts)

(dv <class> (%object-of (%raw 0) (%raw 10)))

;;;
;;; 3. SETUP EARLY OBJECTS
;;;

;;; PLACE HOLDERS FOR EARLY OBJECTS

(dv <lst>    (%object-of <class> (%raw 10))) ;; PLACE HOLDER
(dv nil      (%object-of <lst> (%raw 2)))    ;; AT LEAST GET SIZE RIGHT
(dv one-nil  nil)                            ;; REMEMBER ORIGINAL NIL

;;;
;;; 4. SETUP EARLY CLASSES
;;;

;;; BUILD CLASS SHELLS POINTING TO INCOMPLETE <CLASS>

(dss (%class-shells)
  `(seq ,@(%map-boot-classes
            (fun (name parents)
              `(dv ,name
                 (%class nil nil nil nil nil nil nil nil nil nil nil -1 nil))))))

(%class-shells)

;;; INITIALIZE CLASSES TO BE INSTANCES OF NOW REAL CLASS

(dss (%reparent-class-shells)
  `(seq ,@(%map-boot-classes
            (fun (name parents)
              `(set (%object-class ,name) <class>)))))

(%reparent-class-shells)

;;;
;;; 5. SETUP EARLY OBJECTS
;;;

;;; TODO: NEED SIZES TO BUILD OBJECTS CORRECTLY
;;; TODO: COULD DELAY UNTIL AFTER PROPS

(set (%object-class nil) <lst>)

;;; BUILD BASIC OBJECT HOLDERS

(dss (%object-shells)
  `(seq ,@(%map-boot-objects 
            (fun (name class)
              `(dv ,name (%object-of ,class (%raw 0)))))))

(%object-shells)

(dv %classes-ready? #f)

;;;
;;; 6. SETUP LIST BASICS
;;;

;;; LST BASICS

(%define-structure % lst head tail)

(dl %pair (head tail) (%lst head tail))

(dl %empty? (x) (%bb (%eq? x nil)))

(dl %%len (x) 
  (if (%empty? x) (%raw 0) (%i+ (%%len (%tail x)) (%raw 1))))

;;; INITIALIZE NIL

(set nil         one-nil)
(set (%head nil) nil)
(set (%tail nil) nil)

;;; MET BASICS

(%define-structure % sig 
   sig-names sig-specs sig-nary? sig-arity sig-val sig-unification-vars)

(%define-structure % met 
   met-code met-name met-sig met-env 
   met-refs met-src
   )

(dv %met-prop-len (%raw 4))

;; NOW FALSE AND TRUE HAVE THEIR PERMANENT VALUES.

(dv %symbols-ready?     #f)  ;; READY TO BUILD SYMBOLS?
(dv %*start-running-at* nil)

;;; 
;;; 8. TAGGED OBJECTS
;;; 

;; TAGGED OBJECTS ARE IMMEDIATE OBJECTS WHOSE TYPE AND DATA
;; ARE ENCODED IN ADDRESS
;; USES TWO TAG BITS WITH ADDRESSES HAVING TAG ZERO

(dv $direct-object-class (%raw-alloc (%raw 4)))

(dss ($tag-msk) `(%raw 3))
(dss ($tag-len) `(%raw 2))

(dl %tag-bits (x) (%i& x ($tag-msk)))

(dl %tag (x t) (%iv (%i<< x ($tag-len)) t))

(dl %untag (x) (%i>> x ($tag-len)))

(dss ($adr-tag) `(%raw 0))

(dl %tag-into (x t) (%tag (%untag x) t))

(dl %untag-into (x) (%tag (%untag x) ($adr-tag)))

(dl %indirect-object? (x) (%i= (%tag-bits x) ($adr-tag)))

(dl %class-of (x)
  (def tag (%tag-bits x))
  (if (%bb (%i= tag ($adr-tag)))
      (%object-class x)
      (%elt $direct-object-class tag)))

;; DEFINE EARLY TAGGED CLASS 
;;   WHERE CODE IS ABBREVIATION PREFIX FOR OPS
;;   DEFINES TAG/FAB AND UNTAG OPS
;;   DEFINES TAG2CLASS ENTRY FOR MAP

(dss (%define-tagged-structure ,name ,ptag ,puntag ,code ,tag)
  (let ((class-name (cat-sym "<" name ">"))
        (fab-name   (cat-sym "%" name))
        (tag-name   (cat-sym "%" code "b"))
        (untag-name (cat-sym "%" code "u")))
    `(seq (dl ,tag-name (x) (,ptag x (%raw ,tag)))
          (dl ,fab-name (x) (,tag-name x))
          (dl ,untag-name (x) (,puntag x))
          (set (%elt $direct-object-class (%raw ,tag)) ,class-name))))

(%define-tagged-structure int %tag %untag           i 1) ;; INTEGERS

(%define-tagged-structure chr %tag %untag           c 2) ;; CHARACTERS

(%define-tagged-structure loc %tag-into %untag-into l 3) ;; LOCATIVES

(dv $num-int-bits (%ib (%i- (%iu 32) ($tag-len))))
(dv $max-int 
  (%ib (%i- (%i<< (%iu 1) (%i- (%iu $num-int-bits) (%iu 1))) (%iu 1))))
(dv $min-int
  (%ib (%i<< (%iu 1) (%i- (%iu $num-int-bits) (%iu 1)))))

;;; 
;;;  9. SETUP REPEATED OBJECTS
;;; 

;; DEF STRUCT'S WITH INDEXED ELEMENTS W/ DATA STORED IN DATA PROP
;;   DEFINING CONSTRUCTORS,ACCESSORS,LEN,BOX/UNBOX'ERS(FOR FFI),

(dss (%define-repeated-structure ,name ,elt ,code ,init)
  (let ((class-name (cat-sym "<"  name ">"))
        (nul        (cat-sym "%"  code "nul"))
        (fab        (cat-sym "%"  name))
        (fab!       (cat-sym "%"  name "!"))
        (raw-fab    (cat-sym "%%" code "fab")))
    `(seq (dl ,fab! (len e) (,raw-fab len e))
          (dv ,nul (,fab! (%raw 0) ,init))
          (dl ,fab (len e) (if (%bb (%i= len (%raw 0))) ,nul (,fab! len e))))))

(%define-repeated-structure str <chr> s (%cu #\Space))

(%define-repeated-structure tup <any> t nul) 

(%define-repeated-structure rep <any> r nul) 

;; can't use rep yet because symbols aren't real
(dl %str-eq?-loop (s1 s2 len i)
  (or (%bb (%i= i len))
      (let ((c1 (%selt s1 i)) (c2 (%selt s2 i)))
        (and (%bb (%c= c1 c2))
             (%str-eq?-loop s1 s2 len (%i+ i (%raw 1)))))))

(dl %str-eq? (s1 s2)
  (let ((len (%slen s1)))
    (and (%bb (%i= len (%slen s2)))
         (%str-eq?-loop s1 s2 len (%raw 0)))))

;;;
;;; 7. SETUP HIERARCHY
;;;

;; COMPUTE ALL PARENTS FROM DIRECT PARENTS ASSUMING SIMPLE INHERITANCE

(dl %compute-ancestors (parent)
  (if (%bb (%eq? parent <any>))
      (%pair <any> nil)
      (%pair parent (%compute-ancestors (%head (%class-parents parent))))))

;; DEFINE CHILD / PARENT RELATIONSHIP

(dv *early-classes* nil)

(dl %define-parents (class parents)
  (set *early-classes* (%pair class *early-classes*))
  (set (%class-prop-len class)     0)    ;; NOW INT'S ARE DEFINED
  (set (%class-forward class)      #f)   ;; NOW #F    IS  DEFINED
  (set (%class-parents class)      parents)
  (set (%class-ancestors class)
       (%pair class (%compute-ancestors (%head parents))))
  (set (%class-descendents (%head parents))
       (%pair class (%class-descendents (%head parents)))))

;; DEFINES SINGLE INHERITANCE HIERARCHY FROM TOP TO BOTTOM

(dss (%pairize ,@elts)
  (rep pairize ((elts elts))
    (if (empty? elts)
        '()
        `(%pair ,(head elts) ,(pairize (tail elts))))))

(dss (%define-hierarchy)
  `(seq ,@(%map-boot-classes
            (fun (name parents) 
              `(%define-parents ,name (%pairize ,@parents))))))

(%define-hierarchy)

;; PATCH <ANY>'S PARENTS

(set (%class-ancestors <any>) (%pair <any> nil))

;;;
;;; 10. SETUP SYMBOLS
;;;

;; Get symbol fab up ASAP so we don't have to patch the names of
;; a bunch of objects.

(dl %%sym (raw-str)      ;; Called in code generated by compiler
  (if %symbols-ready?
     (fab-sym (%sb raw-str))
     (set %*used-symbols-too-early* #t)
     #f))

(%define-structure % sym sym-nam)

(dv %symbols nil)

;; EARLY VERSION (PRE TAB) OF SYM CONSING USING LST SET
(if (%bb (%eq? %*used-symbols-too-early* #t))
    (%puts (%current-out-port) (%su
        "Warning: symbols were created in the boot image before the symbol-creation was setup. (Probably from a df or rep)\n")))


;; this first version doesn't have proper symbols, but it works..
(dv fab-sym
  (fun (name)
    (rep lookup ((s %symbols))
      (if (%empty? s)
          (let ((sym (%sym name)))
            (set %symbols (%pair sym %symbols))
            sym)
          (let ((sym (%head s)))
            (if (%str-eq? (%sym-nam sym) name)
                sym
                (lookup (%tail s))))))))

(set %symbols-ready? #t) ;; READY TO CONS SYMBOLS

;; do the same thing, this time the symbols will be filled in
(df fab-sym (name)
  (rep lookup ((s %symbols))
    (if (%empty? s)
        (let ((sym (%sym name)))
          (set %symbols (%pair sym %symbols))
          sym)
        (let ((sym (%head s)))
          (if (%str-eq? (%sym-nam sym) name)
              sym
              (lookup (%tail s)))))))

;; NEED THIS TO BUILD METS -- COMPUTED FOR REAL BELOW
(set (%class-prop-len <met>) (%ib %met-prop-len)) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; !!! Below here we can use functions !!! ;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; MORE LST UTILITIES BUT NOW USING LOCAL METHODS

(dl %rev! (c)
  (rep loop ((l c) (r '()))
    (if (%empty? l)
        r
        (let ((t (%tail l)))
          (set (%tail l) r)
          (loop t l)))))

(dl %cat2 (x y) 
  (rep colx ((lx nil) (x x))
    (if (%empty? x)
        (rep coly ((lxy lx) (y y))
          (if (%empty? y)
              (%rev! lxy)
              (coly (%pair (%head y) lxy) (%tail y))))
        (colx (%pair (%head x) lx) (%tail x)))))


;;; 
;;; 11. BOXED OBJECTS
;;; 

(dss (%define-boxed-structure ,name ,code)
  (let ((class-name (cat-sym "<" name ">"))
        (dat-name   (cat-sym name "-dat"))
        (fab-name   (cat-sym "%" name))
        (box-name   (cat-sym "%" code "b"))
        (unbox-name (cat-sym "%" code "u")))
    `(seq (%define-structure % ,name ,dat-name)
          (dl ,box-name (x) (,fab-name x))
          (dl ,unbox-name (x) (%prop-elt x (%raw 0)))
          )))

(%define-boxed-structure flo f)

;; (%define-boxed-structure chr c)

;; (%define-boxed-structure int i)

;; (%define-boxed-structure loc l)

;;; 5.5. Make optional arg stuff
(%define-structure % opts opts-location opts-count)
(%define-structure % opts-tup opts-tup-location opts-tup-count opts-tup-tup)

;;;
;;; 12. MAKE PROPS AND ACCESSORS
;;; 

;; DEF PROP'S

(%define-structure %% prop
  prop-owner prop-getter prop-setter prop-type prop-init)

;; GENERIC DISPATCH CACHES 
;;   USED IN HIERARCHY DECISION TREE
;;   MAP KEYS TO SUBTREES WHERE KEYS ARE EITHER OBJECTS OR CLASS
;;   AND SUBTREES ARE EITHER OTHER CACHES OR METHODS OR PROP OFFSETS

(%define-structure % gen-cache 
   gen-cache-missable? gen-cache-arg-pos gen-cache-singletons gen-cache-classes
   gen-cache-count)

(dv $gen-cache-singletons-offset 2) ;; TODO: USED IN CACHE UPDATE
(dv $gen-cache-classes-offset    3)

;;; DEF GENERIC'S
 
(%define-structure % gen 
   gen-code gen-name gen-sig gen-mets fun-cache gen-refs gen-src)

(df %prop-offset (owner getter)
  (rep loop ((i (%raw 0)) (props (%class-props (%object-class owner))))
    (if (%empty? props)
        (%iu -1)
        (let ((prop (%head props)))
          (if (%bb (%eq? (%prop-getter prop) getter))
              i
              (loop (%i+ i (%raw 1)) (%tail props)))))))

;; &LISTIFY CONSTRUCTS CODE THAT BUILDS A LIST OF GIVEN ARGS WITH CALLS TO %PAIR

(ct (df &listify (args)
      (if (empty? args)
          'nil
          `(%pair ,(head args) ,(&listify (tail args))))))

;; EARLY DISPATCH ERRORS OUT

(df %early-dispatch (args|...)
  (def gen (%fun-reg))
  (%puts
   (%current-out-port)
   (%su "ERROR: Generic function dispatch called before it existed."))
  ;; die (is there a better way?)
  ((%raw 0)))

(df %add-met (gen met)
  (set (%gen-mets gen) (%pair met (%gen-mets gen))))

;; DEFINE EARLY GENERIC METHOD FOR ACCESSORS

(dss (%define-accessor ,name (,@sig) ,@body)
  (let ((params  (sexpr-signature-parameters sig))
        (specs   (&listify (map (always '<any>) params))))
    `(seq (dv ,name 
            (%gen %early-dispatch ',name 
                  (%sig '() ,specs #f ,(len params) <any> '()) '() #f #f #f))
          (let ((accessor (fun (,@sig) ,@body)))
            (%add-met ,name accessor)
        (set (%met-name accessor) ,name)
            accessor))))

(dss (%define-getter ,name ,owner ,type)
  `(%define-accessor ,name ((x ,owner))
      (%prop-elt x (%prop-offset ,owner ,name))))

(dss (%define-setter ,name ,owner ,type)
  `(%define-accessor ,(cat-sym name "-setter") ((z ,type) (x ,owner))
     (set (%prop-elt x (%prop-offset ,owner ,name)) z)))

;; EARLY ADD-PROP JUST ADDS PROP TO DIRECT-PROPS

(df %add-prop (class prop)
  (set (%class-direct-props class)
       (%pair prop (%class-direct-props class))))

;; DEF GETTER/SETTER/PROPS FOR ALL BOOT CLASS PROPS
;; N.B. PROP METHODS CLOSE OVER PROP

(dss (%define-props)
  `(seq ,@(%map-boot-props 
            (fun (owner name type init) 
              `(let ((getter (%define-getter ,name ,owner ,type))
                     (setter (%define-setter ,name ,owner ,type))
                     ;; TODO: X FROM OWNER VAR
                     (prop   (%%prop ,owner ,name ,(cat-sym name "-setter") 
                                     ,type (fun (x) ,init))))
                 (set (%met-env getter) prop)
                 (set (%met-env setter) prop)
                 (%add-prop ,owner prop))))))

(%define-props)

;;;
;;; 7. FINALIZE PROPS
;;;

;; NEED TO SET ALL PROPS CLASS PROP

(df %collect-direct-props (class)
  (def parent (%head (%class-parents class)))
  (%cat2 (%class-props parent) (%class-direct-props class)))

(df %finalize-props! (name class)
  (set (%class-name class)         name)
  (set (%class-direct-props class) (%rev! (%class-direct-props class)))
  (set (%class-props class)        (%collect-direct-props class))
  (set (%class-prop-len class)     (%ib (%%len (%class-props class))))
  class)

(dss (%finalize-props)
  `(seq ,@(%map-boot-classes
           (fun (name parent) `(%finalize-props! ',name ,name)))))

(%finalize-props)

;;;
;;; 11. FUNCTION PREP
;;; 

;; NEED TO DEF A SLEW OF MONOVARIANT FUN'S 
;;   PRE GENERICS AND IN ORDER TO AVOID CIRCULARITIES
;;   USE PRIMITIVES FOR SPEED FOR NOW

(dl @head (x|<lst> => <any>) (%head x))

(dl @head-setter (z x|<lst>) (set (%head x) z))

(dl @tail (x|<lst> => <lst>) (%tail x))

(dl @tail-setter (z|<lst> x|<lst>) (set (%tail x) z))

(dl @= (x|<int> y|<int> => <log>)
;; optimization based on knowing the tag bits for two ints are always the same
  (%bb (%i= x y)))
;;  (%bb (%i= (%iu x) (%iu y))))

(dl @< (x|<int> y|<int> => <log>)
  (%bb (%i< (%iu x) (%iu y))))

(dl @+ (x|<int> y|<int> => <int>)
  (%ib (%i+ (%iu x) (%iu y))))

(dl @== (x|<any> y|<any> => <log>) (%bb (%eq? x y)))

(df @@== (x|<any> y|<any> => <log>) (%bb (%eq? x y)))

(df not (x|<any> => <log>) (%bb (%eq? x #f)))

(dl @not (x|<any> => <log>) (%bb (%eq? x #f)))

(dl @empty? (x|<lst> => <log>) (%empty? x))

(df @@empty? (x|<lst> => <log>) (%empty? x))

(df @rev! (x|<lst> => <lst>) (%rev! x))

(dl @len (x|<lst> => <int>) (%ib (%%len x)))

(dl @oelt (x|<opts> i|<int>)
  (%loc-off (%opts-location x) (%i- (%raw 0) (%iu i))))
(dl @oelt-setter (z x|<opts> i|<int>) 
  (set (%loc-off (%opts-location x) (%i- (%raw 0) (%iu i))) z))
(dl @olen ((x <opts>) => <int>) (%opts-count x))

(df @all? (test|<fun> c|<lst> => <log>)
  (rep fnd ((p c))
    (if (@empty? p) #t (if (test (@head p)) (fnd (@tail p)) #f))))

(df @all2? (test|<fun> x|<lst> y|<lst> => <log>)
  (rep fnd ((px x) (py y))
    (if (@empty? px) 
        (@empty? py)
        (if (@empty? py)
            #f
            (if (test (@head px) (@head py)) 
                (fnd (@tail px) (@tail py))
                #f)))))

(df @elt (x|<lst> key|<int> => <any>)
  (rep fnd ((count|<int> 0) (x|<lst> x))
    (if (@== x '())
        nul
        (if (@= count key) (@head x) (fnd (@+ count 1) (@tail x))))))

(df @fill (x|<lst> f|<fun> => <lst>)
  (rep loop ((p x))
    (if (@empty? p) x (seq (set (@head p) f) (loop (@tail p))))))

(df @any? (test|<fun> c|<lst> => <any>) ;; TODO: => <log>
  (rep fnd ((p c))
    (if (@empty? p) #f (or (test (@head p)) (fnd (@tail p))))))

(dl @pair (h|<any> t|<lst> => <lst>) (%pair h t))

(dl @add (c|<lst> e|<any> => <lst>) (@pair e c))

(dl @add-new (c|<lst> e|<any> => <lst>) 
  (if (@mem? c e) c (@pair e c)))

(df @map (f|<fun> x|<lst> => <lst>)
  (rep do ((x x) (res '()))
    (if (@empty? x)
        (@rev! res)
        (do (@tail x) (@pair (f (@head x)) res)))))

(df @pick (f|<fun> x|<lst> => <lst>)
  (rep do ((x x) (res '()))
    (if (@empty? x)
        (@rev! res)
        (let ((h (@head x))) (do (@tail x) (if (f h) (@pair h res) res))))))

(df @do (f|<fun> x|<lst>)
  (rep do ((x x))
    (if (@empty? x)
        #f
        (seq (f (@head x)) (do (@tail x))))))

(df @alter (dst|<lst> src|<lst> => <lst>)
  (rep in ((ds dst) (ss src))
    (if (or (@empty? ds) (@empty? ss))
        dst
        (seq (set (@head ds) (@head ss))
             (in (@tail ds) (@tail ss))))))

(df @fab (x|<lst> s|<int> => <lst>)
  (rep fab (((i <int>) s) ((res <lst>) '()))
    (if (@< i 0) res (fab (@+ i -1) (@pair nul res)))))

(df @fold (combine|<fun> init|<any> c|<lst> => <lst>)
  (rep red ((res init) (c c))
    (if (@empty? c)
        res
        (red (combine res (@head c)) (@tail c)))))

(df @rev ((x <lst>) => <lst>)
  (rep loop ((l x) (r '()))
    (if (@empty? l)
        r
        (loop (@tail l) (@pair (@head l) r)))))

(df @cat2 (x|<lst> y|<lst> => <lst>)
  (%cat2 x y))

(df @find (f|<fun> c|<lst> => <any>) ;; TODO: => <int>
  (rep fnd ((c c) (i 0))
    (if (@empty? c)
        nul
        (if (f (@head c))
            i
            (fnd (@tail c) (@+ i 1))))))

(df @mem? (c|<lst> x|<any> => <log>)
  (not (@== (@find (fun (y) (@== x y)) c) nul)))

;; added rev! since it was returning the list backwards. TODO: make it more
;; efficient.
(df @del-dups (x|<lst> => <lst>)
  (@rev! (@fold (fun (s e) (if (@mem? s e) s (@pair e s))) '() x)))

(df @lst-helper (objects|<opts> i|<int> l|<lst>)
  (if (@== i -1)
      l
      (@lst-helper objects (@+ i -1) (@pair (@oelt objects i) l))))

(df @opts-as-lst (x|<opts> => <lst>)
  (@lst-helper x (@+ (@olen x) -1) '()))

(df @lst (objects|...) (@lst-helper objects (@+ (@olen objects) -1) '()))

(dl @tlen (x|<tup> => <int>)
  (%ib (%tlen x)))

(dl @telt (x|<tup> i|<int> => <any>)
  (%telt x (%iu i)))

(dl @telt-setter (z x|<tup> i|<int>)
  (set (%telt x (%iu i)) z))

(df @tup (args|...)
  (def l (@olen args))
  (def t (%tup (%iu l) nul))
  (if (@= l 2) ;; MOST FREQUENT CASE AND SPEED CRITICAL
      (seq (set (@telt t 0) (@oelt args 0))
           (set (@telt t 1) (@oelt args 1)))
      (rep into ((k (@+ l -1)))
        (unless (@= k -1)
          (set (@telt t k) (@oelt args k))
          (into (@+ k -1)))))
  t)

(df @fun-names (x|<fun> => <lst>) (%sig-names (%gen-sig x)))

(df @fun-specs (x|<fun> => <lst>) (%sig-specs (%gen-sig x)))

(df @fun-nary? (x|<fun> => <log>) (%sig-nary? (%gen-sig x)))

(df @fun-arity (x|<fun> => <int>) (%sig-arity (%gen-sig x)))

(df @fun-val   (x|<fun> => <any>) (%sig-val (%gen-sig x)))

(df @fun-unification-vars (x|<fun> => <lst>) (%sig-unification-vars (%gen-sig x)))

(df @fun-mets (x|<fun> => <lst>) (%gen-mets x))

(df @fun-mets-setter (z|<lst> x|<fun>) (set (%gen-mets x) z))

;;; 
;;; 12. FUNCTIONS
;;; 

(dv <env>   <any>)
(dv <specs> <lst>)
(dv <body>  <any>)

(df fun-spec (x|<met> i|<int> => <any>)
  (@elt (@fun-specs x) i))

(dv <mets> <lst>)

(df fun-same-met? (x|<met> y|<met> => <log>)
  (@all2? @@== (@fun-specs x) (@fun-specs y)))

(df fun-congruent? (x|<fun> y|<fun> => <log>)
  (and (@=  (@fun-arity x) (@fun-arity y))
       (@== (@fun-nary? x) (@fun-nary? y))
       (@all2? @subtype? (@fun-specs x) (@fun-specs y))
       (@subtype? (@fun-val x) (@fun-val y))))

(dv *restarts-ok?* #f)

;;; Add a method to a generic function.  Note that this function might
;;; *create* a new generic function, and add the method to that instead.
;;; Return the generic function to which the method was added.
(df gen-add-met (g|<gen> m|<met> => <gen>)
  (set (%fun-cache g) #f)
  (if (not (fun-congruent? m g))
      ;; Raise a method congruency error.  If restarts have been set up,
      ;; install an appropriate restart handler.  Note that we don't install
      ;; the handler until *after* the error for performance reasons.
      (if *restarts-ok?*
          (esc return
            (try ((type <replace-generic-restart>)
                  (description
                   "Replace %= with an empty generic congruent with %=" g m))
              (fun (c r)
                (return (gen-add-met (gen-from-met m) m)))
              (incongruent-method-error g m)))
          (incongruent-method-error g m))
      
      ;; DEP TRACK MET/GEN IN ALL REAL SPECS -- USED FOR REDEFINITION
      (seq
        (rep lop ((specs (@fun-specs m)))
          (unless (@empty? specs)
            (def spec (@head specs))
            ;; TODO: CHANGE TO REFLECT NEW SETUP -- DEP-CLASSES
            (unless (or (@singleton-spec? spec) (@== spec <any>))
              (def spec-class (%object-class spec))
              (set (%class-gens spec-class)
                   (@add-new (%class-gens spec-class) g))
              (set (%class-mets spec-class)
                   (@add-new (%class-mets spec-class) m))
              (lop (@tail specs)))))
        ;; ACTUALLY PERFORM ADDITION KEEPING TRACK OF IT BEING A REPLACEMENT
        ;; OR NOT
        (rep col ((mets '()) (same? #f) ((gms <mets>) (@fun-mets g)))
          (if (@empty? gms)
              (set (%gen-mets g) (@rev! (if same? mets (@add mets m))))
              (let ((gm         (@head gms))
                    (now-same?  (fun-same-met? gm m)))
                (col (@add mets (if now-same? m gm)) 
                     (or now-same? same?) (@tail gms)))))
        g)))

;; (dl @class-in? (c cs => <log>)
;;   (or (@== (%head cs) c) ; at least one ancestor
;;       (let ((next-cs (%tail cs)))
;;         (if (%empty? next-cs)
;;             #f
;;             (@class-in? c next-cs)))))

(dl @subclass? (c1 c2 => <log>)
  (%bb (%i= (%selt (%class-row c1) (%iu (%class-id c2))) (%iu 1)))
  ;; (or (@== c2 <any>) (@== c1 c2)
  ;;     (@class-in? c2 (%class-ancestors c1)))
  )

(dl @class-isa? (o c => <log>)
  (@subclass? (%class-of o) c))

;; ;; specialized for usage with function call/return type checks
;; (dl @type-check-class-isa? (o c2 => <log>)
;;   (def c1 (%class-of o))
;;   (def c3 (%class-type-cache c2))                ; last successful class to pass check
;;   (or (@== c1 c3)                 
;;       (and (@class-in? c2 (%class-ancestors c1))
;;            (set (%class-type-cache c2) c1)       ; cache new winner
;;            #t)))

(dl @singleton-isa? (o t => <log>)
  ;; TODO: FIX UP TO DO PROPER ==
  (@== (%type-object t) o))

(df @isa? (o t => <log>)
  (if (@== (%class-of t) <class>)
      (@class-isa? o t)
      (isa? o t)))

(df @class< (c1 c2 wrt => <log>)
  (rep find ((ps (%class-ancestors wrt)))
    (if (@empty? ps)
        (error "can't order specializers - arg/reference object %= is "
               "neither %= nor %=" wrt c1 c2) 
        (let ((c (@head ps)))
          (if (@== c c1)
              #t
              (if (@== c c2)
                  #f
                  (find (@tail ps))))))))

(dv tup @tup)

;; TODO: DEF SUBTYPE METHODS

(df @type-equal? (t1 t2 => <log>)
  (or (@== t1 t2)
      (and (not (@== (%class-of t1) <class>)) (not (@== (%class-of t2) <class>))
           (@subtype? t1 t2) (@subtype? t2 t1))))

(df @subtype? (t1 t2 => <log>)
  (if (and (@== (%class-of t2) <class>) (@== (%class-of t1) <class>))
      (@subclass? t1 t2)
      (subtype? t1 t2)))
  
(df @may-isa? (c|<class> t|<type> => (tup <log> <log>))
  (if (@== (%class-of t) <class>)
      (if (@subclass? c t) (@tup #t #t) (@tup #f #f))
      (may-isa? c t)))

(df @order-specs-class (t1 t2 arg)
  (if (@== t1 t2)
      (@tup '= t1)
      (if (@class< t1 t2 (%class-of arg))
          (@tup '< t1)
          (@tup '> t2))))

(df @order-specs (t1 t2 arg)
  (if (and (@== (%class-of t1) <class>) (@== (%class-of t2) <class>))
      (@order-specs-class t1 t2 arg)
      (order-specs t1 t2 arg)))

(df order-mets (m1|<met> m2|<met> args|<opts> => <sym>)
  (def arity|<int> (@fun-arity m1))
  (rep loop ((state|<sym> '=) (idx|<int> 0))
    (if (@= idx arity)
        state
        (let ((m1spec (fun-spec m1 idx))
              (m2spec (fun-spec m2 idx))
              (cmp+typ|<tup> (@order-specs m1spec m2spec (@oelt args idx)))
              (cmp|<sym> (@telt cmp+typ 0))
              (idx|<int> (@+ idx 1)))
          (if (@== cmp '=)
              (loop state idx)
              (if (and (not (@== cmp '<>))
                       (or (@== state '=) (@== cmp state)))
                  (loop cmp idx)
                  '<>))))))

(df ord-app-mets-1
    (mets|<lst> args|<opts> order-mets|<fun> => (tup ordered|<lst> ambig|<lst>))
  (def ohead|<lst> (@pair #f '()))
  (def ahead|<lst> (@pair #f '()))
  (rep loop ((mets|<lst> mets))
    (unless (@== mets '())
      (def met|<met> (@head mets))
      (loc ((make-ambiguous ((headed-list <lst>))
              (rep loop ((l|<lst> (@tail headed-list)))
                (or (@== l '())
                    (let ((t1 (@tail l)))
                      (set (@tail l) (@tail ahead))
                      (set (@tail ahead) l)
                      (loop t1))))
              (set (@tail headed-list) '())
              (set (@tail ahead) (@pair met (@tail ahead))))
            (precedes-all? ((l <lst>))
              (rep loop ((l|<lst> l))
                (if (@== l '())
                    #t
                    (if (@== (order-mets met (@head l) args) '<)
                        (loop (@tail l))
                        #f))))
            (check-subsequent-ambiguities ((oprev <lst>))
              (if (or (not (precedes-all? (@tail oprev)))
                      (not (precedes-all? (@tail ahead))))
                  (make-ambiguous oprev)
                  (set (@tail oprev) (@pair met (@tail oprev)))))
            (insert ((oprev <lst>) (osub <lst>))
              (if (@empty? osub)
                  (check-subsequent-ambiguities oprev)
                  (let ((indic (order-mets met (@head osub) args)))
                    (if (@== indic '<);; comes before current one.
                        (check-subsequent-ambiguities oprev)
                        (if (@== indic '>);; comes after, check further.
                            (insert osub (@tail osub))
                            (make-ambiguous oprev)))))))
        (insert ohead (@tail ohead))
        (loop (@tail mets)))))
  (@tup (@tail ohead) (@tail ahead)))

(dv met-app-unify (fun (x y) #f))

(df met-app? (met|<met> args|<opts> => <log>)
  (if (not (@empty? (@fun-unification-vars met)))
      (met-app-unify met args)
      (let ((n|<int> (@fun-arity met)))
        (rep loop ((i|<int> 0))
          (if (@= i n)
              #t
              (if (@isa? (@oelt args i) (fun-spec met i))
                  (loop (@+ i 1))
                  #f))))))

(df ord-app-mets* (gf|<gen> args|<opts> => (tup ordered|<lst> ambig|<lst>))
  (def considered-mets
    (rep col ((ans '()) (ms (@fun-mets gf)))
      (if (@empty? ms)
          ans
          (let ((m (@head ms))
                (ans (if (met-app? m args) (@pair m ans) ans)))
            (col ans (@tail ms))))))
  (ord-app-mets-1 considered-mets args order-mets))

(df ord-app-mets (gf|<gen> args|... => (tup ordered|<lst> ambig|<lst>))
  (ord-app-mets* gf args))

;; (df opt-args (n|<int> args|<opts> => <opts>)
;;   (rep col ((i|<int> 0) (l|<opts> '()) (p|<opts> args))
;;     (if (@= i n)
;;       (if (@empty? l)
;;           (@lst p)
;;           (seq (set (@tail l) (@lst p)) args))
;;       (col (@+ i 1) p (@tail p)))))

(df @gen-cache-arg-pos (x)             (%gen-cache-arg-pos x))
(df @gen-cache-arg-pos-setter (z x)    (set (%gen-cache-arg-pos x) z))
(df @gen-cache-singletons (x)          (%gen-cache-singletons x))
(df @gen-cache-singletons-setter (z x) (set (%gen-cache-singletons x) z))
(df @gen-cache-classes (x)             (%gen-cache-classes x))
(df @gen-cache-classes-setter (z x)    (set (%gen-cache-classes x) z))

;; GIVEN MET/GEN AND ARGS FIND PROP-OFFSET -- USING PROP IN MET ENV

(df method-accessor-offset (gen|<gen> met|<met> args|<opts>)
  (def prop  (%met-env met)) ;; TODO: THIS NEEDS TO BE IMPROVED
  (def prop? (and prop (@== (%class-of prop) <prop>)))
  (def n     (@olen args))
  (and prop?
       (if (@= n 1);; getter?
           (prop-offset (@oelt args 0) gen)
           (prop-offset (@oelt args 1) (%prop-getter prop)))))

(df @singleton-spec? (x)
  (@class-isa? x <singleton>))

(df @subclass-spec? (x)
  (@class-isa? x <subclass>))

(df @union-spec? (x)
  (@class-isa? x <union>))

(df @precise-spec? (x)
  (or (@singleton-spec? x) (@subclass-spec? x) 
      (and (@union-spec? x) (@any? @precise-spec? (%type-elts x)))))

(df @mets-unspecialized-at? (mets|<lst> pos|<int> => <log>)
  (@all? (fun (met) (@= (fun-spec met pos) <any>)) mets))

(df @prune-mets-by-type-at
    (mets|<lst> type|<type> pos|<int> => <mets>)
  (@pick (fun (met) (@subtype? type (fun-spec met pos))) mets))

(df @mets-specs-at (mets|<lst> pos|<int> => <lst>)
  (@map (fun (met) (fun-spec met pos)) mets))

;; TODO: GROVEL THROUGH UNIONS

(df @mets-singletons-at (mets|<lst> pos|<int> => <lst>)
  (@pick (fun (spec) (@singleton-spec? spec)) (@mets-specs-at mets pos)))

(df @mets-subclasses-at (mets|<lst> pos|<int> => <lst>)
  (@pick (fun (spec) (@subclass-spec? spec)) (@mets-specs-at mets pos)))

(dv $nul-assocs %tnul)

(df @cache-add (t|<tup> k v)
  (def olen (@tlen t))
  (def res  (%tup (%iu (@+ olen 2)) nul))
  (rep copy ((i 0))
    (unless (@= i olen)
      (set (@telt res i) (@telt t i))
      (def i (@+ i 1))
      (set (@telt res i) (@telt t i))
      (copy (@+ i 1))))
  (set (@telt res olen)        k)
  (set (@telt res (@+ olen 1)) v)
  res)

(df gen-lookup-miss-1-using
  (key instance all-assocs|<fun> all-assocs-setter|<fun> 
   gen|<gen> cache mets|<lst> sorted-mets|<lst> i|<int> args|<opts>)
  ;; (if (or (and cache (@< i (%gen-cache-arg-pos cache)))
  ;;         (@mets-unspecialized-at? mets i))
  ;;     (gen-lookup-miss-1 gen cache mets sorted-mets (@+ i 1) args)
  (def cache  (or cache (%gen-cache #t i $nul-assocs $nul-assocs (%raw 0))))
  (def assocs (all-assocs cache))
  (rep loop ((j 0))
    (if (@= j (@tlen assocs)) ;; miss
        ;; could be a stale object
        (if (and (@== all-assocs @gen-cache-classes)
                 (%class-forward key))
            (seq (update-instance-for-changed-class instance)
                 (set key (%class-of instance)) ; reset key to new class
                 (loop (all-assocs cache)))     ; restart search cause might hit
            (let ((val (gen-lookup-miss-1 gen #f mets sorted-mets (@+ i 1) args)))
              (set (all-assocs cache) (@cache-add assocs key val))))
        (if (@== (@telt assocs j) key)
            (let ((v (@telt assocs (@+ j 1))))
              (gen-lookup-miss-1 gen v mets sorted-mets (@+ i 1) args))
            (loop (@+ j 2)))))
  cache)

;;; copy args with arg as i'th elt into a opts.
(df @specd-args (args|<opts> i|<int> arg|<any> => <opts>)
  (def v (%tup (%iu (@olen args)) nul))
  (def r (%opts-tup (%lb (%prop-dat-at v (%tlen v))) (%ib (%tlen v)) v))
  (rep copy ((k 0))
    (if (@== (@olen args) k)
        r
        (seq (set (@oelt r k) (if (@== k i) arg (@oelt args k)))
             (copy (@+ k 1))))))

;; does the specified position require singleton precision always?
(df requires-singleton-prec (mets pos)
  (not (@empty? (@mets-subclasses-at mets pos))))

;; TODO: SHOULD BE USING @MAY-ISA? 
;;
;;   (not (@empty?
;;         (@pick
;;          (fun (spec)
;;            (not (or (@class-isa? spec <class>) 
;;                     (and (@class-isa? spec <singleton>)
;;                          (or 
;;                           (not (@class-isa? (%type-object spec) <type>))
;;                           (@class-isa? (%type-object spec) <class>))))))
;;          (@mets-specs-at mets pos)))))

(df ensure-singleton-cache
    (gen|<gen> cache mets|<lst> sorted-mets|<lst> i|<int> args|<opts>)
  (or cache 
      ;; prefill with singletons
      (if (requires-singleton-prec mets i)
          (%gen-cache #f i $nul-assocs $nul-assocs (%raw 0))
          (let ((singletons (@mets-singletons-at mets i)))
            (if (@empty? singletons)
                #f ;; no prefilling needed and no cache supplied
                (let ((cache (%gen-cache #t i $nul-assocs $nul-assocs (%raw 0))))
                  ;;??? (set (%fun-cache gen) cache)
                  (rep loop ((singletons singletons))
                    (if (@empty? singletons)
                        cache
                        (let ((sing     (@head singletons))
                              (arg      (%type-object sing))
                              (args     (@specd-args args i arg))
                              (smets    (choose-methods gen args))
                              (app-mets (@prune-mets-by-type-at mets sing i)))
                          (gen-lookup-miss-1-using arg arg
                           @gen-cache-singletons @gen-cache-singletons-setter 
                           gen cache mets smets i args)
                          (loop (@tail singletons)))))))))))

(df gen-lookup-miss-1
    (gen|<gen> ocache mets|<lst> sorted-mets|<lst> i|<int> args|<opts>)
  (if (@= i (@fun-arity gen))
      (or (method-accessor-offset gen (@head sorted-mets) args) sorted-mets)
      (let ((arg   (@oelt args i))
            (cache (ensure-singleton-cache gen ocache mets sorted-mets i args))
            (sing? (@singleton-spec? (fun-spec (@head sorted-mets) i))))
        (if (or (and sing? (@== ocache cache));; sing args not seen?
                (and cache (not (%gen-cache-missable? cache))));; force sing?
            (let ((mets (@prune-mets-by-type-at mets (%singleton arg) i)))
              (gen-lookup-miss-1-using
               arg arg @gen-cache-singletons @gen-cache-singletons-setter
               gen cache mets sorted-mets i args))
            (if sing? ;; sing arg doesn't belong in this cache
                cache ;; already in cache by way of ensure-singleton-cache?
                (let ((class (%class-of arg))
                      (app-mets (@prune-mets-by-type-at mets class i)))
                  (gen-lookup-miss-1-using
                   class arg @gen-cache-classes @gen-cache-classes-setter
                   gen cache app-mets sorted-mets i args)))))))

(df gen-lookup-miss (gen|<gen> args|<opts> => <any>) 
  (def mets (choose-methods gen args)) ;; TODO: => (or <met> <gen-cache>)
  (gen-lookup-miss-1 gen (%fun-cache gen) (%gen-mets gen) mets 0 args))

(dl gen-lookup-1) ;; FORWARD DECL

(dl gen-lookup (gen|<gen> args|<opts>)
  (def c (or (%fun-cache gen)
             (set (%fun-cache gen) (gen-lookup-miss gen args))))
  (gen-lookup-1 gen c args))

(dl prop-value-at (object offset|<int> => <any>)
  (def val (%prop-elt object (%iu offset)))
  (if (@== val nul-prop)
      (let ((props (object-props object)))
        (set (%prop-elt object (%iu offset))
             ((%prop-init (@elt props offset)) object)))
      val))

(dl prop-bound-at? (object offset|<int> => <log>)
  (def val (%prop-elt object (%iu offset)))
  (if (@== val nul-prop)
      (let ((props (object-props object)))
        (not (@== (%prop-init (@elt props offset)) %prop-unbound-error)))
      #t))

(dl prop-value-at-setter (z object offset|<int>)
  (set (%prop-elt object (%iu offset)) z))

(dv $missed-dispatch (%pair nil nil))

;; MAIN DISPATCH ARG STEP (FOR SINGLETONS AND CLASSES) RESULTING IN HIT OR MISS
;; HIT RETURNS ASSOCD VALUE AND REORDERS ASSOCS PUT KEY AT FRONT REFLECTIN FREQS
;; MISS ADDS KEYS (UNLESS MISSABLE) AND THEN RERUNS LOOKUP FROM BEGINNING

(dl gen-lookup-1-using
    (key i len assocs|<tup> missable? gen|<gen> args|<opts>)
  (if (%bb (%i= i len))
      (if missable?
          $missed-dispatch
          (seq (set (%fun-cache gen) (gen-lookup-miss gen args))
               (gen-lookup gen args))) ;; restart lookup
      (if (@== (%telt assocs i) key)
          (gen-lookup-1 gen (%telt assocs (%i+ i (%raw 1))) args)
          (gen-lookup-1-using key (%i+ i (%raw 2)) len assocs missable? gen args))))

;; DISPATCH ARG STEP RUNNING BOTH SINGLETON AND CLASS DISPATCH
;; IF HIT THEN 
;;   IF LAST ARG THEN LEAF WITH INT MEANING PROP-OFFSET ELSE METHOD
;;               ELSE RECURSE WITH NEXT ARG

(dl gen-lookup-1 (gen|<gen> cache args|<opts>)
  (if (@== (%class-of cache) <gen-cache>)
      (let ((arg (@oelt args (%gen-cache-arg-pos cache)))
            (val (let ((assocs (%gen-cache-singletons cache)))
                   ;; first look in singleton cache
                   (gen-lookup-1-using
                    arg (%raw 0) (%tlen assocs) assocs 
                    (%gen-cache-missable? cache) gen args))))
        (if (@== val $missed-dispatch)
            (let ((assocs (%gen-cache-classes cache)))
              ;; otherwise look in class cache
              (gen-lookup-1-using
               (%class-of arg) (%raw 0) (%tlen assocs) assocs #f gen args))
            val))
      cache))

;; TODO: CONDITIONS FOR THESE ERRORS

(df choose-methods (gen|<gen> args|<opts> => <lst>)
  (def ord-amb-mets   (ord-app-mets* gen args))
  (def sorted-mets    (@telt ord-amb-mets 0))
  (def ambiguous-mets (@telt ord-amb-mets 1))
  ;;    (if (@< 0 (@len ambiguous-mets))
  ;;        (error "Ambiguous Method Error when calling %= on %=" gen args)
  (if (@empty? sorted-mets)
      (error "No applicable methods error when calling %= on %=" 
             gen (@opts-as-lst args))
      sorted-mets))

;; FIXME: note the horrible hack in g2c that makes it not generate
;; an UNLINK_STACK at the end of this function.
;; The way this works right now is not a long term solution.

(df %dispatch (args|...)
  (let ((result (gen-lookup (%fun-reg) args)))
    (if (@== (%class-of result) <int>) ;; int?
        (let ((res
               (if (@= (@olen args) 1) ;; getter?
                   (prop-value-at (@oelt args 0) result)
                   (set (prop-value-at (@oelt args 1) result)
                        (@oelt args 0)))))
          (%unlink-stack)
          res)
        (let ((m (%head result))) 
          (%unlink-stack) 
          (set (%loc-off (%sp-reg) (%raw -1)) m) ;; replace gen w/ met on stack
          (%raw-call m (%tail result))))))

;; READY TO REPLACE EARLY DISPATCHER WITH REAL DISPATCHER IN EARLY GEN'S

(df %patch-early-generic (generic|<gen>)
  (set (%gen-code generic) (%met-code %dispatch)))

(dss (%patch-early-generics)
  `(seq ,@(%map-boot-props 
            (fun (owner name type init) 
              `(seq 
                 (%patch-early-generic ,name)
                 (%patch-early-generic ,(cat-sym name "-setter")))))))

(%patch-early-generics)

;; SIG TRAMPOLINES THROUGH FUN'S

(dss (def-fun/sig-accessor ,name)
  `(seq (df ,(cat-sym "fun-" name) (x)
          (,(cat-sym "sig-" name) (fun-sig x)))
        (df ,(cat-sym "fun-" name "-setter") (z x) 
          (set (,(cat-sym "sig-" name) (fun-sig x)) z))))

(def-fun/sig-accessor names)
(def-fun/sig-accessor specs)
(def-fun/sig-accessor nary?)
(def-fun/sig-accessor arity)
(def-fun/sig-accessor val)
(def-fun/sig-accessor unification-vars)

;;; 
;;; 13. OBJECTS
;;; 

(dv <parents> <lst>)
(dv <props>   <lst>)

(df object-class (x) (%class-of x))
(df @class-ancestors (x) (%class-ancestors x))

(df class-ordered-ancestors (c|<class> => <parents>)
  (loc ((merge-lists ((partial-cpl <lst>) (remaining-lists <lst>))
          ;; the partial-cpl is in reverse order at this point.
         (if (@all? @@empty? remaining-lists)
             (@rev! partial-cpl)
             (loc ((unconstrained-class (p)
                    (loc ((p-in-and-unconstrained-in? ((l <lst>))
                           (@== (@head l) p))
                          (p-unconstrained-in? ((l <lst>))
                           (or (@== (@head l) p) (not (@mem? (@tail l) p)))))
                      (and (@any? p-in-and-unconstrained-in? remaining-lists)
                           (@all? p-unconstrained-in? remaining-lists)
                           p)))
                   (unconstrained-class-in-parents ((c <class>))
                     (@any? unconstrained-class (%class-parents c))))
               (let ((next (@any? unconstrained-class-in-parents partial-cpl)))
                 (if next
                      (loc ((remove-next ((l <lst>))
                              (if (@== (@head l) next) (@tail l) l)))
                        (merge-lists 
                         (@pair next partial-cpl)
                         ;; (@alter remaining-lists 
                           (@map remove-next remaining-lists)
                         ;; )
                         ))
                      (error "inconsistent precedence graph")))))))
     (def parents (%class-parents c))
     (merge-lists (@lst c)
                  (@add (@map @class-ancestors parents) parents))))

(df @class-direct-props (x) (%class-direct-props x))

(df class-ordered-props (x|<class> => <props>)
  (def props
    (@del-dups
     (@fold @cat2 '() (@map @class-direct-props (@rev (%class-ancestors x))))))
  (set (%class-prop-len x) (@len props))
  props)

(df del-class (class|<class>)
  ;; TODO: DEL ALL DIRECT-PROPS
  ;; TODO: FLUSH ALL GEN'S ON ALL PROPS
  ;; TODO: DEL SELF FROM ALL DIRECT-PARENTS
  )

(dv *next-class-id* 0)
(dv $max-classes    500)

(df init-class (x)
  (when (@< $max-classes *next-class-id*)
    (error "Too many classes %=\n" $max-classes))
  (set (%class-id x)   *next-class-id*)
  (set *next-class-id* (@+ *next-class-id* 1))
  (unless (@== x <any>)
    (@do (fun (parent) 
           (set (%class-descendents parent)
                (@add-new (%class-descendents parent) x)))
         (%class-parents x))
    (set (%class-ancestors x) (class-ordered-ancestors x)))
  (def row (%str (%iu $max-classes) (%iu 0)))
  (set (%class-row x)       row)
  (@do (fun (ancestor) (set (%selt row (%iu (%class-id ancestor))) (%iu 1)))
       (%class-ancestors x))
  (set (%class-props x)     (class-ordered-props x))
  x)

(df fab-class (name|<sym> parents|<parents> => <class>)
  (def x (%class 0 name parents '() '() '() '() '() '() #f #f -1 nul))
  (init-class x)
  x)

(df refab-class (old-class|<class> parents|<parents> => <class>)
  ;; TODO: WHAT TO DO WITH OLD PROPS? -- REUSE THEM FOR NOW
  ;;       EXCEPT ALL OLD METS ARE SPEC'D ON OLD-CLASS
  ;; TODO: NEED CONCRETE-CLASS CLASS FOR THIS
  (def new-class (fab-class parents (%class-direct-props old-class)))
  (set (%class-forward old-class) new-class)
  new-class)

;; TRAMPOLINE META METHODS
;; TODO: OBSOLETE

(dss (def-object-class-accessor ,name)
  `(df ,(cat-sym "object-" name) (x) 
     (,(cat-sym "%class-" name) (%class-of x))))

(def-object-class-accessor props)
(def-object-class-accessor parents)

;;;
;;; PROPS
;;;

(dv $getter-not-found -1)

(df ensure-fresh-object (x)
  (when (%class-forward (%class-of x)) ;; stale object?
    (update-instance-for-changed-class x)))

(df prop-offset (object getter|<fun> => <int>)
  (rep loop ((i 0) (props (object-props object)))
    (if (@empty? props)
        $getter-not-found
        (if (@== (%prop-getter (@head props)) getter)
            i
            (loop (@+ i 1) (@tail props))))))

(dv *report-prop-unbound-errors?* #t) ;; TODO: SHOULD BE DDV

(df %prop-unbound-error (x)
  (if *report-prop-unbound-errors?*
      (error "property unbound")
      nul))

(df prop-value (object getter|<fun> => <any>)
  (ensure-fresh-object object)
  (def offset (prop-offset object getter))
  (if (@= offset $getter-not-found)
      (error "prop %s not found in %=" getter object)
      (prop-value-at object offset)))

(df prop-bound? (object getter|<fun> => <log>)
  (ensure-fresh-object object)
  (def offset (prop-offset object getter))
  (if (@= offset $getter-not-found)
      (error "prop %s not found in %=" getter object)
      (prop-bound-at? object offset)))

(df prop-value-setter (z object getter|<fun>)
  (ensure-fresh-object object)
  (rep loop ((i 0) (props (object-props object)))
    (if (@empty? props)
        (error "prop %s not found in %=" getter object)
        (let ((prop (@head props)))
          (if (@== (%prop-getter prop) getter)
              (if (@isa? z (%prop-type prop))
                  (set (prop-value-at object i) z)
                  (error "Prop type error"))
              (loop (@+ i 1) (@tail props)))))))

(df find-getter (owner|<class> getter|<gen> => <met>)
  (rep loop ((mets (@fun-mets getter)))
    (if (@empty? mets)
        (error "COULDN'T FIND GETTER")
        (let ((met (@head mets)))
          (if (@== (fun-spec met 0) owner)
              met
              (loop (@tail mets)))))))

(df find-setter (owner|<class> type zetter|<gen> => <met>)
  (rep loop ((mets (@fun-mets zetter)))
    (if (@empty? mets)
        (error "COULDN'T FIND SETTER")
        (let ((met (@head mets)))
          (if (and (@== (fun-spec met 1) owner) 
                   (@type-equal? (fun-spec met 0) type))
              met
              (loop (@tail mets)))))))

;; CREATE CLONE OF CLASS AND MARK THEM AS FORWARDED CLONE OF ORIGINAL CLASS
;; ALSO CLEAR ALL ASSOC'D GENERIC DISPATCH CACHES SO THAT THEY TRAP NEXT TIME

(df forward-class (old-class)
  (def new-class (%clone old-class))
  (@do (fun (g) (set (%fun-cache g) #f)) (%class-gens old-class))
  (set (%class-forward old-class) new-class))

(df @do-children (f x)
  (def visited '())
  (rep visit ((x x))
    (unless (@mem? visited x)
      (set visited (@add visited x))
      (f x) 
      (@do visit (%class-descendents x)))))

(df %prop (owner|<class> getter|<gen> setter|<gen> type|<type> init|<fun>)
  ;; TODO: FORWARD CONDITIONALLY
  ;; (@do-children forward-class owner)
  (def class      owner)
  (def prop       (@new <prop>         prop-owner  owner
                    prop-getter getter prop-setter setter
                    prop-type   type   prop-init   init))
  (def getter-met (find-getter owner getter))
  (def setter-met (find-setter owner type setter))
  ;; ACCESSORS STORE PROP IN THEIR ENVIRONMENT
  (set (%met-env getter-met) prop)
  (set (%met-env setter-met) prop)
  (set (%class-direct-props class)
       (@cat2 (%class-direct-props class) (@lst prop)))
  (set (%class-props class)
       (class-ordered-props class))
  ;; FLUSH ACCESSOR GENERIC CACHES CAUSE THEY HOLD POTENTIALLY 
  ;; OUTDATED PROP OFFSETS 
  (@do (fun (prop) (set (%fun-cache (%prop-getter prop)) #f))
       (%class-props class)) 
  prop)

(dl %update-instance-for-changed-class (new-object)
;;  (def old-class (%class-of new-object))
;;  (def new-class (%class-forward old-class))
;;  (def old-object (%make-object))
;;    ;; capture old values in temporary container
;;    (set (%object-values old-object) (%object-values new-object))
;;    ;; allocate new values in existing object and set new class
;;    (%install-object-values new-object (%%len (%class-props new-class)))
;;    (set (%object-class new-object) new-class)
;;    ;; copy correlated prop values from old to new
;;    (rep loop-old-props ((old-props (%class-props old-class)) (old-offset 0))
;;      (unless (@empty? old-props)
;;        (let ((old-prop   (@head old-props))
;;            (getter     (%prop-getter old-prop))
;;            (new-offset (prop-offset new-object getter)))
;;        (unless (@= new-offset $getter-not-found)
;;          (set (prop-value-at new-object new-offset) 
;;               (prop-value-at old-object old-offset))
;;          (loop-old-props (@tail old-props) (@+ old-offset 1))))))
    new-object) ;; )

(df update-instance-for-changed-class (object)
  (%update-instance-for-changed-class object))

(dv add-prop %prop)

;; PATCH EARLY CLASSES FOR MULTIPLE-INHERITANCE
(df patch-early-classes ()
  (set *early-classes* (@rev! *early-classes*))
  (@do init-class *early-classes*)
  (set %classes-ready? #t))

(patch-early-classes)

;; USED FROM INTERPRETER TO BUILD GEN'S

(df fab-gen
    (name names|<lst> specs|<lst> nary?|<log> val|<type> mets|<lst> => <gen>)
  (def g (@new <gen>
            fun-name name
            fun-sig  (@new <sig>
                        sig-names names
                        sig-specs specs
                        sig-nary? nary?
                        sig-arity (@len specs)
                        sig-val   val)
            fun-mets mets))
  (set (%gen-code g) (%met-code %dispatch))
  g)

(df gen-from-met (x|<met> => <gen>)
  (def specs (@map (fun (x) <any>) (@fun-specs x)))
  (fab-gen (fun-name x) '() specs (@fun-nary? x) <any> '()))

;; CALLED FROM COMPILER/INTERPRETER

(df %define-method (gen met|<met> => <gen>)
  (gen-add-met (or gen (gen-from-met met)) met))

(df unexec (name|<str> fun|<fun>)
  (set %*start-running-at* fun)
  (%unexec (%su name)))

(dg new (parent|<type> inits|... => <any>))

(dl %new (parent|<class> inits|<opts> => <any>)
  (def object (%object-of parent (%iu (%class-prop-len parent))))
  (def num    (@olen inits))
  (rep loop ((i 0))
    (when (@< i num)
      (def getter (@oelt inits i)) (def val (@oelt inits (@+ i 1)))
      (set (prop-value object getter) val)
      (loop (@+ i 2))))
  object)

(df @new (parent|<class> inits|... => <any>)
  (%new parent inits))

(dm new (parent|<class> inits|... => <any>)
  (%new parent inits))

;;; TYPE PROTOCOL

;;; SUBTYPE?
(dg subtype? (t1|<type> t2|<type> => <log>))

(dm subtype? (t1|<union> t2|<type> => <log>)
  (@all? (fun (t) (@subtype? t t2)) (%type-elts t1)))
(dm subtype? (t1|<type> t2|<union> => <log>)
  (@any? (fun (t) (@subtype? t1 t)) (%type-elts t2)))
;; disambiguate the case where there are two unions.
(dm subtype? (t1|<union> t2|<union> => <log>)
  (@all? (fun (t) (@subtype? t t2)) (%type-elts t1)))

(dm subtype? (t1|<class> t2|<class> => <log>)
  (@subclass? t1 t2))
(dm subtype? (t1|<singleton> t2|<class> => <log>)
  (@isa? (%type-object t1) t2))
(dm subtype? (t1|<subclass> t2|<class> => <log>)
  (@subclass? <class> t2)) ;    ????????

(dm subtype? (t1|<class> t2|<singleton> => <log>)
  #f)
(dm subtype? (t1|<singleton> t2|<singleton> => <log>)
  (@singleton-isa? (%type-object t1) t2))
(dm subtype? (t1|<subclass> t2|<singleton> => <log>)
  #f)

(dm subtype? (t1|<class> t2|<subclass> => <log>)
  (and (@== t1 <class>) (@== (%type-class t2) <class>)))
(dm subtype? (t1|<subclass> t2|<subclass> => <log>)
  (@subclass? (%type-class t1) (%type-class t2)))
(dm subtype? (t1|<singleton> t2|<subclass> => <log>)
  (and (@isa? (%type-object t1) <class>)
       (@subclass? (%type-object t1) (%type-class t2))))

;;; ISA?

(dg isa? (x t|<type> => <log>))

(dm isa? (o t|<class> => <log>)
  (@class-isa? o t))
(dm isa? (o t|<singleton> => <log>)
  (@singleton-isa? o t))
(dm isa? (o t|<subclass> => <log>)
  (and (@isa? o <class>)
       (@subclass? o (%type-class t))))
(dm isa? (o u|<union> => <log>)
  (@any? (fun (t) (@isa? o t)) (%type-elts u)))

;;; ORDER-SPECS
(dg order-specs (t1|<type> t2|<type> arg|<any>
                 => (tup order|<sym> canonical-type)))

(dm order-specs (t1|<singleton> t2|<singleton> arg
                 => (tup order|<sym> canonical-type))
  (@tup '= t1))

(dm order-specs (t1|<singleton> t2|<type> arg
                 => (tup order|<sym> canonical-type))
  (@tup '< t1))

(dm order-specs (t1|<subclass> t2|<subclass> arg
                 => (tup order|<sym> canonical-type))
  (def c1 (%type-class t1))
  (def c2 (%type-class t2))
  (cond
    ((@== c1 c2)         (@tup '= t1))
    ((@class< c1 c2 arg) (@tup '< t1))
    (#t                  (@tup '> t2))))

(dm order-specs (t1|<subclass> t2|<class> arg
                 => (tup order|<sym> canonical-type))
  (@tup (if (@subtype? <class> t2) ;; TODO: THIS SEEMS WRONG
            (if (@== t1 <any>)
                (order-specs <class> t2 arg)
                '<)
            '<>)
        t1))

(dm order-specs (t1|<class> t2|<subclass> arg
                 => (tup order|<sym> canonical-type))
  (@tup (if (@subtype? <class> t1) ;; TODO: THIS SEEMS WRONG
            (if (@== t2 <any>)
                (order-specs t1 <class> arg)
                '>)
            '<>)
        t2))

(dm order-specs (t1|<class> t2|<class> arg
                 => (tup order|<sym> canonical-type))
  (@order-specs-class t1 t2 arg))

(dm order-specs (t1|<type> t2|<type> arg
                 => (tup order|<sym> canonical-type))
  (if (@subtype? t1 t2)
      (@tup (if (@subtype? t2 t1) '= '<) t1)
      (if (@subtype? t2 t1)
          (@tup '>  t2)
          (@tup '<> <any>))))

;;; MAY-ISA?: class contains => (some? all?) instances of type
(dg may-isa? (c|<class> t|<type> => (tup <log> <log>)))

(dm may-isa? (c|<class> t|<class> => (tup <log> <log>))
  (if (@subclass? c t) (@tup #t #t) (@tup #f #f)))
(dm may-isa? (c|<class> t|<singleton> => (tup <log> <log>))
  (@tup (@may-isa? (%class-of (%type-object t)) c) #f))
(dm may-isa? (c|<class> t|<subclass> => (tup <log> <log>))
  (def class? (@subtype? c <class>))
  (@tup class? (and class? (@== (%type-class c) <any>))))
(dm may-isa? (c|<class> t|<union> => (tup <log> <log>))
  (rep loop ((some? #f) (all? #f) (elts (%type-elts t)))
    (if (@empty? elts)
        (@tup some? all?)
        (let ((elt-some-all? (@may-isa? c (@head elts)))
              (elt-some?     (@telt elt-some-all? 0))
              (elt-all?      (@telt elt-some-all? 1)))
          (loop (or elt-some? some?) (or elt-all? all?) (@tail elts))))))

;;; 
;;; 14. MACROS
;;; 

(dv *boot-macro-module-names* '())
(dv *boot-macro-names*        '())
(dv *boot-macro-expanders*    '())
(dv *macros-ok?*              #f)  ;; ENOUGH OF WORLD BOOTED TO DEFINE MACROS?

(dl %macro (modname name expander)
  (if *macros-ok?*
      (%%macro modname name expander #f) ;; DEFINED IN AST
      (seq ;; REMEMBER NAMES/EXPANDERS FOR LATER INSTALLATION
        (set *boot-macro-module-names*
             (@pair modname *boot-macro-module-names*))
        (set *boot-macro-names*     (@pair name     *boot-macro-names*))
        (set *boot-macro-expanders* (@pair expander *boot-macro-expanders*)))))

;;;
;;; 15. EXPORTS
;;;

;; Some functions are called directly from prt.c.  For now, we generate
;; artificial free bindings for these symbols in the boot module--and
;; export them--so that other modules will define them under the
;; correct C names.  Please feel free to redesign this if you wish.
;; TODO - It might be worth dumping (mangle-runtime-name ...) in
;; g2c and using this mechanism instead.
(dss (force-names-into-boot-module ,@names)
  (if (empty? names)
      #f
      `(seq (if #f ,(head names))
            (export ,(head names))
            (force-names-into-boot-module ,@(tail names)))))

(force-names-into-boot-module
  error
  unknown-function-error
  file-opening-error
  type-error
  wrong-number-arguments-error
  keyboard-interrupt
  tup
  %with-monitor
)

;; Forward references.
;; TODO - These would normally be defined using need-implementation, but we
;; haven't defined that yet.
(export
  %%macro
  error
  incongruent-method-error

  ;; Required for the incongruent-method-error restart.
  <replace-generic-restart>
  <simple-handler-info>
  handler-info-message
  handler-info-arguments
  lst)

;; Compiler magic.
(export
  use
  use/export
  export
  mif
  macro-expand
  quasiquote
  dl
  ct
  ct-also
  dp
  fab-class
  try
  fin
  esc
  rep
  loc
  let
  def
  bound?
  fun
  df
  dg
  dm
  dss
  ds
  dv
  dc
  set
  quote
  %raw
  seq
  if)

;; Primitives used in other modules.
(export
  %app-args
  %app-filename
  %bb
  %binding-name
  %build-runtime-modules %process-module
  %c<
  %c=
  %ready?
  %close-in-port
  %close-out-port
  %create-directory
  %current-in-port
  %current-out-port
  %do-stack-frames
  %eof-object
  %eq?
  %f*
  %f+
  %f-
  %f/
  %f<
  %f=
  %fi2f
  %file-exists?
  %file-mtime
  %file-type
  %flo-bits
  %fpow %flog %fsqrt 
  %fsin %fcos %ftan 
  %fasin %facos %fatan %fatan2
  %fsinh %fcosh %ftanh
  %force-out
  %ft
  %i!
  %i&
  %i*
  %i+
  %i-
  %i<
  %i<<
  %i<<<
  %i=
  %i>>
  %i>>>
  %i?
  %i^
  %im
  %invoke-debugger
  %it/
  %iv
  %loc-val
  %loc-val-setter
  %next-methods
  %open-in-file
  %open-out-file
  %os-val
  %os-val-setter
  %os-name
  %pair
  %peek
  %get
  %put
  %puts
  %%sym
  ;;; FOR DECISION TREE CODE
  %gen-refs 
  %gen-code %gen-code-setter
  %gen-src
  %met-code
  %fun-reg
  %unlink-stack
  @isa?
)

;; Regular exports.
(export
  <any>
  <mag>
  <chr>
  <col> <col.> <col!>
  <flat>
  <flo>
  <fun>
  <gen>
  <int>
  <loc>
  <log>
  <lst>
  <met>
  <num>
  <opts>
  <type>
  <class>
  <subclass>
  <singleton>
  <union>
  <seq> <seq.> <seq!>
  <sig>
  <prop>
  <str>
  <sym>
  <tup>
  <rep>

;; tagged structures
  %cb
  %cu
  %fb
  %fu
  %ib
  %iu
  %lb
  %lu
  $max-int
  $min-int
  %untag

;; repeated structures
  %sb
  %selt
  %selt-setter
  %slen
  %snul
  %str
  %su
  %tup
  %telt
  %telt-setter
  %tlen
  %tnul
  %rep
  %relt
  %relt-setter
  %rlen
  %rnul

  add-prop
  %allocate-stack
  *boot-macro-expanders*        ;;var
  *boot-macro-names*            ;;var
  *boot-macro-module-names*
  %define-method                
  fab-gen
  fab-sym
  find-getter
  find-setter
  fun-arity
  fun-name
  fun-name-setter
  fun-names
  fun-nary?
  fun-mets
  gen-refs gen-refs-setter
  gen-src gen-src-setter
  fun-sig-setter
  fun-specs
  fun-val
  gen-add-met
  head
  head-setter
  isa?
  new
  *macros-ok?*
  met-app?
  nil
  not
  nul
  subtype?
  may-isa?
  object-class
  type-object
  type-class
  type-elts
  class-name
  class-parents
  class-descendents
  class-direct-props
  class-ancestors
  class-props
  object-parents
  object-props
  *restarts-ok?*
  %prop %prop-unbound-error
  prop-owner
  prop-type
  prop-init
  prop-value        ;; TODO: remove these when they can be called directly 
  prop-value-setter ;; TODO: w/o being exported
  prop-bound?       ;; TODO: w/o being exported
  prop-getter
  prop-setter
  sig-names
  sig-specs
  sig-nary?
  sig-arity
  sig-val
  sig-unification-vars
  ord-app-mets
  sym-name
  %symbols
  tail
  tail-setter
  unexec
  @lst
  @len
  @all2?
  @oelt
  @any?
  @olen
  @+
  @<
  @==
  %raw-call
  %check-call-types
  %loc-off %loc-off-setter
  %sp-reg-setter %sp-reg
  *report-prop-unbound-errors?*
)
