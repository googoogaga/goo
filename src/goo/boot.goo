;;;; Copyright (c) 2001 Jonathan Bachrach

;;; GOALS
;;;
;;; SIMPLEST POSSIBLE
;;; DYNAMIC ORDER FORM BY FORM
;;; MINIMIZE OBJECT SYSTEM BOOT OBFUSCATION
;;;
;;; TODO
;;; 
;;; o RENAME LOW PRIMITIVES TO HAVE TWO %%'s
;;; o INVENT NAMING CONVENTION FOR COMPILE TIME THINGS SAY &...?
;;; 

;; Define the primitives whose code is in prt.c
(dss (%define-primitives)
  `(seq ,@(map (fun (name) `(dp ,name)) primitive-names)))

(ct (dv primitive-names
      '(
        %eq? %bb
        %i= %i< %i+ %i- %i* %im %ir %it/ %iv %i^ %i& %i! %i?
        %i<< %i>> %i<<< %i>>>
        %fi2f %f= %f< %f+ %f* %f- %f/ %ft %ft/ %ff %fc %flo-bits
        %c= %c<
        %create-directory
        %current-output-port %current-input-port
        %open-input-file %open-output-file 
        %close-output-port %close-input-port
        %write-char %write-string %file-mtime
        %file-type %file-exists?
        %force-output %char-ready?
        %read-char %newline %eof-object %eof-object
        %peek-char %char-ready
        %object-class %object-class-setter
        %raw-alloc %object-of %clone
        %slot-elt %slot-elt-setter %slot-dat-at
        %elt %elt-setter
        %slen %selt %selt-setter %%sfab %su %sb
        %vlen %velt %velt-setter %%vfab %vu
        %fab-code-refs %code-ref
        %app-filename %app-args
        %locative-value %locative-value-setter %invoke-debugger
        %os-name %os-binding-value %os-binding-value-setter        
        %break %binding-name %fun-reg
        %trace-on %trace-off
        %%apply %%mep-apply %next-methods %fapply
        %do-stack-frames 
        %unexec
        %build-runtime-modules %process-module
        %loc-off %loc-off-setter %raw-call %check-call-types
        %sp-reg %sp-reg-setter %fp-reg %fp-reg-setter %unlink-stack
        )
))

(%define-primitives)

;; Early definitions, so we at least know false != true
(dv %false (%raw 0)) 
(dv %true (%raw 1))

(dv %*used-symbols-too-early* (%raw 0))

;;; Temporary, compile-time-only macros.  These are used by this file only--
;;; we never export them.  The real definitions live in macros.proto.

(dss (unless ,test ,@body)
  `(if (not ,test) (seq ,@body)))

(dss (when ,test ,@body)
  `(if ,test (seq ,@body)))

(dss (or ,@rest)
  (mif ((,x ,@rest) rest)
       (mif (() rest)
	    x
	    `(let ((tmp ,x))
	       (if tmp tmp (or ,@rest))))
       #f))

(dss (and ,@rest)
  (mif ((,x ,@rest) rest)
       (mif (() rest)
	    x
	    `(let ((tmp ,x))
	       (if tmp (and ,@rest) #f)))
       #t))

(dss (case ,@cases)
  (if (empty? cases)
      #f
      (mif ((,cond ,@body) (head cases))
	   `(if ,cond
		(seq ,@body)
		(case ,@(tail cases)))
	   ;; TODO: NEED SYNTAX ERROR CONDITIONS
	   (error "CASE: SYNTAX ERROR BAD CASE" (head cases)))))

;;;
;;; BOOT OBJECTS
;;;

;; ALL PROTO'S NEEDED FOR BOOT ARE DEFINED HERE
;; THEY ARE DEFINED AS THEY WOULD BE OUTSIDE BOOT

(ct (df %boot-defs ()
      '((dc <any>    (<any>))
	(dv nul      (isa <any>))
	(dv nul-slot (isa <any>))
	(dc <log>    (<any>))
	(dv %true    (isa <log>))
	(dv %false   (isa <log>))
	(dc <chr> (<any>))
	(dc <num> (<any>))
	(dc <int> (<num>))
	(dc <flo> (<num>))
	(dc <loc> (<any>))
	(dc <col> (<any>))
	(dc <seq> (<col>))
	(dc <lst> (<seq>))
	(dv nil (isa <lst>))
	  (slot <lst> (head <any>) nil)
	  (slot <lst> (tail <lst>) nil)
	(dc <flat> (<seq>))
	(dc <vec> (<flat>))
	(dc <str> (<flat>))
	(dc <sym> (<any>))
	  (slot <sym> (sym-name <str>))
	(dc <type> (<any>))
	(dc <class> (<type>))
	  (slot <class> (class-slot-len <int>)        0)
	  (slot <class> (class-name <sym>))
	  (slot <class> (class-direct-parents <lst>)  nil)
	  (slot <class> (class-direct-slots <lst>)    nil)
	  (slot <class> (class-parents <lst>)         nil)
	  (slot <class> (class-slots <lst>)           nil)
	  (slot <class> (class-direct-children <lst>) nil)
	  ;; ULTIMATELY NEED GENS TO BE FLUSHED DURING CLASS REDEF
	  ;; KEEP BOTH GENS/METS CAUSE NO MET->GEN MAP
	  ;; WANT TO PRUNE OUT UNNECESSARY GENS BASED ON ACTUAL METS
	  (slot <class> (class-gens <lst>)            nil)
	  (slot <class> (class-mets <lst>)            nil)
	  (slot <class> (class-forward <any>)         #f)
	(dc <singleton> (<type>))
          (slot <singleton> (type-object <any>))
	(dc <subclass> (<type>))
          (slot <subclass>  (type-class <class>))
	(dc <union> (<type>))
          (slot <union>     (type-elts <lst>)           nil)
	(dc <slot> (<any>))
	  (slot <slot> (slot-owner <any>))
	  (slot <slot> (slot-getter <fun>))
	  (slot <slot> (slot-setter <fun>))
	  (slot <slot> (slot-type  <any>))
	  (slot <slot> (slot-init  <fun>) (fun (x) nul-slot))
	(dc <gen-cache> (<any>))
	  (slot <gen-cache> (gen-cache-missable? <log>) #f)
	  (slot <gen-cache> (gen-cache-arg-pos <int>) 0)
	  (slot <gen-cache> (gen-cache-singletons <lst>) nil)
	  (slot <gen-cache> (gen-cache-classes <lst>)    nil)
	(dc <sig> (<any>))
	  (slot <sig> (sig-names <lst>) nil)
	  (slot <sig> (sig-specs <lst>) nil)
	  (slot <sig> (sig-nary? <log>) %false)
	  (slot <sig> (sig-arity <int>) 0)
	  (slot <sig> (sig-value <any>) <any>)
	  (slot <sig> (sig-unification-vars <lst>) nil)
	(dc <fun> (<any>))
	  (slot <fun> (fun-code <any>)  %false)
	  (slot <fun> (fun-name <any>)  %false)
	  (slot <fun> (fun-sig <sig>))
	(dc <met> (<fun>))
	  (slot <met> (fun-env <any>)   %false)
	  (slot <met> (fun-refs <any>)  %false)
	  (slot <met> (fun-src <any>)   %false)
	(dc <gen> (<fun>))
	  (slot <gen> (fun-mets <lst>)  nil)
	  (slot <gen> (fun-cache <any>) %false)
    (dc <opts> (<flat>))
      (slot <opts> (opts-location <loc>) 0)
      (slot <opts> (opts-count <int>) 0)
    (dc <opts-vec> (<opts>))
      (slot <opts-vec> (opts-vec-storage <vec>) nul)
)))

;; RETURN CLASS DEFS FROM BOOT DEFS

(ct (df %map-boot-classes (f)
      (rep loop ((res '()) (defs (%boot-defs)))
        (if (empty? defs)
	    (rev! res)
	    (loop (mif ((dc ,name (,parent)) (head defs))
                       (pair (f name parent) res)
                       res)
		  (tail defs))))))

;; RETURN OBJECTS DEFS FROM BOOT DEFS

(ct (df %map-boot-objects (f)
      (rep loop ((res '()) (defs (%boot-defs)))
        (if (empty? defs)
	    (rev! res)
	    (loop (mif ((dv ,name (isa ,parent)) (head defs))
		       (pair (f name parent) res)
                       res)
		  (tail defs))))))

;; RETURN SLOT DEFS FROM BOOT DEFS

(ct (df %map-boot-slots (f)
      (rep loop ((res '()) (defs (%boot-defs)))
        (if (empty? defs)
	    (rev! res)
	    (loop (mif ((slot ,owner (,name ,type) ,@maybe-init) (head defs))
		       (let ((init (if (empty? maybe-init) 
	                               'nul-slot 
	                               (head maybe-init))))
			 (pair (f owner name type init) res)) 
		       res)
		  (tail defs))))))

;;;
;;; 1. CONSTRUCTION MACHINERY FOR BUILDING EARLY OBJECTS
;;;

(dp %allocate-stack (num)
  (let ((ret (%sp-reg)))
    (set (%sp-reg) (%i+ (%sp-reg) (%i* (%raw 4) num)))
    ret))

;; STRUCTURES ARE OBJECT TEMPLATES WITH 
;;   PRIMITIVES FOR ACCESSORS AND 
;;   A PRIMITIVE REQUIRED ONLY CONSTRUCTOR

;; DEFINE ACCESSORS NAMED SLOT-NAMES AT INCREASING OFFSETS

(dss (%define-structure-accessors ,@slot-names)
  (loc ((getter (name offset) 
          `(dp ,(make-sym "%" name) (x)
             (%slot-elt x (%raw ,offset))))
        (setter (name offset)
          `(dp ,(make-sym "%" name "-setter") (z x)
             (set (%slot-elt x (%raw ,offset)) z))))
    (rep loop ((res '()) (i 0) (names slot-names))
      (if (== names '())
          `(seq ,@(rev! res))
          (let ((name (head names)))
            (loop (pair (getter name i) (pair (setter name i) res))
                  (+ i 1) (tail names)))))))

;; DEFINE STRUCTURE BASE WITH PREFIX FOR CONSTRUCTOR NAME

(dss (%define-structure ,prefix ,proto-base-name ,@slot-names)
  (loc ((constructor (name inits)
	  (let ((proto-name (make-sym "<" name ">")))
	    `(dp ,(make-sym prefix name) (,@slot-names) 
	       (let ((proto (%object-of ,proto-name (%raw ,(len slot-names)))))
		 ,@inits
		 proto)))))
    (rep loop ((inits '()) (i 0) (names slot-names))
      (if (== names '())
	  `(seq (%define-structure-accessors ,@slot-names)
		,(constructor proto-base-name inits))
	  (let ((name (head names)))
	    (loop (pair `(set (%slot-elt proto (%raw ,i)) ,name) inits)
		  (+ i 1) (tail names)))))))

;;;
;;; 2. SETUP EARLY CLASS
;;;

(%define-structure % class
 class-slot-len class-name 
 class-direct-parents class-direct-slots
 class-parents class-slots class-direct-children 
 class-gens class-mets class-forward)

(%define-structure % singleton type-object)
(%define-structure % subclass  type-class)
(%define-structure % union     type-elts)

(dv <class> (%object-of (%raw 0) (%raw 10)))

;;;
;;; 3. SETUP EARLY OBJECTS
;;;

;;; PLACE HOLDERS FOR EARLY OBJECTS

(dv <lst>    (%object-of <class> (%raw 10))) ;; PLACE HOLDER
(dv nil      (%object-of <lst> (%raw 2)))    ;; AT LEAST GET SIZE RIGHT
(dv one-nil  nil)                            ;; REMEMBER ORIGINAL NIL

;;;
;;; 4. SETUP EARLY CLASSES
;;;

;;; BUILD CLASS SHELLS POINTING TO INCOMPLETE <CLASS>

(dss (%class-shells)
  `(seq ,@(%map-boot-classes
	    (fun (name parent)
              `(dv ,name (%class nil nil nil nil nil nil nil nil nil nil))))))

(%class-shells)

;;; INITIALIZE CLASSES TO BE INSTANCES OF NOW REAL CLASS

(dss (%reparent-class-shells)
  `(seq ,@(%map-boot-classes
	    (fun (name parent)
              `(set (%object-class ,name) <class>)))))

(%reparent-class-shells)

;;;
;;; 5. SETUP EARLY OBJECTS
;;;

;;; TODO: NEED SIZES TO BUILD OBJECTS CORRECTLY
;;; TODO: COULD DELAY UNTIL AFTER SLOTS

(set (%object-class nil) <lst>)

;;; BUILD BASIC OBJECT HOLDERS

(dss (%object-shells)
  `(seq ,@(%map-boot-objects 
	    (fun (name parent)
              `(dv ,name (%object-of ,parent (%raw 0)))))))

(%object-shells)

;;;
;;; 6. SETUP LIST BASICS
;;;

;;; LST BASICS

(%define-structure % lst head tail)

(dp %pair (head tail) (%lst head tail))

(dp %empty? (x) (%bb (%eq? x nil)))

(dp %%len (x) 
  (if (%empty? x) (%raw 0) (%i+ (%%len (%tail x)) (%raw 1))))

;;; INITIALIZE NIL

(set nil         one-nil)
(set (%head nil) nil)
(set (%tail nil) nil)

;;; MET BASICS

(%define-structure % sig 
   sig-names sig-specs sig-nary? sig-arity sig-value sig-unification-vars)

(%define-structure % met 
   met-code met-name met-sig met-env 
   met-refs met-src
   )

(dv %met-slot-len (%raw 4))

;; NOW FALSE AND TRUE HAVE THEIR PERMANENT VALUES.

(dv %symbols-ready?     #f)  ;; READY TO BUILD SYMBOLS?
(dv %*start-running-at* nil)

;;; 
;;; 8. TAGGED OBJECTS
;;; 

;; TAGGED OBJECTS ARE IMMEDIATE OBJECTS WHOSE TYPE AND DATA
;; ARE ENCODED IN ADDRESS
;; USES TWO TAG BITS WITH ADDRESSES HAVING TAG ZERO

(dv $direct-object-class (%raw-alloc (%raw 4)))

(dss ($tag-msk) `(%raw 3))
(dss ($tag-len) `(%raw 2))

(dp %tag-bits (x) (%i& x ($tag-msk)))

(dp %tag (x t) (%iv (%i<< x ($tag-len)) t))

(dp %untag (x) (%i>> x ($tag-len)))

(dss ($adr-tag) `(%raw 0))

(dp %tag-into (x t) (%tag (%untag x) t))

(dp %untag-into (x) (%tag (%untag x) ($adr-tag)))

(dp %indirect-object? (x) (%i= (%tag-bits x) ($adr-tag)))

(dp %class-of (x)
  (let ((tag (%tag-bits x)))
    (if (%bb (%i= tag ($adr-tag)))
        (%object-class x)
        (%elt $direct-object-class tag))))

;; DEFINE EARLY TAGGED PROTO 
;;   WHERE CODE IS ABBREVIATION PREFIX FOR OPS
;;   DEFINES TAG/FAB AND UNTAG OPS
;;   DEFINES TAG2CLASS ENTRY FOR MAP

(dss (%define-tagged-structure ,name ,ptag ,puntag ,code ,tag)
  (let ((class-name (make-sym "<" name ">"))
	(fab-name   (make-sym "%" name))
	(tag-name   (make-sym "%" code "b"))
	(untag-name (make-sym "%" code "u")))
    `(seq (dp ,tag-name (x) (,ptag x (%raw ,tag)))
	  (dp ,fab-name (x) (,tag-name x))
	  (dp ,untag-name (x) (,puntag x))
	  (set (%elt $direct-object-class (%raw ,tag)) ,class-name))))

(%define-tagged-structure int %tag %untag           i 1) ;; INTEGERS

(%define-tagged-structure chr %tag %untag           c 2) ;; CHARACTERS

(%define-tagged-structure loc %tag-into %untag-into l 3) ;; LOCATIVES

(dv $num-int-bits (%ib (%i- (%iu 32) ($tag-len))))
(dv $max-int 
  (%ib (%i- (%i<< (%iu 1) (%i- (%iu $num-int-bits) (%iu 1))) (%iu 1))))
(dv $min-int
  (%ib (%i<< (%iu 1) (%i- (%iu $num-int-bits) (%iu 1)))))

;;; 
;;;  9. SETUP REPEATED OBJECTS
;;; 

;; DEF STRUCT'S WITH INDEXED ELEMENTS W/ DATA STORED IN DATA SLOT
;;   DEFINING CONSTRUCTORS,ACCESSORS,LEN,BOX/UNBOX'ERS(FOR FFI),

(dss (%define-repeated-structure ,name ,elt ,code ,init)
  (let ((class-name (make-sym "<"  name ">"))
	(nul        (make-sym "%"  code "nul"))
	(fab        (make-sym "%"  name))
	(fab!       (make-sym "%"  name "!"))
	(raw-fab    (make-sym "%%" code "fab")))
    `(seq (dp ,fab! (len) (,raw-fab len ,init))
	  (dv ,nul (,fab! (%raw 0)))
	  (dp ,fab (len) (if (%bb (%i= len (%raw 0))) ,nul (,fab! len))))))

(%define-repeated-structure str <chr> s (%cu #\Space))

(%define-repeated-structure vec <any> v nul) 

;; can't use rep yet because symbols aren't real
(dp %str-eq?-loop (s1 s2 len i)
  (or (%bb (%i= i len))
      (let ((c1 (%selt s1 i)) (c2 (%selt s2 i)))
        (and (%bb (%c= c1 c2))
             (%str-eq?-loop s1 s2 len (%i+ i (%raw 1)))))))

(dp %str-eq? (s1 s2)
  (let ((len (%slen s1)))
    (and (%bb (%i= len (%slen s2)))
         (%str-eq?-loop s1 s2 len (%raw 0)))))

;;;
;;; 7. SETUP HIERARCHY
;;;

;; COMPUTE ALL PARENTS FROM DIRECT PARENTS ASSUMING SINGLE INHERITANCE

(dp %compute-parents (parent)
  (if (%bb (%eq? parent <any>))
      (%pair <any> nil)
      (%pair parent
             (%compute-parents (%head (%class-direct-parents parent))))))

;; DEFINE CHILD / PARENT RELATIONSHIP

(dp %define-parent (class direct-parent)
  (set (%class-slot-len class) 0)    ;; NOW INT'S ARE DEFINED
  (set (%class-forward class)  #f)   ;; NOW #F    IS  DEFINED
  (set (%class-direct-parents class) 
       (%pair direct-parent nil))
  (set (%class-parents class) 
       (%pair class (%compute-parents direct-parent)))
  (set (%class-direct-children direct-parent)
       (%pair class (%class-direct-children direct-parent))))

;; DEFINES SINGLE INHERITANCE HIERARCHY FROM TOP TO BOTTOM

(dss (%define-hierarchy)
  `(seq ,@(%map-boot-classes
	    (fun (name parent) `(%define-parent ,name ,parent)))))

(%define-hierarchy)

;; PATCH <ANY>'S PARENTS

(set (%class-parents <any>) (%pair <any> nil))

;;;
;;; 10. SETUP SYMBOLS
;;;

;; Get symbol fab up ASAP so we don't have to patch the names of
;; a bunch of objects.

(dp %%sym (raw-str)      ;; Called in code generated by compiler
  (if %symbols-ready?
     (fab-sym (%sb raw-str))
     (set %*used-symbols-too-early* #t)
     #f))

(%define-structure % sym sym-nam)

(dv %symbols nil)

;; EARLY VERSION (PRE TAB) OF SYM CONSING USING LST SET
(if (%bb (%eq? %*used-symbols-too-early* #t))
    (%write-string (%current-output-port) (%su
	"Warning: symbols were created in the boot image before the symbol-creation was setup. (Probably from a df or rep)\n")))


;; this first version doesn't have proper symbols, but it works..
(dv fab-sym
  (fun (name)
    (rep lookup ((s %symbols))
      (if (%empty? s)
          (let ((sym (%sym name)))
            (set %symbols (%pair sym %symbols))
            sym)
          (let ((sym (%head s)))
            (if (%str-eq? (%sym-nam sym) name)
                sym
                (lookup (%tail s))))))))

(set %symbols-ready? #t) ;; READY TO CONS SYMBOLS

;; do the same thing, this time the symbols will be filled in
(df fab-sym (name)
  (rep lookup ((s %symbols))
    (if (%empty? s)
        (let ((sym (%sym name)))
          (set %symbols (%pair sym %symbols))
          sym)
        (let ((sym (%head s)))
          (if (%str-eq? (%sym-nam sym) name)
              sym
              (lookup (%tail s)))))))

;; NEED THIS TO BUILD METS -- COMPUTED FOR REAL BELOW
(set (%class-slot-len <met>) (%ib %met-slot-len)) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; !!! Below here we can use functions !!! ;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; MORE LST UTILITIES BUT NOW USING LOCAL METHODS

(dp %rev! (c)
  (rep loop ((l c) (r '()))
    (if (%empty? l)
	r
	(let ((t (%tail l)))
	  (set (%tail l) r)
	  (loop t l)))))

(dp %cat2 (x y) 
  (rep colx ((lx nil) (x x))
    (if (%empty? x)
	(rep coly ((lxy lx) (y y))
	  (if (%empty? y)
	      (%rev! lxy)
	      (coly (%pair (%head y) lxy) (%tail y))))
	(colx (%pair (%head x) lx) (%tail x)))))


;;; 
;;; 11. BOXED OBJECTS
;;; 

(dss (%define-boxed-structure ,name ,code)
  (let ((class-name (make-sym "<" name ">"))
	(dat-name   (make-sym name "-dat"))
	(fab-name   (make-sym "%" name))
	(box-name   (make-sym "%" code "b"))
	(unbox-name (make-sym "%" code "u")))
    `(seq (%define-structure % ,name ,dat-name)
	  (dp ,box-name (x) (,fab-name x))
	  (dp ,unbox-name (x) (%slot-elt x (%raw 0)))
	  )))

(%define-boxed-structure flo f)

;; (%define-boxed-structure chr c)

;; (%define-boxed-structure int i)

;; (%define-boxed-structure loc l)

;;; 5.5. Make optional arg stuff
(%define-structure % opts opts-location opts-count)
(%define-structure % opts-vec opts-vec-location opts-vec-count opts-vec-vec)

;;;
;;; 12. MAKE SLOTS AND ACCESSORS
;;; 

;; DEF SLOT'S

(%define-structure %% slot
  slot-owner slot-getter slot-setter slot-type slot-init)

;; GENERIC DISPATCH CACHES 
;;   USED IN HIERARCHY DECISION TREE
;;   MAP KEYS TO SUBTREES WHERE KEYS ARE EITHER OBJECTS OR CLASS
;;   AND SUBTREES ARE EITHER OTHER CACHES OR METHODS OR SLOT OFFSETS

(%define-structure % gen-cache 
   gen-cache-missable? gen-cache-arg-pos gen-cache-singletons gen-cache-classes)

(dv $gen-cache-singletons-offset 2) ;; TODO: USED IN CACHE UPDATE
(dv $gen-cache-classes-offset    3)

;;; DEF GENERIC'S
 
(%define-structure % gen 
   gen-code gen-name gen-sig gen-mets fun-cache)

(df %slot-offset (owner getter)
  (rep loop ((i (%raw 0)) (slots (%class-slots (%object-class owner))))
    (if (%empty? slots)
	(%iu -1)
	(let ((slot (%head slots)))
	  (if (%bb (%eq? (%slot-getter slot) getter))
	      i
	      (loop (%i+ i (%raw 1)) (%tail slots)))))))

;; &LISTIFY CONSTRUCTS CODE THAT BUILDS A LIST OF GIVEN ARGS WITH CALLS TO %PAIR

(ct (df &listify (args)
      (if (empty? args)
	  'nil
	  `(%pair ,(head args) ,(&listify (tail args))))))

;; EARLY DISPATCH ERRORS OUT

(df %early-dispatch ((args ...))
  (let ((gen (%fun-reg)))
    (%write-string
     (%current-output-port)
     (%su "ERROR: Generic function dispatch called before it existed."))
    ;; die (is there a better way?)
    ((%raw 0))))

(df %add-met (gen met)
  (set (%gen-mets gen) (%pair met (%gen-mets gen))))

;; DEFINE EARLY GENERIC METHOD FOR ACCESSORS

(dss (%define-accessor ,name (,@sig) ,@body)
  (let ((params  (sexpr-signature-parameters sig))
	(specs   (&listify (map (always '<any>) params))))
    `(seq (dv ,name 
	    (%gen %early-dispatch ',name 
	          (%sig '() ,specs #f ,(len params) <any> '()) '() #f))
	  (let ((accessor (fun (,@sig) ,@body)))
	    (%add-met ,name accessor)
        (set (%met-name accessor) ,name)
	    accessor))))

(dss (%define-getter ,name ,owner ,type)
  `(%define-accessor ,name ((x ,owner))
      (%slot-elt x (%slot-offset ,owner ,name))))

(dss (%define-setter ,name ,owner ,type)
  `(%define-accessor ,(make-sym name "-setter") ((z ,type) (x ,owner))
     (set (%slot-elt x (%slot-offset ,owner ,name)) z)))

;; EARLY ADD-SLOT JUST ADDS SLOT TO DIRECT-SLOTS

(df %add-slot (class slot)
  (set (%class-direct-slots class)
       (%pair slot (%class-direct-slots class))))

;; DEF GETTER/SETTER/SLOTS FOR ALL BOOT PROTO SLOTS
;; N.B. SLOT METHODS CLOSE OVER SLOT

(dss (%define-slots)
  `(seq ,@(%map-boot-slots 
	    (fun (owner name type init) 
	      `(let ((getter (%define-getter ,name ,owner ,type))
		     (setter (%define-setter ,name ,owner ,type))
		     ;; TODO: X FROM OWNER VAR
		     (slot   (%%slot ,owner ,name ,(make-sym name "-setter") 
                                     ,type (fun (x) ,init))))
		 (set (%met-env getter) slot)
		 (set (%met-env setter) slot)
		 (%add-slot ,owner slot))))))

(%define-slots)

;;;
;;; 7. FINALIZE SLOTS
;;;

;; NEED TO SET ALL SLOTS CLASS SLOT

(df %collect-direct-slots (class)
  (let ((parent (%head (%class-direct-parents class))))
    (%cat2 (%class-slots parent) (%class-direct-slots class))))

(df %finalize-slots! (name class)
  (set (%class-name class)         name)
  (set (%class-direct-slots class) (%rev! (%class-direct-slots class)))
  (set (%class-slots class)        (%collect-direct-slots class))
  (set (%class-slot-len class)     (%ib (%%len (%class-slots class))))
  class)

(dss (%finalize-slots)
  `(seq ,@(%map-boot-classes
           (fun (name parent) `(%finalize-slots! ',name ,name)))))

(%finalize-slots)

;;;
;;; 11. FUNCTION PREP
;;; 

;; NEED TO DEF A SLEW OF MONOVARIANT FUN'S 
;;   PRE GENERICS AND IN ORDER TO AVOID CIRCULARITIES
;;   USE PRIMITIVES FOR SPEED FOR NOW

(dp @head ((x <lst>) => <any>) (%head x))

(dp @head-setter (z (x <lst>)) (set (%head x) z))

(dp @tail ((x <lst>) => <lst>) (%tail x))

(dp @tail-setter ((z <lst>) (x <lst>)) (set (%tail x) z))

(dp @= ((x <int>) (y <int>) => <log>)
;; optimization based on knowing the tag bits for two ints are always the same
  (%bb (%i= x y)))
;;  (%bb (%i= (%iu x) (%iu y))))

(dp @< ((x <int>) (y <int>) => <log>)
  (%bb (%i< (%iu x) (%iu y))))

(dp @+ ((x <int>) (y <int>) => <int>)
  (%ib (%i+ (%iu x) (%iu y))))

(dp @== ((x <any>) (y <any>) => <log>) (%bb (%eq? x y)))

(df @@== ((x <any>) (y <any>) => <log>) (%bb (%eq? x y)))

(df not ((x <any>) => <log>) (%bb (%eq? x #f)))

(dp @not ((x <any>) => <log>) (%bb (%eq? x #f)))

(dp @empty? ((x <lst>) => <log>) (%empty? x))

(df @@empty? ((x <lst>) => <log>) (%empty? x))

(df @rev! ((x <lst>) => <lst>) (%rev! x))

(dp @len ((x <lst>) => <int>) (%ib (%%len x)))

(dp @oelt ((x <opts>) (i <int>)) (%loc-off (%opts-location x) (%i- (%raw 0) (%iu i))))
(dp @oelt-setter (z (x <opts>) (i <int>)) (set (%loc-off (%opts-location x) (%i- (%raw 0) (%iu i))) z))
(dp @olen ((x <opts>) => <int>) (%opts-count x))

(df @all? ((test <fun>) (c <lst>) => <log>)
  (rep fnd ((p c))
    (if (@empty? p) #t (if (test (@head p)) (fnd (@tail p)) #f))))

(df @all2? ((test <fun>) (x <lst>) (y <lst>) => <log>)
  (rep fnd ((px x) (py y))
    (if (@empty? px) 
	(@empty? py)
	(if (@empty? py)
	    #f
	    (if (test (@head px) (@head py)) 
		(fnd (@tail px) (@tail py))
		#f)))))

(df @elt ((x <lst>) (key <int>) => <any>)
  (rep fnd (((count <int>) 0) ((x <lst>) x))
    (if (@== x '())
        nul
        (if (@= count key) (@head x) (fnd (@+ count 1) (@tail x))))))

(df @fill ((x <lst>) (f <fun>) => <lst>)
  (rep loop ((p x))
    (if (@empty? p) x (seq (set (@head p) f) (loop (@tail p))))))

(df @any? ((test <fun>) (c <lst>) => <any>) ;; TODO: => <log>
  (rep fnd ((p c))
    (if (@empty? p) #f (or (test (@head p)) (fnd (@tail p))))))

(dp @pair ((h <any>) (t <lst>) => <lst>) (isa <lst> (set head h) (set tail t)))

(dp @add ((c <lst>) (e <any>) => <lst>) (@pair e c))

(dp @add-new ((c <lst>) (e <any>) => <lst>) 
  (if (@mem? c e) c (@pair e c)))

(df @map ((f <fun>) (x <lst>) => <lst>)
  (rep do ((x x) (res '()))
    (if (@empty? x)
	(@rev! res)
	(do (@tail x) (@pair (f (@head x)) res)))))

(df @pick ((f <fun>) (x <lst>) => <lst>)
  (rep do ((x x) (res '()))
    (if (@empty? x)
	(@rev! res)
        (let ((h (@head x))) (do (@tail x) (if (f h) (@pair h res) res))))))

(df @do ((f <fun>) (x <lst>) => <any>) ;; TODO: => (tup)
  (rep do ((x x))
    (if (@empty? x)
	#f
	(seq (f (@head x)) (do (@tail x))))))

(df @alter ((dst <lst>) (src <lst>) => <lst>)
  (rep in ((ds dst) (ss src))
    (if (or (@empty? ds) (@empty? ss))
        dst
        (seq (set (@head ds) (@head ss))
             (in (@tail ds) (@tail ss))))))

(df @fab ((x <lst>) (s <int>) => <lst>)
  (rep fab (((i <int>) s) ((res <lst>) '()))
    (if (@< i 0) res (fab (@+ i -1) (@pair nul res)))))

(df @reduce ((combine <fun>) (init <any>) (c <lst>) => <lst>)
  (rep red ((res init) (c c))
    (if (@empty? c)
        res
        (red (combine res (@head c)) (@tail c)))))

(df @cat2 ((x <lst>) (y <lst>) => <lst>)
  (%cat2 x y))

(df @find-key ((f <fun>) (c <lst>) => <any>) ;; TODO: => <int>
  (rep fnd ((c c) (i 0))
    (if (@empty? c)
	nul
	(if (f (@head c))
	    i
	    (fnd (@tail c) (@+ i 1))))))

(df @mem? ((c <lst>) (x <any>) => <log>)
  (not (@== (@find-key (fun (y) (@== x y)) c) nul)))

;; added rev! since it was returning the list backwards. TODO: make it more
;; efficient.
(df @del-dups ((x <lst>) => <lst>)
  (@rev! (@reduce (fun (s e) (if (@mem? s e) s (@pair e s))) '() x)))

(df @lst-helper ((objects <opts>) (i <int>) (l <lst>))
  (if (@== i -1)
      l
      (@lst-helper objects (@+ i -1) (@pair (@oelt objects i) l))))

(df @lst ((objects ...)) (@lst-helper objects (@+ (@olen objects) -1) '()))

(df @velt ((x <vec>) (i <int>) => <any>)
  (%velt x (%iu i)))

(df @velt-setter (z (x <vec>) (i <int>))
  (set (%velt x (%iu i)) z))

(df @vec ((objects ...))
  (let ((v (%vec (%iu (@olen objects)))))
    (rep copy ((k (@+ (@olen objects) -1)))
      (if (@= k -1)
          v
          (seq
            (set (@velt v k) (@oelt objects k))
            (copy (@+ k -1)))))))


(df @fun-names ((x <fun>) => <lst>) (%sig-names (%gen-sig x)))

(df @fun-specs ((x <fun>) => <lst>) (%sig-specs (%gen-sig x)))

(df @fun-nary? ((x <fun>) => <log>) (%sig-nary? (%gen-sig x)))

(df @fun-arity ((x <fun>) => <int>) (%sig-arity (%gen-sig x)))

(df @fun-value ((x <fun>) => <any>) (%sig-value (%gen-sig x)))

(df @fun-unification-vars ((x <fun>) => <lst>) (%sig-unification-vars (%gen-sig x)))

(df @fun-mets ((x <fun>) => <lst>) (%gen-mets x))

(df @fun-mets-setter ((z <lst>) (x <fun>)) (set (%gen-mets x) z))

;;; 
;;; 12. FUNCTIONS
;;; 

(dv <env>   <any>)
(dv <specs> <lst>)
(dv <body>  <any>)

(df fun-spec ((x <met>) (i <int>) => <any>)
  (@elt (@fun-specs x) i))

(dv <mets> <lst>)

(df fun-same-met? ((x <met>) (y <met>) => <log>)
  (@all2? @@== (@fun-specs x) (@fun-specs y)))

(df fun-congruent? ((x <fun>) (y <fun>) => <log>)
  (and (@=  (@fun-arity x) (@fun-arity y))
       (@== (@fun-nary? x) (@fun-nary? y))
       (@all2? @subtype? (@fun-specs x) (@fun-specs y))))

(dv *restarts-ok?* #f)

;;; Add a method to a generic function.  Note that this function might
;;; *create* a new generic function, and add the method to that instead.
;;; Return the generic function to which the method was added.
(df gen-add-met ((g <gen>) (m <met>) => <gen>)
  (set (%fun-cache g) #f)
  (if (not (fun-congruent? m g))
      ;; Raise a method congruency error.  If restarts have been set up,
      ;; install an appropriate restart handler.  Note that we don't install
      ;; the handler until *after* the error for performance reasons.
      (if *restarts-ok?*
          (lab return
            (try ((type <replace-generic-restart>)
                  (description
                   "Replace %= with an empty generic congruent with %=" g m))
              (fun (c r)
                (return (gen-add-met (gen-from-met m) m)))
              (incongruent-method-error g m)))
          (incongruent-method-error g m))
      
      ;; DEP TRACK MET/GEN IN ALL REAL SPECS -- USED FOR REDEFINITION
      (seq
        (rep lop ((specs (@fun-specs m)))
          (unless (@empty? specs)
            (let ((spec (@head specs)))
              ;; TODO: CHANGE TO REFLECT NEW SETUP -- DEP-CLASSES
              (unless (or (@singleton-spec? spec) (@== spec <any>))
                (let ((spec-class (%object-class spec)))
                  (set (%class-gens spec-class)
                       (@add-new (%class-gens spec-class) g))
                  (set (%class-mets spec-class)
                       (@add-new (%class-mets spec-class) m)))
                (lop (@tail specs))))))
        ;; ACTUALLY PERFORM ADDITION KEEPING TRACK OF IT BEING A REPLACEMENT
        ;; OR NOT
        (rep col ((mets '()) (same? #f) ((gms <mets>) (@fun-mets g)))
          (if (@empty? gms)
              (set (%gen-mets g) (@rev! (if same? mets (@add mets m))))
              (let ((gm          (@head gms))
                    (now-same?   (fun-same-met? gm m)))
                (col (@add mets (if now-same? m gm)) 
                     (or now-same? same?) (@tail gms)))))
        g)))

(dp @class-in? (c cs => <log>)
  (if (%empty? cs)
      #f
      (if (@== (%head cs) c)
	  #t
	  (@class-in? c (%tail cs)))))

(dp @subclass? (c1 c2 => <log>)
  (or (@== c2 <any>) (@== c1 c2)
      (@class-in? c2 (%class-parents c1))))

(dp @class-isa? (o c => <log>)
  (@subclass? (%class-of o) c))

(dp @singleton-isa? (o t => <log>)
  ;; TODO: FIX UP TO DO PROPER ==
  (@== (%type-object t) o))

(df @isa? (o t => <log>)
  (if (@== (%class-of t) <class>)
      (@class-isa? o t)
      (isa? o t)))

(df @class< (c1 c2 wrt => <log>)
  (rep find ((ps (%class-parents wrt)))
    (if (@empty? ps)
        (error "can't order specializers - arg/reference object %= is "
               "neither %= nor %=" wrt c1 c2) 
        (let ((c (@head ps)))
          (if (@== c c1)
              #t
              (if (@== c c2)
                  #f
                  (find (@tail ps))))))))

(dv <tup> <vec>)
(dv @tup  @vec)
(dv tup  @vec)
(dv @telt @velt)

;; TODO: DEF SUBTYPE METHODS

(df @type-equal? (t1 t2 => <log>)
  (or (@== t1 t2)
      (and (not (@== (%class-of t1) <class>)) (not (@== (%class-of t2) <class>))
           (@subtype? t1 t2) (@subtype? t2 t1))))

(df @subtype? (t1 t2 => <log>)
  (if (and (@== (%class-of t2) <class>) (@== (%class-of t1) <class>))
      (@subclass? t1 t2)
      (subtype? t1 t2)))
  
(df @may-isa? ((c <class>) (t <type>) => (tup <log> <log>))
  (if (@== (%class-of t) <class>)
      (if (@subclass? c t) (@tup #t #t) (@tup #f #f))
      (may-isa? c t)))

(df @order-specs-class (t1 t2 arg)
  (if (@== t1 t2)
      (@tup '= t1)
      (if (@class< t1 t2 (%class-of arg))
          (@tup '< t1)
          (@tup '> t2))))

(df @order-specs (t1 t2 arg)
  (if (and (@== (%class-of t1) <class>) (@== (%class-of t2) <class>))
      (@order-specs-class t1 t2 arg)
      (order-specs t1 t2 arg)))

(df order-mets ((m1 <met>) (m2 <met>) (args <opts>) => <sym>)
  (let (((arity <int>) (@fun-arity m1)))
    (rep loop (((state <sym>) '=) ((idx <int>) 0))
      (if (@= idx arity)
          state
          (let ((m1spec (fun-spec m1 idx))
                (m2spec (fun-spec m2 idx))
                ((cmp+typ <tup>) (@order-specs m1spec m2spec (@oelt args idx)))
                ((cmp <sym>) (@telt cmp+typ 0))
                ((idx <int>) (@+ idx 1)))
            (if (@== cmp '=)
                (loop state idx)
                (if (and (not (@== cmp '<>))
                         (or (@== state '=) (@== cmp state)))
                    (loop cmp idx)
                    '<>)))))))

(df sorted-app-mets-1
      ((mets <lst>) (args <opts>) (order-mets <fun>)
       => (tup (ordered <lst>) (ambig <lst>)))
  (let (((ohead <lst>) (@pair #f '()))
	((ahead <lst>) (@pair #f '())))
    (rep loop (((mets <lst>) mets))
      (unless (@== mets '())
	(let (((met <met>) (@head mets)))
	  (loc ((make-ambiguous ((headed-list <lst>))
		  (rep loop (((l <lst>) (@tail headed-list)))
		    (or (@== l '())
			(let ((t1 (@tail l)))
			  (set (@tail l) (@tail ahead))
			  (set (@tail ahead) l)
			  (loop t1))))
		  (set (@tail headed-list) '())
		  (set (@tail ahead) (@pair met (@tail ahead))))
		(precedes-all? ((l <lst>))
                  (rep loop (((l <lst>) l))
		    (if (@== l '())
			#t
			 (if (@== (order-mets met (@head l) args) '<)
			     (loop (@tail l))
			     #f))))
		(check-subsequent-ambiguities ((oprev <lst>))
		  (if (or (not (precedes-all? (@tail oprev)))
			  (not (precedes-all? (@tail ahead))))
		      (make-ambiguous oprev)
		      (set (@tail oprev) (@pair met (@tail oprev)))))
		(insert ((oprev <lst>) (osub <lst>))
		  (if (@empty? osub)
		      (check-subsequent-ambiguities oprev)
		      (let ((indic (order-mets met (@head osub) args)))
			(if (@== indic '<)     ;; comes before current one.
			    (check-subsequent-ambiguities oprev)
			    (if (@== indic '>) ;; comes after, check further.
				(insert osub (@tail osub))
				(make-ambiguous oprev)))))))
	    (insert ohead (@tail ohead))
	    (loop (@tail mets))))))
    (@tup (@tail ohead) (@tail ahead))))

(dv met-app-unify (fun (x y) #f))

(df met-app? ((met <met>) (args <opts>) => <log>)
  (if (not (@empty? (@fun-unification-vars met)))
      (met-app-unify met args)
      (let (((n <int>) (@fun-arity met)))
        (rep loop (((i <int>) 0))
          (if (@= i n)
              #t
              (if (@isa? (@oelt args i) (fun-spec met i))
                  (loop (@+ i 1))
                  #f))))))

(df sorted-app-mets
      ((gf <gen>) (args <opts>) => (tup (ordered <lst>) (ambig <lst>)))
  (let ((considered-mets
	 (rep col ((ans '()) (ms (@fun-mets gf)))
	   (if (@empty? ms)
	       ans
	       (let ((m (@head ms))
		     (ans (if (met-app? m args) (@pair m ans) ans)))
		 (col ans (@tail ms)))))))
    (sorted-app-mets-1 considered-mets args order-mets)))

; (df opt-args ((n <int>) (args <opts>) => <opts>)
;   (rep col (((i <int>) 0) ((l <opts>) '()) ((p <opts>) args))
;     (if (@= i n)
; 	(if (@empty? l)
; 	    (@lst p)
; 	    (seq (set (@tail l) (@lst p)) args))
; 	(col (@+ i 1) p (@tail p)))))

(df @gen-cache-arg-pos (x)             (%gen-cache-arg-pos x))
(df @gen-cache-arg-pos-setter (z x)    (set (%gen-cache-arg-pos x) z))
(df @gen-cache-singletons (x)          (%gen-cache-singletons x))
(df @gen-cache-singletons-setter (z x) (set (%gen-cache-singletons x) z))
(df @gen-cache-classes (x)             (%gen-cache-classes x))
(df @gen-cache-classes-setter (z x)    (set (%gen-cache-classes x) z))

;; GIVEN MET/GEN AND ARGS FIND SLOT-OFFSET -- USING SLOT IN MET ENV

(df method-accessor-offset ((gen <gen>) (met <met>) (args <opts>))
  (let ((slot  (%met-env met)) ;; TODO: THIS NEEDS TO BE IMPROVED
	(slot? (and slot (@== (%class-of slot) <slot>)))
	(n     (@olen args)))
    (and slot?
	 (if (@= n 1) ;; getter?
	     (slot-offset (@oelt args 0) gen)
	     (slot-offset (@oelt args 1) (%slot-getter slot))))))

(df @singleton-spec? (x)
  (@class-isa? x <singleton>))

(df @subclass-spec? (x)
  (@class-isa? x <subclass>))

(df @union-spec? (x)
  (@class-isa? x <union>))

(df @precise-spec? (x)
  (or (@singleton-spec? x) (@subclass-spec? x) 
      (and (@union-spec? x) (@any? @precise-spec? (%type-elts x)))))

(df @mets-unspecialized-at? ((mets <lst>) (pos <int>) => <log>)
  (@all? (fun (met) (@= (fun-spec met pos) <any>)) mets))

(df @prune-mets-by-type-at
    ((mets <lst>) (type <type>) (pos <int>) => <mets>)
  (@pick (fun (met) (@subtype? type (fun-spec met pos))) mets))

(df @mets-specs-at ((mets <lst>) (pos <int>) => <lst>)
  (@map (fun (met) (fun-spec met pos)) mets))

;; TODO: GROVEL THROUGH UNIONS

(df @mets-singletons-at ((mets <lst>) (pos <int>) => <lst>)
  (@pick (fun (spec) (@singleton-spec? spec)) (@mets-specs-at mets pos)))

(df @mets-subclasses-at ((mets <lst>) (pos <int>) => <lst>)
  (@pick (fun (spec) (@subclass-spec? spec)) (@mets-specs-at mets pos)))

(df gen-lookup-miss-1-using
  (key instance (all-assocs <fun>) (all-assocs-setter <fun>) 
   (gen <gen>) cache (mets <lst>) (sorted-mets <lst>) (i <int>) (args <opts>))
  ;; (if (or (and cache (@< i (%gen-cache-arg-pos cache)))
  ;;         (@mets-unspecialized-at? mets i))
  ;;     (gen-lookup-miss-1 gen cache mets sorted-mets (@+ i 1) args)
  (let ((cache (or cache (%gen-cache #t i nil nil))))
    (rep loop ((assocs (all-assocs cache)))
      (if (@empty? assocs) ;; miss
          ;; could be a stale object
          (if (and (@== all-assocs @gen-cache-classes)
                   (%class-forward key))
              (seq
                (update-instance-for-changed-class instance)
                (set key (%class-of instance)) ; reset key to new class
                (loop (all-assocs cache))) ; restart search cause might hit
              (let ((val (gen-lookup-miss-1
                          gen #f mets sorted-mets (@+ i 1) args)))
                (set (all-assocs cache)
                     (@pair key (@pair val (all-assocs cache))))))
          (let ((k (@head assocs)))
            (if (@== k key)
                (let ((v (@head (@tail assocs))))
                  (gen-lookup-miss-1 gen v mets sorted-mets (@+ i 1) args))
                (loop (@tail (@tail assocs)))))))
    cache))

;;; copy args with arg as i'th elt into a opts.
(df @specd-args ((args <opts>) (i <int>) (arg <any>) => <opts>)
  (let ((v (%vec (%iu (@olen args))))
        (r (%opts-vec (%lb (%slot-dat-at v (%vlen v))) (%ib (%vlen v)) v)))
    (rep copy ((k 0))
      (if (@== (@olen args) k)
        r
        (seq
          (set (@oelt r k) (if (@== k i) arg (@oelt args k)))
          (copy (@+ k 1)))))))

(df ensure-singleton-cache
    ((gen <gen>) cache (mets <lst>) (sorted-mets <lst>) (i <int>) (args <opts>))
  (or cache 
      ;; prefill with singletons
      (let ((subclasses (@mets-subclasses-at mets i)))
        (if (@empty? subclasses)
            (let ((singletons (@mets-singletons-at mets i)))
              (if (@empty? singletons)
                  #f ;; no prefilling needed and no cache supplied
                  (let ((cache (%gen-cache #t i nil nil)))
;;???                    (set (%fun-cache gen) cache)
                    (rep loop ((singletons singletons))
                      (if (@empty? singletons)
                          cache
                          (let ((sing  (@head singletons))
                                (arg   (%type-object sing))
                                (args  (@specd-args args i arg))
                                (smets (choose-methods gen args))
                                (app-mets (@prune-mets-by-type-at mets sing i)))
                            (gen-lookup-miss-1-using arg arg
                             @gen-cache-singletons @gen-cache-singletons-setter 
                             gen cache mets smets i args)
                            (loop (@tail singletons))))))))
            (%gen-cache #f i nil nil))))) ;; subclasses require singleton prec

(df gen-lookup-miss-1
    ((gen <gen>) ocache (mets <lst>) (sorted-mets <lst>) (i <int>) (args <opts>))
  (if (@= i (@fun-arity gen))
      (or (method-accessor-offset gen (@head sorted-mets) args) sorted-mets)
      (let ((arg   (@oelt args i))
            (cache (ensure-singleton-cache gen ocache mets sorted-mets i args))
            (sing? (@singleton-spec? (fun-spec (@head sorted-mets) i))))
	(if (or (and sing? (@== ocache cache)) ;; sing args not seen?
                (and cache (not (%gen-cache-missable? cache)))) ;; force sing?
            (let ((mets (@prune-mets-by-type-at mets (%singleton arg) i)))
              (gen-lookup-miss-1-using
               arg arg @gen-cache-singletons @gen-cache-singletons-setter
               gen cache mets sorted-mets i args))
            (if sing? ;; sing arg doesn't belong in this cache
                cache ;; already in cache by way of ensure-singleton-cache?
                (let ((class (%class-of arg))
                      (app-mets (@prune-mets-by-type-at mets class i)))
                  (gen-lookup-miss-1-using
                   class arg @gen-cache-classes @gen-cache-classes-setter
                   gen cache app-mets sorted-mets i args)))))))

(df gen-lookup-miss ((gen <gen>) (args <opts>) => <any>) 
  (let ((mets (choose-methods gen args))) ;; TODO: => (or <met> <gen-cache>)
    (gen-lookup-miss-1 gen (%fun-cache gen) (%gen-mets gen) mets 0 args)))

(dp gen-lookup-1) ;; FORWARD DECL

(dp gen-lookup ((gen <gen>) (args <opts>))
  (let ((c (or (%fun-cache gen)
               (set (%fun-cache gen) (gen-lookup-miss gen args)))))
    (gen-lookup-1 gen c args)))

(dp slot-value-at (object (offset <int>) => <any>)
  (let ((val (%slot-elt object (%iu offset))))
    (if (@== val nul-slot)
	(let ((slots (object-slots object)))
	  (set (%slot-elt object (%iu offset))
	       ((%slot-init (@elt slots offset)) object)))
	val)))

(dp slot-value-at-setter (z object (offset <int>))
  (set (%slot-elt object (%iu offset)) z))

(dv $missed-dispatch (%pair nil nil))

;; MAIN DISPATCH ARG STEP (FOR SINGLETONS AND CLASSES) RESULTING IN HIT OR MISS
;; HIT RETURNS ASSOCD VALUE AND REORDERS ASSOCS PUT KEY AT FRONT REFLECTIN FREQS
;; MISS ADDS KEYS (UNLESS MISSABLE) AND THEN RERUNS LOOKUP FROM BEGINNING

(dp gen-lookup-1-using
    (key (prev-assocs <lst>) (assocs <lst>) missable? (cache-offset <int>) 
     (gen <gen>) cache (args <opts>))
    (if (@empty? assocs) ;; miss
        (if missable?
            $missed-dispatch
            (seq (set (%fun-cache gen) (gen-lookup-miss gen args))
                 (gen-lookup gen args))) ;; restart lookup
        (let ((k           (%head assocs))
              (tail-assocs (%tail assocs)))
          (if (@== k key)
              (let ((v          (%head tail-assocs))
                    (old-assocs (%slot-elt cache (%iu cache-offset))))
                (if (@== old-assocs assocs) ;; already at front?
                    #f
                    (let ((nxt-assocs (%tail tail-assocs)))
                      ;; move assoc to front
                      (set (%slot-elt cache (%iu cache-offset)) assocs)
                      (set (%tail tail-assocs)                  old-assocs)
                      (set (%tail (%tail prev-assocs))          nxt-assocs)))
                (gen-lookup-1 gen v args))
              (gen-lookup-1-using
               key assocs (%tail tail-assocs) missable? cache-offset
               gen cache args)))))

;; DISPATCH ARG STEP RUNNING BOTH SINGLETON AND CLASS DISPATCH
;; IF HIT THEN 
;;   IF LAST ARG THEN LEAF WITH INT MEANING SLOT-OFFSET ELSE METHOD
;;               ELSE RECURSE WITH NEXT ARG

(dp gen-lookup-1 ((gen <gen>) cache (args <opts>))
    (if (@== (%class-of cache) <gen-cache>)
        (let ((arg (@oelt args (%gen-cache-arg-pos cache)))
              (val (let ((assocs (%gen-cache-singletons cache)))
                     ;; first look in singleton cache
                     (gen-lookup-1-using
                      arg assocs assocs (%gen-cache-missable? cache)
                      $gen-cache-singletons-offset
                      gen cache args))))
            (if (@== val $missed-dispatch)
                (let ((assocs (%gen-cache-classes cache)))
                  ;; otherwise look in class cache
                  (gen-lookup-1-using
                   (%class-of arg) assocs assocs #f
                   $gen-cache-classes-offset gen cache args))
                val))
        cache))

;; TODO: CONDITIONS FOR THESE ERRORS

(df choose-methods ((gen <gen>) (args <opts>) => <lst>)
  (let ((ord-amb-mets   (sorted-app-mets gen args))
        (sorted-mets    (@telt ord-amb-mets 0))
        (ambiguous-mets (@telt ord-amb-mets 1)))
;    (if (@< 0 (@len ambiguous-mets))
;        (error "Ambiguous Method Error when calling %= on %=" gen args)
        (if (@empty? sorted-mets)
            (error "No Applicable Methods Error when calling %= on %=" gen args)
            sorted-mets)))

;; FIXME: note the horrible hack in p2c.proto that makes it not generate
;; an UNLINK_STACK at the end of this function.
;; The way this works right now is not a long term solution.

(df %dispatch ((args ...))
  (let ((result (gen-lookup (%fun-reg) args)))
    (if (@== (%class-of result) <int>) ;; int?
        (let ((n (@olen args))
              (res
               (if (@= n 1) ;; getter?
                   (slot-value-at (@oelt args 0) result)
                   (set (slot-value-at (@oelt args 1) result)
                        (@oelt args 0)))))
          (%unlink-stack)
          res)
        (seq
          (%unlink-stack)
          (%raw-call (%head result) (%tail result))))))

;; READY TO REPLACE EARLY DISPATCHER WITH REAL DISPATCHER IN EARLY GEN'S

(df %patch-early-generic ((generic <gen>))
  (set (%gen-code generic) (%met-code %dispatch)))

(dss (%patch-early-generics)
  `(seq ,@(%map-boot-slots 
	    (fun (owner name type init) 
	      `(seq 
                 (%patch-early-generic ,name)
                 (%patch-early-generic ,(make-sym name "-setter")))))))

(%patch-early-generics)

;; SIG TRAMPOLINES THROUGH FUN'S

(dss (def-fun/sig-accessor ,name)
  `(seq (df ,(make-sym "fun-" name) (x)
	  (,(make-sym "sig-" name) (fun-sig x)))
	(df ,(make-sym "fun-" name "-setter") (z x) 
	  (set (,(make-sym "sig-" name) (fun-sig x)) z))))

(def-fun/sig-accessor names)
(def-fun/sig-accessor specs)
(def-fun/sig-accessor nary?)
(def-fun/sig-accessor arity)
(def-fun/sig-accessor value)
(def-fun/sig-accessor unification-vars)

;;; 
;;; 13. OBJECTS
;;; 

(dv <parents> <lst>)
(dv <slots>   <lst>)

(df object-class (x) (%class-of x))
(df @class-parents (x) (%class-parents x))

(df class-ordered-parents ((c <class>) => <parents>)
  (loc ((merge-lists ((partial-cpl <lst>) (remaining-lists <lst>))
          ;; the partial-cpl is in reverse order at this point.
	 (if (@all? @@empty? remaining-lists)
	     (@rev! partial-cpl)
	     (loc ((unconstrained-class (p)
		    (loc ((p-in-and-unconstrained-in? ((l <lst>))
			   (@== (@head l) p))
			  (p-unconstrained-in? ((l <lst>))
  		           (or (@== (@head l) p) (not (@mem? (@tail l) p)))))
		      (and (@any? p-in-and-unconstrained-in? remaining-lists)
			   (@all? p-unconstrained-in? remaining-lists)
			   p)))
		   (unconstrained-class-in-parents ((c <class>))
		     (@any? unconstrained-class (%class-direct-parents c))))
	       (let ((next (@any? unconstrained-class-in-parents partial-cpl)))
		 (if next
		      (loc ((remove-next ((l <lst>))
			      (if (@== (@head l) next) (@tail l) l)))
			(merge-lists 
			 (@pair next partial-cpl)
			 ;; (@alter remaining-lists 
			   (@map remove-next remaining-lists)
			 ;; )
			 ))
		      (error "inconsistent precedence graph")))))))
     (let ((parents (%class-direct-parents c)))
       (merge-lists (@lst c)
                    (@add (@map @class-parents parents) parents)))))

(df @class-direct-slots (x) (%class-direct-slots x))

(df class-ordered-slots ((x <class>) => <slots>)
  (let ((slots
         (@del-dups
          (@reduce @cat2 '() (@map @class-direct-slots (%class-parents x))))))
    (set (%class-slot-len x) (@len slots))
    slots))

(df del-class ((class <class>))
  ;; TODO: DEL ALL DIRECT-SLOTS
  ;; TODO: FLUSH ALL GEN'S ON ALL SLOTS
  ;; TODO: DEL SELF FROM ALL DIRECT-PARENTS
  )

(df fab-class ((name <sym>) (parents <parents>) => <class>)
  (let ((x (%class 0 name parents '() '() '() '() '() '() #f)))
    (if (@empty? (%class-direct-parents x)) ;; ONLY FOR <ANY> TODO: WHY?
        (set (%class-direct-parents x) (@lst x)))
    (@do (fun (parent) 
           (set (%class-direct-children parent)
                (@add-new (%class-direct-children parent) x)))
	 (%class-direct-parents x))
    (set (%class-parents x)  (class-ordered-parents x))
    (set (%class-slots x)    (class-ordered-slots x))
    x))

(df refab-class ((old-class <class>) (parents <parents>) => <class>)
  ;; TODO: WHAT TO DO WITH OLD SLOTS? -- REUSE THEM FOR NOW
  ;;       EXCEPT ALL OLD METS ARE SPEC'D ON OLD-CLASS
  ;; TODO: NEED CONCRETE-CLASS CLASS FOR THIS
  (let ((new-class (fab-class parents (%class-direct-slots old-class))))
    (set (%class-forward old-class) new-class)
    new-class))

;; TRAMPOLINE META METHODS
;; TODO: OBSOLETE

(dss (def-object-class-accessor ,name)
  `(df ,(make-sym "object-" name) (x) 
     (,(make-sym "%class-" name) (%class-of x))))

(def-object-class-accessor slots)
(def-object-class-accessor parents)

;;;
;;; SLOTS
;;;

(dv $getter-not-found -1)

(df ensure-fresh-object (x)
  (when (%class-forward (%class-of x)) ;; stale object?
    (update-instance-for-changed-class x)))

(df slot-offset (object (getter <fun>) => <int>)
  (rep loop ((i 0) (slots (object-slots object)))
    (if (@empty? slots)
	$getter-not-found
	(if (@== (%slot-getter (@head slots)) getter)
	    i
	    (loop (@+ i 1) (@tail slots))))))

(df slot-value (object (getter <fun>) => <any>)
  (ensure-fresh-object object)
  (let ((offset (slot-offset object getter)))
    (if (@= offset $getter-not-found)
	(error "slot %s not found in %=" getter object)
	(slot-value-at object offset))))

(df slot-value-setter (z object (getter <fun>))
  (ensure-fresh-object object)
  (let ((offset (slot-offset object getter)))
    (if (@= offset $getter-not-found)
	(error "slot %s not found in %=" getter object)
	(set (slot-value-at object offset) z))))

(df %isa ((parent <class>) (getters <lst>) (vals <lst>) => <any>)
  (let ((object (%object-of parent (%iu (%class-slot-len parent)))))
    ;; SET SLOT-VALUES FROM ISA ARGUMENTS
    ;; TODO: FASTER WITH GEN CACHE?
    (rep loop ((getters getters) (vals vals))
      (unless (or (@== getters '()) (@== vals '()))
        (seq (set (slot-value object (@head getters)) (@head vals))
	     (loop (@tail getters) (@tail vals)))))
    object))

(df find-getter (owner (getter <gen>) => <met>)
  (rep loop ((mets (@fun-mets getter)))
    (if (@empty? mets)
	(error "COULDN'T FIND GETTER")
	(let ((met (@head mets)))
	  (if (@== (fun-spec met 0) owner)
	      met
	      (loop (@tail mets)))))))

(df find-setter (owner type (zetter <gen>) => <met>)
  (rep loop ((mets (@fun-mets zetter)))
    (if (@empty? mets)
	(error "COULDN'T FIND SETTER")
	(let ((met (@head mets)))
	  (if (and (@== (fun-spec met 1) owner) 
                   (@type-equal? (fun-spec met 0) type))
	      met
	      (loop (@tail mets)))))))

;; CREATE CLONE OF CLASS AND MARK THEM AS FORWARDED CLONE OF ORIGINAL CLASS
;; ALSO CLEAR ALL ASSOC'D GENERIC DISPATCH CACHES SO THAT THEY TRAP NEXT TIME

(df forward-class (old-class)
  (let ((new-class (%clone old-class))) 
    (@do (fun (g) (set (%fun-cache g) #f)) (%class-gens old-class))
    (set (%class-forward old-class) new-class)))

(df @do-children (f x)
  (let ((visited '()))
    (rep visit ((x x))
      (unless (@mem? visited x)
        (set visited (@add visited x))
        (f x) 
        (@do visit (%class-direct-children x))))))

(df %slot (owner (getter <gen>) (setter <gen>) type (init <fun>))
  ;; TODO: FORWARD CONDITIONALLY
  ;; (@do-children forward-class owner)
  (let ((class      owner)
	(slot       (isa <slot> (set slot-owner owner)
		      (set slot-getter getter) (set slot-setter setter)
		      (set slot-type   type)   (set slot-init   init)))
	(getter-met (find-getter owner getter))
	(setter-met (find-setter owner type setter)))
    ;; ACCESSORS STORE SLOT IN THEIR ENVIRONMENT
    (set (%met-env getter-met) slot)
    (set (%met-env setter-met) slot)
    (set (%class-direct-slots class)
	 (@cat2 (%class-direct-slots class) (@lst slot)))
    (set (%class-slots class)
	 (class-ordered-slots class))
    ;; FLUSH ACCESSOR GENERIC CACHES CAUSE THEY HOLD POTENTIALLY 
    ;; OUTDATED SLOT OFFSETS 
    (@do (fun (slot) (set (%fun-cache (%slot-getter slot)) #f))
	 (%class-slots class)) 
    slot))

(dp %update-instance-for-changed-class (new-object)
;;  (let ((old-class (%class-of new-object))
;;	(new-class (%class-forward old-class))
;;	(old-object (%make-object)))
;;    ;; capture old values in temporary container
;;    (set (%object-values old-object) (%object-values new-object))
;;    ;; allocate new values in existing object and set new class
;;    (%install-object-values new-object (%%len (%class-slots new-class)))
;;    (set (%object-class new-object) new-class)
;;    ;; copy correlated slot values from old to new
;;    (rep loop-old-slots ((old-slots (%class-slots old-class)) (old-offset 0))
;;      (unless (@empty? old-slots)
;;        (let ((old-slot   (@head old-slots))
;;	      (getter     (%slot-getter old-slot))
;;	      (new-offset (slot-offset new-object getter)))
;;	  (unless (@= new-offset $getter-not-found)
;;	    (set (slot-value-at new-object new-offset) 
;;		 (slot-value-at old-object old-offset))
;;	    (loop-old-slots (@tail old-slots) (@+ old-offset 1))))))
    new-object) ;; )

(df update-instance-for-changed-class (object)
  (%update-instance-for-changed-class object))

(dv add-slot %slot)

;; USED FROM COMPILER TO BUILD GEN'S
;; TODO: NEED FUN-VALUE AS WELL

(df fab-gen
    (name (names <lst>) (specs <lst>) (nary? <log>) (mets <lst>) => <gen>)
  (isa <gen>
    (set fun-code (fun-code %dispatch))
    (set fun-name name)
    (set fun-sig (isa <sig>
                   (set sig-names names)
                   (set sig-specs specs)
                   (set sig-nary? nary?)
                   (set sig-arity (@len specs))
                   (set sig-value <any>)))
    (set fun-mets mets)))

(df gen-from-met ((x <met>) => <gen>)
  (let ((specs (@map (fun (x) <any>) (@fun-specs x))))
    (fab-gen (fun-name x) '() specs (@fun-nary? x) '())))

;; CALLED FROM COMPILER/INTERPRETER

(df %define-method (gen (met <met>) => <gen>)
  (gen-add-met (or gen (gen-from-met met)) met))

(df unexec ((name <str>) (fun <fun>))
  (set %*start-running-at* fun)
  (%unexec (%su name)))

;;; TYPE PROTOCOL

;;; SUBTYPE?
(dg subtype? ((t1 <type>) (t2 <type>) => <log>))

(dm subtype? ((t1 <union>) (t2 <type>) => <log>)
  (@all? (fun (t) (@subtype? t t2)) (%type-elts t1)))
(dm subtype? ((t1 <type>) (t2 <union>) => <log>)
  (@any? (fun (t) (@subtype? t1 t)) (%type-elts t2)))
;; disambiguate the case where there are two unions.
(dm subtype? ((t1 <union>) (t2 <union>) => <log>)
  (@all? (fun (t) (@subtype? t t2)) (%type-elts t1)))

(dm subtype? ((t1 <class>) (t2 <class>) => <log>)
  (@subclass? t1 t2))
(dm subtype? ((t1 <singleton>) (t2 <class>) => <log>)
  (@isa? (%type-object t1) t2))
(dm subtype? ((t1 <subclass>) (t2 <class>) => <log>)
  (@subclass? <class> t2)) ;    ????????

(dm subtype? ((t1 <class>) (t2 <singleton>) => <log>)
  #f)
(dm subtype? ((t1 <singleton>) (t2 <singleton>) => <log>)
  (@singleton-isa? (%type-object t1) t2))
(dm subtype? ((t1 <subclass>) (t2 <singleton>) => <log>)
  #f)

(dm subtype? ((t1 <class>) (t2 <subclass>) => <log>)
  (and (@== t1 <class>) (@== (%type-class t2) <class>)))
(dm subtype? ((t1 <subclass>) (t2 <subclass>) => <log>)
  (@subclass? (%type-class t1) (%type-class t2)))
(dm subtype? ((t1 <singleton>) (t2 <subclass>) => <log>)
  (and (@isa? (%type-object t1) <class>)
       (@subclass? (%type-object t1) (%type-class t2))))

;;; ISA?

(dg isa?     ((x <any>) (t <type>) => <log>))

(dm isa? (o (t <class>) => <log>)
  (@class-isa? o t))
(dm isa? (o (t <singleton>) => <log>)
  (@singleton-isa? o t))
(dm isa? (o (t <subclass>) => <log>)
  (and (@isa? o <class>)
       (@subclass? o (%type-class t))))
(dm isa? (o (u <union>) => <log>)
  (@any? (fun (t) (@isa? o t)) (%type-elts u)))

;;; ORDER-SPECS
(dg order-specs ((t1 <type>) (t2 <type>) (arg <any>)
                 => (tup (order <sym>) canonical-type)))

(dm order-specs ((t1 <singleton>) (t2 <singleton>) arg
                 => (tup (order <sym>) canonical-type))
  (@tup '= t1))

(dm order-specs ((t1 <singleton>) (t2 <type>) arg
                 => (tup (order <sym>) canonical-type))
  (@tup '< t1))

(dm order-specs ((t1 <subclass>) (t2 <subclass>) arg
                 => (tup (order <sym>) canonical-type))
  (let ((c1 (%type-class t1))
        (c2 (%type-class t2)))
    (case
      ((@== c1 c2)         (@tup '= t1))
      ((@class< c1 c2 arg) (@tup '< t1))
      (#t                  (@tup '> t2)))))

(dm order-specs ((t1 <subclass>) (t2 <class>) arg
                 => (tup (order <sym>) canonical-type))
  (@tup (if (@subtype? <class> t2) ;; TODO: THIS SEEMS WRONG
            (if (@== t1 <any>)
                (order-specs <class> t2 arg)
                '<)
            '<>)
        t1))

(dm order-specs ((t1 <class>) (t2 <subclass>) arg
                 => (tup (order <sym>) canonical-type))
  (@tup (if (@subtype? <class> t1) ;; TODO: THIS SEEMS WRONG
            (if (@== t2 <any>)
                (order-specs t1 <class> arg)
                '>)
            '<>)
        t2))

(dm order-specs ((t1 <class>) (t2 <class>) arg
                 => (tup (order <sym>) canonical-type))
  (@order-specs-class t1 t2 arg))

(dm order-specs ((t1 <type>) (t2 <type>) arg
                 => (tup (order <sym>) canonical-type))
  (if (@subtype? t1 t2)
      (@tup (if (@subtype? t2 t1) '= '<) t1)
      (if (@subtype? t2 t1)
          (@tup '>  t2)
          (@tup '<> <any>))))

;;; MAY-ISA?: class contains => (some? all?) instances of type
(dg may-isa? ((c <class>) (t <type>) => (tup <log> <log>)))

(dm may-isa? ((c <class>) (t <class>) => (tup <log> <log>))
  (if (@subclass? c t) (@tup #t #t) (@tup #f #f)))
(dm may-isa? ((c <class>) (t <singleton>) => (tup <log> <log>))
  (@tup (@may-isa? (%class-of (%type-object t)) c) #f))
(dm may-isa? ((c <class>) (t <subclass>) => (tup <log> <log>))
  (let ((class? (@subtype? c <class>)))
    (@tup class? (and class? (@== (%type-class c) <any>)))))
(dm may-isa? ((c <class>) (t <union>) => (tup <log> <log>))
  (rep loop ((some? #f) (all? #f) (elts (%type-elts t)))
    (if (@empty? elts)
        (@tup some? all?)
        (let ((elt-some-all? (@may-isa? c (@head elts)))
              (elt-some? (@telt elt-some-all? 0))
              (elt-all? (@telt elt-some-all? 1)))
          (loop (or elt-some? some?) (or elt-all? all?) (@tail elts))))))

;;; 
;;; 14. MACROS
;;; 

(dv *boot-macro-module-names* '())
(dv *boot-macro-names*        '())
(dv *boot-macro-expanders*    '())
(dv *macros-ok?*              #f)  ;; ENOUGH OF WORLD BOOTED TO DEFINE MACROS?

(dp %macro (modname name expander)
  (if *macros-ok?*
      (%%macro modname name expander #f) ;; DEFINED IN AST.PROTO
      (seq ;; REMEMBER NAMES/EXPANDERS FOR LATER INSTALLATION
	(set *boot-macro-module-names*
             (@pair modname *boot-macro-module-names*))
	(set *boot-macro-names*     (@pair name     *boot-macro-names*))
	(set *boot-macro-expanders* (@pair expander *boot-macro-expanders*)))))

;;;
;;; 15. EXPORTS
;;;

;; Some functions are called directly from prt.c.  For now, we generate
;; artificial free bindings for these symbols in the boot module--and
;; export them--so that other modules will define them under the
;; correct C names.  Please feel free to redesign this if you wish.
;; TODO - It might be worth dumping (mangle-runtime-name ...) in
;; p2c.proto and using this mechanism instead.
(dss (force-names-into-boot-module ,@names)
  (if (empty? names)
      #f
      `(seq (if #f ,(head names))
            (export ,(head names))
            (force-names-into-boot-module ,@(tail names)))))

(force-names-into-boot-module
  error
  unknown-function-error
  file-opening-error
  type-error
  wrong-number-arguments-error
  keyboard-interrupt
  vec
  %with-monitor
)

;; Forward references.
;; TODO - These would normally be defined using need-implementation, but we
;; haven't defined that yet.
(export
  %%macro
  error
  incongruent-method-error

  ;; Required for the incongruent-method-error restart.
  <replace-generic-restart>
  <simple-handler-info>
  handler-info-message
  handler-info-arguments
  lst)

;; Compiler magic.
(export
  use
  use/export
  export
  mif
  macro-expand
  quasiquote
  dp
  ct
  ct-also
  slot
  isa
  fab-class
  try
  fin
  lab
  rep
  loc
  let
  bound?
  fun
  df
  dg
  dm
  dss
  ds
  dv
  dc
  set
  quote
  %raw
  seq
  if)

;; Primitives used in other modules.
(export
  %app-args
  %app-filename
  %bb
  %binding-name
  %build-runtime-modules %process-module
  %c<
  %c=
  %char-ready?
  %close-input-port
  %close-output-port
  %create-directory
  %current-input-port
  %current-output-port
  %do-stack-frames
  %eof-object
  %eq?
  %f*
  %f+
  %f-
  %f/
  %f<
  %f=
  %fi2f
  %file-exists?
  %file-mtime
  %file-type
  %flo-bits
  %force-output
  %ft
  %i!
  %i&
  %i*
  %i+
  %i-
  %i<
  %i<<
  %i<<<
  %i=
  %i>>
  %i>>>
  %i?
  %i^
  %im
  %invoke-debugger
  %it/
  %iv
  %locative-value
  %locative-value-setter
  %next-methods
  %open-input-file
  %open-output-file
  %os-binding-value
  %os-binding-value-setter
  %os-name
  %pair
  %peek-char
  %read-char
  %write-char
  %write-string
  %%sym
)

;; Regular exports.
(export
  <any>
  <chr>
  <col>
  <flat>
  <flo>
  <fun>
  <gen>
  <int>
  <loc>
  <log>
  <lst>
  <met>
  <num>
  <opts>
  <type>
  <class>
  <subclass>
  <singleton>
  <union>
  <seq>
  <sig>
  <slot>
  <str>
  <sym>
  <tup>
  <vec>

;; tagged structures
  %cb
  %cu
  %fb
  %fu
  %ib
  %iu
  %lb
  %lu
  $max-int
  $min-int
  %untag

;; repeated structures
  %sb
  %selt
  %selt-setter
  %slen
  %snul
  %str
  %su
  %vec
  %velt
  %velt-setter
  %vlen
  %vnul

  add-slot
  %allocate-stack
  *boot-macro-expanders*	;;var
  *boot-macro-names*		;;var
  *boot-macro-module-names*
  %define-method		
  fab-gen
  fab-sym
  find-getter
  find-setter
  fun-arity
  fun-name
  fun-name-setter
  fun-names
  fun-nary?
  fun-mets
  fun-sig-setter
  fun-specs
  fun-value
  gen-add-met
  head
  head-setter
  %isa
  isa?
  *macros-ok?*
  met-app?
  nil
  not
  nul
  subtype?
  may-isa?
  object-class
  type-object
  type-class
  type-elts
  class-name
  class-direct-parents
  class-direct-children
  class-direct-slots
  class-parents
  class-slots
  object-parents
  object-slots
  *restarts-ok?*
  %slot
  slot-owner
  slot-type
  slot-init
  slot-value        ;; TODO: remove these when they can be called directly 
  slot-value-setter ;; TODO: w/o being exported
  slot-getter
  slot-setter
  sig-names
  sig-specs
  sig-nary?
  sig-arity
  sig-value
  sig-unification-vars
  sorted-app-mets
  sym-name
  %symbols
  tail
  tail-setter
  unexec
  @oelt
  @olen
  @+
  @<
  @==
  %raw-call
  %check-call-types
  %loc-off %loc-off-setter
  %sp-reg-setter %sp-reg
  tup
)
