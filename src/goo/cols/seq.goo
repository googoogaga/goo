(use boot)
(use macros)
(use proto/math)
(use proto/types)
(use proto/collections/collection)

;; 3.7.3 SEQUENCES

(df @t? ((x <type>) => <union>) 
  (new <union> type-elts (@lst x (new <singleton> type-object #f))))

;;;;!! Interface
(exported
 ;; defined in boot
 <seq>
 
 ;; == (elt x 0)
 (dg 1st (x|<seq> => <any>))

 ;; == (elt x 1)
 2nd ;; (dg 2nd (x|<seq> => <any>)) ;; in types

 ;; == (elt x 2)
 (dg 3rd (x|<seq> => <any>))

 ;; == (elt x (- (len x) 1))
 (dg last (x|<seq> => <any>))

 ;; finds position of v in x else returns false.
 (dg pos (x|<seq> v|<any> => (@t? <int>)))

 ;; finds position of y in x else returns false.
 (dg finds (x|<seq> y|<seq> => (@t? <int>)))

 ;; returns reversed sequence.
 (dg rev (x|<seq> => <seq>))

 ;; returns destructively reversed sequence.
 (dg rev! (x|<seq> => <seq>))

 ;; returns concatenated sequences.
 (dg cat (x|<seq> more|... => <seq>))

 ;; returns destructively concatenated sequences.
 (dg cat! (x|<seq> more|... => <seq>))

 ;; returns two sequences concatenated.
 (dg cat2 (x|<seq> y|<seq> => <seq>))

 ;; subsequence of x between from and below.
 (dg sub (x|<seq> from|<int> below|<int> => <seq>))

 ;; replaces subsequence in range between from and below of dst with
 ;; contents of src.
 (dg sub-setter (dst|<seq> src|<seq> from|<int> below|<int>))

 ;; inserts e into x below index before
 (dg ins (x|<seq> e|<any> before|<int> => <seq>))
 (dg ins! (x|<seq> e|<any> before|<int> => <seq>))

 ;; returns new sequence with elements corresponding to those where test
 ;; returns non-false.
 (dg pick (test|<fun> x|<seq> => <seq>))

 ;; returns new sequence with elements corresponding to those where test
 ;; returns non-false.
 (dg reject (test|<fun> x|<seq> => <seq>))

 ;; returns sequence with all v's deleted from x.
 (dg del-vals (x|<seq> v|<any>  => <seq>))

 ;; returns sequence with all duplicates removed.
 (dg del-dups (x|<seq> => <seq>))


;; UNDOCUMENTED:
 (df range-check (x|<seq> i|<int>))

 (df range-check? (x|<seq> i|<int>))
 ;; (df range-error (x|<seq> i|<int>))
 (dg vals-to-str (s|<seq> => <str>))
 (dg do-key-vals (fn|<fun> key-vals|<seq>))
)

;;;;!! Implementation

;;;; Creation protocol
(dm as ((d (t< <seq>)) s|<seq> => <seq>)
  (into (fab d (len s)) s))

;;;; Collection protocol

(dm key-type (x|<col> => <type>) <int>)

(dm into (dst|<seq> src|<seq> => <seq>)
  (rep in ((ed (enum dst)) (es (enum src)))
    (if (or (fin? es) (fin? ed))
        dst
        (seq (set (now ed) (now es))
             (in (nxt ed) (nxt es))))))

;;;; Sequence protocol

(dm 1st (x|<seq> => <any>) (elt x 0))

(dm 2nd (x|<seq> => <any>) (elt x 1))

(dm 3rd (x|<seq> => <any>) (elt x 2))

;; TODO: SHOULD USE BACKWARD ITERATION PROTOCOL???
(dm last (x|<seq> => <any>) (elt x (- (len x) 1)))

(dm pos (x|<seq> v => (@t? <int>))
  (find-or (fun (a) (== v a)) x #f))

(dm finds ((x <seq>) (y <seq>) => (@t? <int>))
  (rep outer ((xsi 0))
    (if (< xsi (+ (- (len x) (len y)) 1))
        (rep inner ((xi xsi) (yi 0))
          (if (and (< xi (len x)) (< yi (len y)))
              (if (== (elt x xi) (elt y yi))
                  (inner (+ xi 1) (+ yi 1))
                  (outer (+ xsi 1)))
              xsi))
        #f)))

(dm rev (x|<seq> => <seq>)
  (rep con ((seq '()) (e (enum x)))
    (if (fin? e)
        (as-copy x seq)
        (con (add seq (now e)) (nxt e)))))

;; required: rev!

(dm cat (x|<seq> ss|... => <seq>)
  (fold cat2 x ss))

(dm cat! (x|<seq> more|... => <seq>)
  (app cat x more))

(dm cat2 (x|<seq> y|<seq> => <seq>)
  (rep con-x ((seq '()) (ex (enum x)))
    (if (fin? ex)
        (rep con-y ((seq seq) (ey (enum y)))
          (if (fin? ey)
              (as-copy x (rev! seq))
              (con-y (add seq (now ey)) (nxt ey))))
        (con-x (add seq (now ex)) (nxt ex)))))

(dm sub (x|<seq> from|<int> below|<int> => <seq>)
  (rep con-x ((seq '()) ((i <int>) 0) (e (enum x)))
    (if (fin? e)
        (as-copy x (rev! seq))
        (con-x (if (if (>= i from) (< i below)) (add seq (now e)) seq)
               (+ i 1) (nxt e)))))

(dm sub-setter (src|<seq> dst|<seq> from|<int> below|<int> => <seq>)
  (def dst-len|<int> (len dst))
  (def src-len|<int> (len src))
  (def del-len|<int> (- below from))
  (if (= del-len src-len);;  Can modify in place?
      (rep find ((d (enum dst)) (i 0))
        (if (= i from)
            (rep in ((d d) (s (enum src)))
              (if (fin? s)
                  dst
                  (seq (set (now d) (now s)) (in (nxt d) (nxt s)))))
            (find (nxt d) (+ i 1))))
      ;; Don't know if dst is stretchy so we have to create a new one
      (let ((new-len (+ (- dst-len del-len) src-len))
            (ndst    (fab (object-class dst) new-len)))
        (rep copy ((nd (enum ndst)) (d (enum dst)) (i 0))
          (if (= i from)
              (rep insert ((nd nd) (s (enum src)))
                (if (fin? s)
                    (rep skip ((d d) (i from))
                      (if (= i below)
                          (rep onto ((nd nd) (d d) (i below))
                            (if (= i dst-len)
                                ndst
                                (seq (set (now nd) (now d))
                                     (onto (nxt nd) (nxt d) (+ i 1)))))
                          (skip (nxt d) (+ i 1))))
                    (seq (set (now nd) (now s))
                         (insert (nxt nd) (nxt s)))))
              (seq (set (now nd) (now d))
                   (copy (nxt nd) (nxt d) (+ i 1))))))))

(dm pick (test|<fun> x|<seq> => <seq>)
  (rep con ((seq '()) (e (enum x)))
    (if (fin? e)
        (as-copy x seq)
        (let ((v (now e)))
          (con (if (test v) (add seq v) seq) (nxt e))))))

(dm reject (test|<fun> x|<seq> => <seq>)
  (pick (fun (x) (not (test x))) x))

(dm del-vals (s|<seq> x => <seq>)
  (reject (fun (e) (== e x)) s))

(dm del-dups (x|<seq> => <seq>)
  (as-copy x (rev! (fold (fun (s e) (if (mem? s e) s (pair e s))) '() x))))

(dm ins (x|<seq> v|<any> before|<int> => <seq>)
  (rep copy ((r '()) (i 0) (e (enum x)))
    (if (fin? e)
        (as-copy x r)
        (if (= i before)
            (copy (pair v r) (+ i 1) e)
            (copy (pair (now e) r) (+ i 1) (nxt e))))))

(dm ins! (x|<seq> v|<any> before|<int> => <seq>)
  (ins x v before))

;;;; Undocumented

(dm keys (d|<seq> => <seq>)
  (below (len d)))

;; (df range-error (x|<seq> i|<int>)
;;   ;; TODO: REAL CONDITION
;;   (error "RANGE ERROR %= %=" x i))

(df range-check (x|<seq> i|<int>)
  (when (or (< i 0) (>= i (len x)))
    (range-error)))

(df range-check? (x|<seq> i|<int>)
  (and (>= i 0) (< i (len x))))

(dm add-new (c|<seq> x => <seq>)
  (unless (mem? c x) (add c x)) 
  c)

;; TODO: DEPRECATED
(dm alter (dst|<seq> src|<seq> from|<int> below|<int> => <seq>)
  (rep in ((d (enum dst)) (s (enum src)))
    (if (or (fin? d) (fin? s))
        dst
        (seq (set (now d)  (now s)) (in (nxt d) (nxt s))))))


(dm vals-to-str (s|<seq> => <str>)
  (fold (fun (s e) (cat s (if (empty? s) "" " ") (to-str e))) "" s))

(dm do-key-vals (fn|<fun> key-vals|<seq>)
  (rep rep ((e (enum key-vals)))
    (unless (fin? e)
      (def key  (now e))
      (def nxts (nxt e))
      (def val  (and (not (fin? e)) (now e)))
      (fn key val) (rep (nxt e)))))

;; from range.proto
(need-implementation below)
