;;;; Copyright 2002, Jonathan Bachrach.  See file TERMS.

(use goo/boot)
(use goo/macros)
(use goo/math)
(use goo/types)
(use goo/cols/col)

(df @t? ((x <type>) => <union>) 
  (new <union> type-elts (@lst x (new <singleton> type-object #f))))

;;;;!! Interface
(exported
 ;; defined in boot
 <seq> <seq.>
 
 ;; == (elt x 0)
 (dg 1st (x|<seq> => <any>))

 ;; == (elt x 1)
 2nd ;; (dg 2nd (x|<seq> => <any>)) ;; in types

 ;; == (elt x 2)
 (dg 3rd (x|<seq> => <any>))

 ;; == (elt x (- (len x) 1))
 (dg last (x|<seq> => <any>))

 ;; finds position of v in x else returns false.
 (dg pos (x|<seq> v|<any> => (@t? <int>)))

 ;; finds position of y in x else returns false.
 (dg finds (x|<seq> y|<seq> => (@t? <int>)))

 ;; returns reversed sequence.
 (dg rev (x|<seq> => <seq>))

 ;; returns concatenated sequences.
 (dg cat (x|<seq> more|... => <seq>))

 ;; returns two sequences concatenated.
 (dg cat2 (x|<seq> y|<seq> => <seq>))

 ;; subsequence of x between from and below.
 (dg sub (x|<seq> from|<int> below|<int> => <seq>))

 ;; inserts e into x below index before
 (dg ins (x|<seq> e|<any> before|<int> => <seq>))

 ;; returns new sequence with elements corresponding to those where test
 ;; returns non-false.
 (dg pick (test|<fun> x|<seq> => <seq>))

 ;; returns new sequence with elements corresponding to those where test
 ;; returns non-false.
 (dg reject (test|<fun> x|<seq> => <seq>))

 ;; returns sequence with all v's deleted from x.
 (dg del-vals (x|<seq> v|<any>  => <seq>))

 ;; returns sequence with all duplicates removed.
 (dg del-dups (x|<seq> => <seq>))


;; UNDOCUMENTED:
 (df range-check (x|<seq> i|<int>))

 (df range-check? (x|<seq> i|<int>))
 ;; (df range-error (x|<seq> i|<int>))
 (dg vals-to-str (s|<seq> => <str>))
 (dg do-key-vals (fn|<fun> key-vals|<seq>))
)

;;;;!! Implementation

;;;; Creation protocol
(dm as ((d (t< <seq>)) s|<seq> => <seq>)
  (fab-into (fab d (len s)) s))

;;;; Collection protocol

(dm key-type (x|<col> => <type>) <int>)

;;;; Sequence protocol

(dm 1st (x|<seq> => <any>) (elt x 0))

(dm 2nd (x|<seq> => <any>) (elt x 1))

(dm 3rd (x|<seq> => <any>) (elt x 2))

;; TODO: SHOULD USE BACKWARD ITERATION PROTOCOL???
(dm last (x|<seq> => <any>) (elt x (- (len x) 1)))

(dm pos (x|<seq> v => (@t? <int>))
  (find-or (fun (a) (== v a)) x #f))

(dm finds ((x <seq>) (y <seq>) => (@t? <int>))
  (rep outer ((xsi 0))
    (if (< xsi (+ (- (len x) (len y)) 1))
        (rep inner ((xi xsi) (yi 0))
          (if (and (< xi (len x)) (< yi (len y)))
              (if (== (elt x xi) (elt y yi))
                  (inner (+ xi 1) (+ yi 1))
                  (outer (+ xsi 1)))
              xsi))
        #f)))

(dm rev (x|<seq> => <seq>)
  (rep con ((seq '()) (e (enum x)))
    (if (fin? e)
        (as-copy x seq)
        (con (add seq (now e)) (nxt e)))))

;; required: rev!

(dm cat (x|<seq> ss|... => <seq>)
  (fold cat2 x ss))

(dm cat2 (x|<seq> y|<seq> => <seq>)
  (rep con-x ((seq '()) (ex (enum x)))
    (if (fin? ex)
        (rep con-y ((seq seq) (ey (enum y)))
          (if (fin? ey)
              (as-copy x (rev! seq))
              (con-y (add seq (now ey)) (nxt ey))))
        (con-x (add seq (now ex)) (nxt ex)))))

(dm sub (x|<seq> from|<int> below|<int> => <seq>)
  (rep con-x ((seq '()) ((i <int>) 0) (e (enum x)))
    (if (fin? e)
        (as-copy x (rev! seq))
        (con-x (if (if (>= i from) (< i below)) (add seq (now e)) seq)
               (+ i 1) (nxt e)))))


(dm pick (test|<fun> x|<seq> => <seq>)
  (rep con ((seq '()) (e (enum x)))
    (if (fin? e)
        (as-copy x seq)
        (let ((v (now e)))
          (con (if (test v) (add seq v) seq) (nxt e))))))

(dm reject (test|<fun> x|<seq> => <seq>)
  (pick (fun (x) (not (test x))) x))

(dm del-vals (s|<seq> x => <seq>)
  (reject (fun (e) (== e x)) s))

(dm del-dups (x|<seq> => <seq>)
  (as-copy x (rev! (fold (fun (s e) (if (mem? s e) s (pair e s))) '() x))))

(dm ins (x|<seq> v|<any> before|<int> => <seq>)
  (rep copy ((r '()) (i 0) (e (enum x)))
    (if (fin? e)
        (as-copy x r)
        (if (= i before)
            (copy (pair v r) (+ i 1) e)
            (copy (pair (now e) r) (+ i 1) (nxt e))))))

;;;; Undocumented

(dm keys (d|<seq> => <seq>)
  (below (len d)))

;; (df range-error (x|<seq> i|<int>)
;;   ;; TODO: REAL CONDITION
;;   (error "RANGE ERROR %= %=" x i))

(df range-check (x|<seq> i|<int>)
  (when (or (< i 0) (>= i (len x)))
    (range-error)))

(df range-check? (x|<seq> i|<int>)
  (and (>= i 0) (< i (len x))))

(dm add-new (c|<seq> x => <seq>)
  (unless (mem? c x) (add c x)) 
  c)

(dm vals-to-str (s|<seq> => <str>)
  (fold (fun (s e) (cat s (if (empty? s) "" " ") (to-str e))) "" s))

(dm do-key-vals (fn|<fun> key-vals|<seq>)
  (rep rep ((e (enum key-vals)))
    (unless (fin? e)
      (def key  (now e))
      (def nxts (nxt e))
      (def val  (and (not (fin? e)) (now e)))
      (fn key val) (rep (nxt e)))))

;; from range.goo
(need-implementation below)
