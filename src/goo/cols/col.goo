(use goo/boot)
(use goo/macros)
(use goo/types)
(use goo/math)

(exported
 <col>
 <col.>
 len ;; (dg len (x|<col> => <int>)) ;; in types
 (dg elt (x|<col> k|<any> => <any>))
 (dg elt-or (x|<col> k|<any> default|<any> => <any>))
 (dg elt-type (x|<col> => <type>))
 (dg elt-default (x|<col> => <any>))
 (dg key-type (x|<col> => <type>))
 (dg key-test (x|<col> => <fun>))
 (dg elts (x|<col> keys|<col> => <col>))
 (dg empty? (x|<col> => <log>))
 (dg empty ((x (t< <col>)) => <col>))
 (dg add (x|<col> y|<any> => <col>))
 (dg dup (x|<col> => <col>))
 (dg fab ((t (t< <col>)) s|<int> => <col>))
 (dg fabs ((x (t< <col>)) elts|... => <col>))
 (dg fill (x|<col> val|<any> => <col>))

 any? ;; (dg any? (f|<fun> x|<col> => <log>)) ;; in types
 (dg all? (f|<fun> x|<col> => <log>))
 (dg fold (combine|<fun> init|<any> x|<col> => <col>))
 (dg fold+ (combine|<fun> x|<col> => <col>))
 (dg find-or (f|<fun> x|<col> default => <any>))
 (dg find (f|<fun> x|<col> => <any>))
 (dg del (x|<col> key|<any> => <col>))
 (dg zap (x|<col> => <col>))
 (dg do (f|<fun> x|<col>))
 (dg mem? (x|<col> y|<any> => <log>))
 (dg keys (c|<col> => <seq>))
 (dg items (c|<col> => <seq>))

;; 3.7.1 ENUMERATION PROTOCOL
 (dc <enum> (<any>))
 (dg enum (x|<col> => <enum>))
 (dg fin? (e|<enum> => <log>))
 (dg nxt (e|<enum> => <enum>))
 (dg now (e|<enum> => <any>))
 (dg now-setter (v|<any> e|<enum>))
 (dg now-key (e|<enum> => <any>))

;; Deprecated
 (dg do-keyed (f|<fun> x|<col>))
 (dg map-keyed (f|<fun> x|<col> => <col>))
 (dg do2 (f|<fun> x|<col> y|<col>))
 (dg do3 (f|<fun> x|<col> y|<col> z|<col>))
 (dg map (f|<fun> x|<col> => <col>))
 (dg map2 (f|<fun> x|<col> y|<col> => <col>))
 (dg any2? (test|<fun> x|<col> y|<col> => <log>))
 all2? ;; (dg all2? (test|<fun> x|<col> y|<col> => <log>)) ;; in types

;; Undocumented
 (dg fab-into (x|<col> y|<col> => <col>)) 
 (dg fab-fill! (x|<col> y => <col>)) 
 (dg range-error ())
 (dg low-elt (x|<col> k|<any> => <any>))
 (dg fab-elt-setter (v|<any> x|<col> k|<any>))
 (dg as-copy (c|<col> x|<col> => <col>))
)
;;;;!! Implementation
;;;; Creation protocol
(dm as ((p (t< <col>)) x|<col> => <col>)
  (fab-into (fab p (len x)) x))

;;;; Collection protocol default implementation

(dm len (x|<col> => <int>)
  (rep count ((e (enum x)) (i 0))
    (if (fin? e) i (count (nxt e) (+ i 1)))))

(dm elt-type (x|<col> => <type>) <any>)
(dm key-type (x|<col> => <type>) <any>)
(dm key-test (x|<col> => <fun>)  ==)

;; required: elt

;; required: elt-setter

(dm empty? (c|<col> => <log>)
  (= (len c) 0))

(dm empty ((c (t< <col>)) => <col>)
  (fab c 0))

(dm elt-default (x|<col> => <any>)
  #f)

;; required: fab

(dm fab-into (dst|<col> src|<col> => <col>)
  (rep in ((ss (enum src)))
    (if (fin? ss)
        dst
        (seq (set (fab-elt dst (now-key ss)) (now ss))
             (in (nxt ss))))))

(dm fabs (c|(t< <col>) objects|... => <col>)
  (fab-into (fab c (len objects)) objects))

(dm fab-fill! (dst|<col> src => <col>)
  (rep in ((ds (enum dst)))
    (if (fin? ds)
        dst
        (seq (set (fab-elt dst (now-key ds)) src)
             (in (nxt ds))))))

(dm fill (dst|<col> val => <col>)
  (fab-fill! (fab (object-class dst) (len dst)) val))

;; TODO: FLUSH OUT BETTER
(dm dup (x|<col> => <col>)
  (as-copy x x))

(dm any? (test|<fun> c|<col> => <log>)
  (rep fnd ((e (enum c)))
    (if (fin? e)
        #f
        (or (as-log (test (now e))) (fnd (nxt e))))))

(dm all? (test|<fun> c|<col> => <log>)
  (rep fnd ((e (enum c)))
    (or (fin? e)
        (and (test (now e)) (fnd (nxt e))))))

(dm fold (combine|<fun> init c|<col> => <col>)
  (rep red ((res init) (e (enum c)))
    (if (fin? e)
        res
        (red (combine res (now e)) (nxt e)))))

(dm fold+ (combine|<fun> c|<col> => <col>)
  (def e    (enum c))
  (def init (now e))
  (rep red ((res init) (e (nxt e)))
    (if (fin? e)
        res
        (red (combine res (now e)) (nxt e)))))

(dm range-error ()
  (error "RANGE ERROR"))

(dc <elt-default> (<any>))
(dv $elt-default (new <elt-default>))

(dm find-or (f|<fun> c|<col> default => <any>)
  (rep fnd ((e (enum c)))
    (if (fin? e)
        default
        (if (f (now e)) (now-key e) (fnd (nxt e))))))

(dm find (f|<fun> c|<col> => <any>)
  (def val (find-or f c $elt-default))
  (if (== val $elt-default) (range-error) val))

;; required: del

;; required: zap

(dm do (f|<fun> c|<col>)
  (rep lop ((e (enum c)))
    (unless (fin? e)
      (f (now e)) (lop (nxt e)))))

(dm do2 (f|<fun> x|<col> y|<col>)
  (rep lop ((ex (enum x)) (ey (enum y)))
    (unless (or (fin? ex) (fin? ey))
      (f (now ex) (now ey))
      (lop (nxt ex) (nxt ey)))))

(dm map (f|<fun> c|<col> => <col>)
  (rep con ((res '()) (e (enum c)))
    (if (fin? e)
        (as-copy c (rev! res))
        (con (add res (f (now e))) (nxt e)))))

(dm map2 (f|<fun> x|<col> y|<col> => <col>)
  (rep con ((res '()) (ex (enum x)) (ey (enum y)))
    (if (or (fin? ex) (fin? ey))
        (as-copy x (rev! res))
        (con (add res (f (now ex) (now ey))) 
             (nxt ex) (nxt ey)))))

(dm do-keyed (f|<fun> c|<col>)
  (rep lop ((e (enum c)))
    (unless (fin? e)
      (f (now-key e) (now e)) (lop (nxt e)))))

(dm map-keyed (f|<fun> c|<col> => <col>)
  (rep con ((res '()) (e (enum c)))
    (if (fin? e)
        (as-copy c (rev! res))
        (con (add res (f (now-key e) (now e))) (nxt e)))))

(dm keys (c|<col> => <seq>)
  (rep con ((res '()) (e (enum c)))
    (if (fin? e)
        (rev! res)
        (con (add res (now-key e)) (nxt e)))))

(dm items (c|<col> => <seq>)
  (rep con ((res '()) (e (enum c)))
    (if (fin? e)
        (rev! res)
        (con (add res (tup (now-key e) (now e))) (nxt e)))))

(dm mem? (c|<col> x => <log>)
  (any? (fun (e) (== e x)) c))

;;;; Undocumented

(dm as-copy (c|<col> x|<col> => <col>)
  (as (object-class c) x))

(dm = (c1|<col> c2|<col> => <log>)
  (rep eq ((e1 (enum c1)) (e2 (enum c2)))
    (if (fin? e1)
        (fin? e2)
        (and (= (now e1)  (now e2))
             (eq (nxt e1) (nxt e2))))))

(dm any2? (test|<fun> x|<col> y|<col> => <log>)
  (rep fnd ((ex (enum x)) (ey (enum y)))
    (if (or (fin? ex) (fin? ey))
        #f
        (or (as-log (test (now ex) (now ey)))
            (fnd (nxt ex) (nxt ey))))))

(dm all2? (test|<fun> x|<col> y|<col> => <log>)
  (rep fnd ((ex (enum x)) (ey (enum y)))
    (or (fin? ex) (fin? ey)
        (and (test (now ex) (now ey)) 
             (fnd (nxt ex) (nxt ey))))))

(dm do3 (f|<fun> x|<col> y|<col> z|<col>)
  (rep lop ((ex (enum x)) (ey (enum y)) (ez (enum z)))
    (unless (or (fin? ex) (fin? ey) (fin? ez))
      (f (now ex) (now ey) (now ez))
      (lop (nxt ex) (nxt ey) (nxt ez)))))

(dm elt (c|<col> key|<any> => <any>) 
  (def val (elt-or c key $elt-default))
  (if (== val $elt-default) (range-error) val))

;; get this from list.goo
(need-implementation add <tab> into)

