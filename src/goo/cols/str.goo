(use goo/boot)
(use goo/macros)
(use goo/types)
(use goo/math)
(use goo/cols/col)
(use goo/cols/seq)
(use goo/cols/lst)

(exported
 (dg str (objects|...))
 (dg char->ascii (char|<chr> => <int>))
 (dv ascii-whitespaces #f)
 (dv ascii-limit #f)
 (dg str-to-num (string|<str> => (t? <num>))) ;; S48
 (dg num-to-str-base (num|<num> radix|<int> => <str>))
 (dg num-to-str (num|<num> => <str>))
 (dv *print-base* 10)
 )
;;; STRING

(dm empty ((c (t= <str>)) => <str>)
  %snul)

(dm elt-default (x|<str> => <any>)
  #\space)

(dm elt-type (x|<col> => <type>) <chr>)

(dm fab ((x (t= <str>)) s|<int> => <str>)
  (%str (%iu s)))

(dm str (objects|...)
  (fabs <str> objects))

(dm len (x|<str> => <int>)
  (%ib (%slen x)))

(dm low-elt (x|<str> i|<int> => <chr>)
  (%cb (%selt x (%iu i))))

(dm low-elt-setter (z|<chr> x|<str> i|<int>)
  (set (%selt x (%iu i)) (%cu z)))

(dm elt-or (x|<str> i|<int> default => <any>) ;; TODO: TIGHTEN RET TYPE
  (if (range-check? x i)
      (%cb (%selt x (%iu i))) ;; TODO: USE LOW-ELT
      default)) 

(dm elt-setter (z|<chr> x|<str> i|<int>)
  (range-check x i)
  (set (%selt x (%iu i)) (%cu z))) ;; TODO: USE LOW-ELT

(dm to-str (x|<str> => <str>)
  x)

(dm add (s|<str> c|<chr> => <str>)
  (cat s (to-str c)))

;;; ASCII -- S48

(dv ascii-limit 128)

(dv (ascii-chars <vec>)
  (let ((ascii-chars
	 (fill (fab <vec> ascii-limit) #f))
	(init
	 (fun (i s)
	   (rep loop ((i i) (j 0))
	     (unless (= j (len s))
	       (set (elt ascii-chars i) (elt s j))
	       (loop (+ i 1) (+ j 1)))))))
    (init 9 "\t")  ;; tab
    (init 10 "\n") ;; newline
    (init 12 "\f") ;; page
    (init 13 "\r") ;; carriage return
    (init 32 " !\"#$%&'()*+,-./0123456789:;<=>?")
    (init 64 "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_")
    (init 96 "`abcdefghijklmnopqrstuvwxyz{|}~")
    ascii-chars))

(dm ascii->char (n|<int> => <chr>)
  (or (elt ascii-chars n)
      (error "not a standard character's ASCII code: %=" n)))

(dm char->integer (char|<chr> => <int>)
  (as <int> char))

(dm integer->char (n|<int> => <chr>)
  (as <chr> n))

(dv (native-chars <lst>)
  (let ((end259 (len ascii-chars)))
    (rep loop ((i 0) (least #f) (greatest #f))
      (if (= i end259)
	  (let ((v (fill (fab <vec> (+ (- greatest least) 1)) #f)))
	    (rep loop ((i 0))
	      (if (= i end259)
		  (lst least v)
		  (let ((c (elt ascii-chars i)))
		    (if c (set (elt v (- (char->integer c) least)) i))
		    (loop (+ i 1))))))
	  (let ((c (elt ascii-chars i)))
	    (if c
		(let ((n (char->integer c)))
		  (loop (+ i 1) (if least (min least n) n)
			(if greatest (max greatest n) n)))
		(loop (+ i 1) least greatest)))))))

(dm char->ascii (char|<chr> => <int>)
  (or (elt (head (tail native-chars))
	   (- (char->integer char) (head native-chars)))
      (error "not a standard character: %=" char)))

(dv ascii-whitespaces '(32 10 9 12 13))

(dm str-to-num (string|<str> => (t? <num>)) ;; S48
  (def s 1)
  (def d 0)
  (def n 0)
  (def i 0)
  (def scale 1)
  (def length (len string))
  (def seen-decimal-point? #f)
  (def radix 10)
  (loc ((match (char)
          (if (and (< i length) (= (elt string i) char))
              (seq (set i (+ i 1)) #t)
              #f))
        (match-digit! (_)
          (esc return
            (loc ((fail!! () (return #f)))
              (if (>= i length) (fail!!))
              (def char (elt string i))
              (if (= char #\.)
                  (if seen-decimal-point?
                      (error "string->number: Two decimal points: %="
                             string)
                      (seq
                        (set seen-decimal-point? #t)
                        (set i (+ i 1))
                        (if (>= i length) (fail!!))
                        (set char (elt string i)))))
              (if (not (digit? char)) (fail!!))
              (set d (to-digit (elt string i)))
              (set i (+ i 1))
              (if seen-decimal-point?
                  (set scale (* scale radix)))
              #t)))
        (looking-at-alpha? ()
          (if (and (< i length) 
                   (alpha? (elt string i)))
              #t
              #f)))
    ;; Now we get to use all this matching machinery
    (and (or (match #\+)
         (and (match #\-) (set s -1))
         #t)
     (and (match-digit! d) (set n d))
     (rep loop ()
       (if (and (match-digit! d) (set n (+ (* n radix) d)))
           (loop)
           #t))
     (= i length) ;; consumed all chars
     (let ((f (* (as <flo> s) (/ (as <flo> n) (as <flo> scale)))))
       (if seen-decimal-point? f (trunc f))))))

(dv $digit-to-char "0123456789abcdefghijklmnopqrstuvwxyz")

(dv *print-base* 10)

(dv epsilon 0.000001)

(dm num-to-str-base (num|<int> radix|<int> => <str>)
  (def s 
    (if (< num 0) -1 1))
  (def digit-list
    (rep loop ((digit-list '()) (num (* num s)))
      (if (= num 0)
          digit-list
          (let ((digit (elt $digit-to-char (rem num radix))))
            (loop (pair digit digit-list)
                  (1st (trunc/ num radix)))))))
  (as <str> (if (< s 0)
                (pair #\- digit-list)
                (if (= num 0) "0" digit-list))))

(dm num-to-str (num|<int> => <str>)
  (num-to-str-base num *print-base*))

(dm num-to-str-base (num|<flo> radix|<int> => <str>)
  (def s (if (< num 0) -1 +1))
  (def p (* num s))
  (def string "")
  (def e (rep loop ((p p) (e 0))
           (def i (trunc p))
           (if (< (- p i) epsilon)
               (seq (set string (num-to-str-base i radix)) e)
               (loop (* p radix) (+ e 1)))))
  (def length (len string))
  (set string
       (if (= e 0)
           (cat string ".0")
           (if (= e length)
               (cat "0." string)
               (if (< e length)
                   (cat (sub string 0 (- length e)) "." 
                        (sub string (- length e) length))
                   (cat (sub "0.0000000000000" 0 (+ (- e length) 2))
                        string)))))
    (if (< s 0) (cat "-" string) string))

(dm num-to-str (num|<flo> => <str>)
  (num-to-str-base num *print-base*))

;;; SYMBOL

(dm as ((_ (t= <str>)) s|<sym> => <str>)
  (sym-name s))

(dm as ((_ (t= <sym>)) s|<str> => <sym>)
  (fab-sym s)
  ;; (def sym (elt symbols s))
  ;; (if (== sym nul)
  ;;     (set (elt symbols s) sym)
  ;;     sym)
  )

(dm < (x|<sym> y|<sym>)
  (< (sym-name x) (sym-name y)))

(dm to-str (x|<sym> => <str>)
  (sym-name x))

;;; Build a string containing the specified number of spaces.
(df string-repeat (str|<str> n|<int> => <str>)
  (if (<= n 0)
      ""
      (cat str (string-repeat str (- n 1)))))

;;; Split 'str' apart on occurrences of 'sep' (similar to Perl).
;;; TODO - Add a <str> <str> method.
(df string-split (str|<str> sep|<chr> => <lst>)
  (def match (pos str sep))
  (if (== match #f)
      (lst str)
      (pair (sub str 0 match)
            (string-split (sub str (+ match 1) (len str)) sep))))

;;; Join each string in 'strs' with 'sep' (similar to Perl).
;;; TODO - Add a <str> <chr> method.
(df string-join (strs|<lst> sep|<str> => <str>)
  (cond
    ((empty? strs) "")
    ((empty? (tail strs)) (head strs))
    (#t (cat (head strs) sep (string-join (tail strs) sep)))))

(export
  string-repeat
  string-split
  string-join
  )
