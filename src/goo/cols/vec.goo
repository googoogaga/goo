;;;; Copyright 2002, Jonathan Bachrach.  See file TERMS.

(use goo/boot)
(use goo/macros)
(use goo/math)
(use goo/types)
(use goo/cols/col)
(use goo/cols/colx)
(use goo/cols/seq)
(use goo/cols/seqx)
(use goo/cols/lst)
(use goo/cols/flat)
(use goo/cols/rep)

;; 3.7.6.3 STRETCHY-VECTOR

;;;;!! Interface
(exported
 (dc <vec> (<flat> <seq!>))
 (dg vec (elts|... => <vec>))
 )
 

;;;;!! Implementation
  (dp vec-len (x|<vec> => <int>) 0)
  (dp vec-dat (x|<vec> => <rep>) (rep-nul))

;;;; Collection protocol

(dm len (c|<vec> => <int>)
  (vec-len c))

(dm elt-or (c|<vec> i|<int> default => <any>)
  (if (range-check? c i)
      (low-elt c i)
      default))

(dm elt-setter (z c|<vec> i|<int>)
  (when (< i 0) (range-error c i))
  (set (low-elt c i) z))

(dm empty ((c (t= <vec>)) => <vec>) (new <vec>))

(dm fab ((c (t= <vec>)) s|<int> => <vec>)
  (def dat (rep-fab (power-of-two-ceiling s) #f))
  (new <vec> vec-len s vec-dat dat))

;;;; Sequence protocol

;; TODO: HAVE THIS FALL OUT OF PROTOCOL
(dm cat! (x|<vec> more|... => <vec>)
  (for ((s more))
    (for ((e s))
      (add! x e)))
  x)

(dm vec (elts|... => <vec>)
  (app fabs <vec> elts))

(dm push! (c|<vec> x => <vec>)
  (add! c x))

(dm pop! (c|<vec> => (tup <vec> <any>))
  (def new-len (- (len c) 1))
  (def x       (low-elt c new-len))
  (set (len c) new-len)
  (tup c x))

;; TODO: QUESTIONABLE SYNTAX
(dm to-str (x|<vec> => <str>) 
  (cat "#[" (vals-to-str x) "]"))


(dm add! (c|<vec> x => <vec>)
  (set (low-elt c (len c)) x)
  c)

(dm len/fill-setter (new-len|<int> c|<vec> default)
  (def dat (vec-dat c))
  (if (> new-len (rep-len dat))
      (let ((new-data (rep-fab (power-of-two-ceiling new-len) default)))
        (rep-into! new-data dat)
        (set (vec-len c) new-len)
        (set (vec-dat c) new-data))
      (if (< new-len (len c))
          (let ((old-len (len c)))
            (set (vec-len c) new-len)
            (rep fill ((i|<int> new-len))
              (and (< i old-len)
                   (set (rep-elt dat i) default)
                   (fill (+ i 1)))))
          (set (vec-len c) new-len))))

(dm len-setter (new-len|<int> c|<vec>)
  (set (len/fill c (elt-default c)) new-len))

(dm zap! (c|<vec> => <vec>) (set (len c) 0) c)

(dm low-elt (x|<vec> i|<int> => <any>)
  (rep-elt (vec-dat x) i))

(dm low-elt-setter (z x|<vec> i|<int>)
  (when (>= i (len x))
    (set (len x) (+ i 1)))
  (set (rep-elt (vec-dat x) i) z))
