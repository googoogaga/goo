(use goo/boot)
(use goo/macros)
(use goo/types)
(use goo/math)
(use goo/cols/col)
(use goo/cols/colx)
(use goo/cols/seq)
(use goo/cols/seqx)

;; 3.7.5 LISTS

;;;;!! Interface

(exported
 ;; defined in boot
 <lst> head head-setter tail tail-setter nil
 ;; Alias for <lst>
 (dv <list> <lst>)
 (dg lst (elts|... => <lst>))
 
 ;; Alias for list
 (dv list lst)

 (dg pair (x|<any> y|<lst> => <lst>))

 (dg push (l|<lst> x|<any> => <lst>))
 (dg pop (l|<lst> => (tup new-col|<lst> value)))

;; undocumented
 (dg assqn (x l|<lst> pos|<int> => <any>))
 (dg assq (x l|<lst> => <any>))

)

;;;;!! Implementation

;;;; Creation protocol

;; TODO: DO THIS IN GENERAL FOR AS
(dm as ((p (t= <lst>)) x|<lst> => <lst>) x)

;;;; Collection protocol
(dm len (x|<lst> => <int>)
  (rep sum (((count <int>) 0) ((x <lst>) x))
    (if (empty? x) count (sum (+ count 1) (tail x)))))

(dm elt-or (x|<lst> key|<int> default => <any>)
  (rep fnd (((count <int>) 0) ((x <lst>) x))
    (if (empty? x)
        default
        (if (== count key)
            (head x)
            (fnd (+ count 1) (tail x))))))

(dm elt-setter (z x|<lst> key|<int>)
  (rep fnd (((count <int>) 0) ((x <lst>) x))
    (if (empty? x)
        (range-error)
        (if (== count key)
            (set (head x) z)
            (fnd (+ count 1) (tail x))))))

(dm empty? (c|<lst> => <log>) (== c (empty (object-class c))))

(dm empty ((c (t= <lst>)) => <lst>) '())

(dm fab ((t (t= <lst>)) s|<int> => <lst>)
  (rep fab ((i|<int> s) (res|<lst> (empty t)))
    (if (> i 0)
        (fab (- i 1) (new t tail res))
        res)))

(dm fabs ((c (t< <lst>)) objects|... => <lst>)
  (rep build ((index|<int> (- (len objects) 1)) (result|<lst> (empty c)))
    (if (< index 0)
        result
        (build (- index 1) 
               (new c head (elt objects index) tail result)))))

;;;; Iteration protocol for lists
(dc <lst-enum> (<enum>))
(dp %dat (x|<lst-enum> => <lst>))
(dp %key (x|<lst-enum> => <int>) 0)
(dm enum (x|<lst> => <lst-enum>)
  (new <lst-enum> %dat x))
(dm fin? (e|<lst-enum> => <log>)
  (empty? (%dat e)))
(dm nxt (e|<lst-enum> => <lst-enum>)    
  (renew e %key (+ (%key e) 1) %dat (tail (%dat e))))
(dm now (e|<lst-enum> => <any>)
  (head (%dat e)))
(dm now-setter (v|<any> e|<lst-enum>)
  (set (head (%dat e)) v))
(dm now-key (e|<lst-enum> => <int>)
  (%key e))

;;;; Sequence protocol
(dm add (c|<lst> x => <lst>)
  (pair x c))

(dm last (x|<lst> => <any>)
  (rep fnd ((x x) (px x))
    (if (empty? x) (head px) (fnd (tail x) x))))

(dm rev! (c|<lst> => <lst>)
  (rep loop ((l c) (r (empty (object-class c))))
    (if (empty? l)
        r
        (let ((t (tail l)))
          (set (tail l) r)
          (loop t l)))))

(dm cat! (x|<lst> more|... => <lst>)
  (loc ((connect (x|<lst> y|<lst> => <lst>)
          ;; connect x to y and return the last elem of the list
          (if (empty? y)
              x
              (seq (set (tail x) y)
                   (rep find-tail ((p|<lst> y))
                     (if (empty? (tail p))
                         p
                         (find-tail (tail p))))))))
    (def result (lst #f))
    (def cur result)
    (set cur (connect cur (as <lst> x)))
    (for ((x more))
      (set cur (connect cur (as <lst> x))))
    (tail result)))

;;;; List protocol
(dm lst (objects|... => <lst>)
  (app fabs <lst> objects))

(dm pair (h t|<lst> => <lst>)
  (new <lst> head h tail t))

(dm push (c|<lst> x => <lst>)
  (pair x c))

(dm pop (c|<lst> => (tup new-c|<lst> value))
  (tup (tail c) (head c)))

;;;; Misc other stuff
(dm to-str (x|<lst> => <str>)
  (cat "(" (vals-to-str x) ")"))



;;;; Not documented
;; TODO: CHANGE ORDER OF ARGS LIKE MEM?
(dm assq (x l|<lst> => <any>)
  (if (empty? l)
      #f
      (if (== x (head (head l)))
          (head l)
          (assq x (tail l)))))

(dm assqn (x l|<lst> pos|<int> => <any>)
  (if (empty? l)
      #f
      (if (== x (elt (head l) pos))
          (head l)
          (assqn x (tail l) pos))))

