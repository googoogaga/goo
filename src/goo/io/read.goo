;;;; Copyright 2002, Jonathan Bachrach.  See file TERMS.
;;  Copyright (c) 1993, 1994 Richard Kelsey and Jonathan Rees.  See file COPYING.
;;  A little Scheme reader.
;;  Nonstandard things used:
;;   Ascii stuff: char->ascii, ascii->char, ascii-whitespaces, ascii-limit
;;     (for dispatch table; portable definitions in alt/ascii.scm)
;;   reverse-list->string  -- ok to define as follows:
;;     (define (reverse-list->string l n)
;;       (list->string (reverse l)))
;;   make-immutable! -- ok to define as follows:
;;     (define (make-immutable! x) x)
;;   signal (only for use by reading-error; easily excised)

(use goo/boot)
(use goo/macros)
(use goo/runtime)
(use goo/types)
(use goo/math)
(use goo/io/port)
(use goo/cols)

;; READ

(dm read (port|<in-port> => <any>)
  ;; (put out #\a) (newline out)
  (rep loop ()
    (def form (sub-read port))
    (if (not (reader-token? form))
        form
        (if (== form $close-paren)
            (warn "discarding extraneous right parenthesis")
            (loop))
        ;; (reading-error port (tail form))
        )))

(dm read-from-string (x|<str> => <any>)
  (with-port (port (open <str-in-port> x)) (read port)))

(dm sub-read-carefully (port|<port> => <any>)
  ;; (put out #\b) (newline out)
  (def form (sub-read port))
  (if (eof-object? form)
      (reading-error port "unexpected end of file")
      (if (reader-token? form)
          (reading-error port (tail form))
          form)))

(dc <reader-token> (<any>))
  (dp token-message (x|<reader-token> => <str>))

(dm make-reader-token (message => <any>)
  (new <reader-token> token-message message))

(dm reader-token? (form => <log>)
  (isa? form <reader-token>))

(dv $close-paren (make-reader-token "unexpected right parenthesis"))

(dv $dot (make-reader-token "unexpected \" . \""))

;;  Main dispatch

(dm sub-read (port|<port> => <any>)
  ;; (put out #\c) (newline out)
  (def c (get port))
  (if (eof-object? c)
      (seq;; (put out #\m) (put out c) (newline out) 
       c
       )
      ((elt *read-dispatch-vector* (char->ascii c)) c port)))

(dv *read-dispatch-vector* 
  (fill! (fab <vec> ascii-limit)
	 (fun (c port) (reading-error port "illegal character read" c))))

(dv *read-terminating?-vector* (fill! (fab <vec> ascii-limit) #t))

(dm set-standard-syntax! (char|<chr> terminating? reader)
  (set (elt *read-dispatch-vector* (char->ascii char)) reader)
  (set (elt *read-terminating?-vector* (char->ascii char)) terminating?))

(let ((sub-read-whitespace (fun (c port) (sub-read port))))
  (do (fun (c) (set (elt *read-dispatch-vector* c) sub-read-whitespace))
      ascii-whitespaces))

(df sub-read-constituent (c port)
  ;; (put out #\h) (newline out)
  (parse-token (sub-read-token c port) port))

(let ((str10496
       (cat "!$%&*+-./0123456789:<=>?@^_~ABCDEFGHIJKLM"
            "NOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")))
  (do (fun (c) (set-standard-syntax! c #f sub-read-constituent))
      str10496))

;; Usual read macros

(dm set-standard-read-macro! (char|<chr> terminating? proc|<fun>)
  (set-standard-syntax! char terminating? proc))

(dm sub-read-vertical (c|<chr> port|<port> => <any>)
  (parse-token "|" port))

(set-standard-read-macro! #\| #t sub-read-vertical)

(dv $vert-sym   (as <sym> "|"))
(dv $vert-proxy (lst "vert-proxy"))

(df sub-read-list-eof-error (port|<port>)
  (reading-error port "end of file inside list -- unbalanced parentheses"))

(dm sub-read-list (c|<chr> port|<port> => <any>)
  ;; (put out #\d) (newline out)
  (def form (sub-read port))
  (cond ((eof-object? form)     (sub-read-list-eof-error port))
        ((== form $close-paren) '())
        (#t
         (rep read-next ((c|<chr> c) (prev form) (form (sub-read port)))
           (def prev (if (== prev $vert-proxy) $vert-sym prev))
           (cond ((eof-object? form)
                  (sub-read-list-eof-error port))
                 ((== form $close-paren) 
                  (lst prev))
                 ((== form $vert-sym)    
                  (let ((next (sub-read-carefully port)))
                    (pair (lst prev next) (sub-read-list c port))))
                 (#t
                  (pair prev (read-next c form (sub-read port)))))))))

;; (dm sub-read-list (c|<chr> port|<port> => <any>)
;;   ;; (put out #\d) (newline out)
;;   (let ((form (sub-read port)))
;;     (if (eof-object? form)
;;      (reading-error 
;;       port "end of file inside list -- unbalanced parentheses")
;;      (if (== form $close-paren)
;;          '()
;;          (pair form (sub-read-list c port))))))

(set-standard-read-macro! #\( #t sub-read-list)

(set-standard-read-macro! #\) #t (fun (c port) $close-paren))

(set-standard-read-macro!
  #\' #t (fun (c port) (lst 'quote (sub-read-carefully port))))

(set-standard-read-macro!
  #\` #t (fun (c port) (lst 'quasiquote (sub-read-carefully port))))

(set-standard-read-macro!
  #\, #t
  (fun (c port)
    (def next    (peek port))
    (def keyword (if (eof-object? next)
                     (reading-error port "end of file after ,")
                     (if (= next #\@)
                         (seq (get port)
                              'unquote-splicing)
                         'unquote)))
    (lst keyword (sub-read-carefully port))))

(dv $string-escape-chars
  (let ((vec (fill! (fab <vec> ascii-limit) #f)))
    (set (elt vec (as <int> #\t)) #\tab)
    (set (elt vec (as <int> #\f)) #\page)
    (set (elt vec (as <int> #\r)) #\return)
    (set (elt vec (as <int> #\n)) #\newline)
    (as <tup> vec)))

(df read-string-literal (c port)
  ;; (put out #\g) (newline out)
  (rep loop ((l '()) (i 0))
    (def c (get port))
    (if (eof-object? c)
          (reading-error port "end of file within a string")
          (if (= c #\\)
              (let ((c (get port)))
                (if (eof-object? c)
                    (reading-error port "end of file within a string")
                    (if (or (= c #\\) (= c #\"))
                        (loop (pair c l) (+ i 1))
                        (let ((ec (elt $string-escape-chars (as <int> c))))
                          (if ec
                              (loop (pair ec l) (+ i 1))
                              (reading-error
                               port "invalid escaped character in string" 
                               c))))))
              (if (= c #\")
                  (reverse-list->string l i)
                  (loop (pair c l) (+ i 1)))))))

(set-standard-read-macro!
  #\" #t read-string-literal)

(set-standard-read-macro!
  #\; #t (fun (c port) (gobble-line port) (sub-read port)))

(dm gobble-line (port|<port>)
  (rep loop ()
    (def c (get port))
    (if (eof-object? c) c (if (= c #\newline) #f (loop)))))

(dv *sharp-macros* '())

(dm define-sharp-macro (c proc)
  (set *sharp-macros* (pair (lst c proc) *sharp-macros*)))

(set-standard-read-macro!
  #\# #f
  (fun (c port)
    (def c (peek port))
    (def c (if (eof-object? c)
               (reading-error port "end of file after #")
               (to-lower c)))
    (def probe (assq c *sharp-macros*))
    (if probe
        ((head (tail probe)) c port)
        (reading-error port "unknown # syntax" c))))

(define-sharp-macro #\f (fun (c port) (get port) #f))

(define-sharp-macro #\t (fun (c port) (get port) #t))

(define-sharp-macro #\| (fun (c port) (get port) $vert-proxy))

;; TODO: ASSQ

(dv $char-long-names
  '((tab #\tab) (page #\page)
    (return #\return) (newline #\newline)
    (space #\space)))

(define-sharp-macro
  #\\
  (fun (c port)
    (get port)
    (def c (peek port))
    (if (eof-object? c)
        (reading-error port "end of file after #\\")
        (if (alpha? c)
            (let ((name (sub-read-carefully port)))
              (if (= (len (as <str> name)) 1)
                  c
                  (let ((temp (assq name $char-long-names)))
                    (if temp
                        (head (tail temp));; Goo => syntax
                        (reading-error port "unknown #\\ name" name)))))
            (get port)))))

(define-sharp-macro
  #\(
  (fun (c port)
    (get port)
    (as <tup> (sub-read-list c port))))

(let ((number-sharp-macro
        (fun (c port)
          (def string (sub-read-token #\# port))
          (or (str-to-num string)
              (reading-error port "unsupported number syntax" string)))))
  (do (fun (c) (define-sharp-macro c number-sharp-macro))
      '(#\b #\o #\d #\x #\i #\e)))

;; Tokens

(dm sub-read-token (c|<chr> port|<port> => <any>)
  ;; (put out #\e) (put out c) (newline out)
  (rep loop ((l (lst (preferred-case c))) (n 1))
    (def c (peek port))
    (if (or (eof-object? c)
            (elt *read-terminating?-vector* (char->ascii c)))
        (reverse-list->string l n)
        (loop (pair (preferred-case (get port)) l) (+ n 1)))))

;; TODO: MEM? WITH TEST

(dm parse-token (string|<str> port|<port> => <any>)
  ;; (put out #\f) (newline out)
  (if (let ((c (elt string 0)))
        (or (digit? c)
            (= c #\+)
            (= c #\-)
            (= c #\.)))
      (let ((maybe-number (str-to-num string)))
        (if maybe-number
            maybe-number
            (if (any? (fun (x) (= string x)) $strange-symbol-names)
                (as <sym> (make-immutable! string))
                (if (= string ".")
                    $dot
                    (reading-error port "unsupported number syntax" string)))))
      (seq ;; (put out #\n) (newline out)
       (as <sym> (make-immutable! string)))))
;;       (let ((vert-pos (pos string #\|)))
;;      (if (and vert-pos (> (len string) 1)) ;; typed variable?
;;          (if (= vert-pos 0)
;;              (reading-error port "Vertical bar at beginning of symbol" string)
;;              `(,(as <sym> (sub string 0 vert-pos)) 
;;                ,(as <sym> (sub string (+ vert-pos 1) (len string)))))
;;          (seq ;; (put out #\n) (newline out)
;;           (as <sym> (make-immutable! string)))))

(dv $strange-symbol-names 
  '("+" "-" "..."
    "1st" "2nd" "3rd" ;; Seq Support
    "1+" "1-"         ;; Only for S&ICP support
    "->"))            ;; Only for JAR's thesis

(dv preferred-case 
  (if (= (elt (as <str> 't) 0) #\T) to-upper to-lower))

;; Reader errors

(dm reading-error (port|<port> message|<str> irritants|...)
  (error (cat message ": %=")  ;; was: app(...)
         (cat irritants (lst port))))

(dm warn (string|<str> irritants-and-port|...)
  ;; TODO: TURN BACK ON
  ;; (app sig string irritants-and-port)
  #f
  )
  ;; msg-string: string,
  ;;  msg-arguments: irritants-and-port

(dm reverse-list->string (l|<lst> n|<int> => <str>)
  (as <str> (rev! l)))

(dm make-immutable! (x) x)

(export
  $char-long-names
  read
  read-from-string)
