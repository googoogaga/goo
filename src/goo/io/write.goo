;;  -*- Mode: Scheme; Syntax: Scheme; Package: Scheme; -*-
;;  Copyright (c) 1993, 1994 Richard Kelsey and Jonathan Rees.  See file COPYING.
;;  Copyright (c) 2001 Jonathan Bachrach

(use boot)
(use macros)
(use runtime)
(use read)

(dv *max-print-depth*  4)

(dv *max-print-length* 12)

(dm as-binding-name (name) 
  (as <str> name))

(ds (maybe-write-proto-name (,port ,x ,proto) ,@body)
  `(if (== ,x ,proto)
       (write-string ,port (as-binding-name ',proto))
       (seq ,@body)))
     
(dm do-display ((port <output-port>) (x <str>) (d <int>) (recur <fun>))
  (maybe-write-proto-name (port x <str>)
    (write-string port x)))

(dm do-display ((port <output-port>) (x <chr>) (d <int>) (recur <fun>))
  (maybe-write-proto-name (port x <chr>)
    (write-char port x)))

(dm do-display ((port <output-port>) x (d <int>) (recur <fun>))
  (recurring-write port x d recur))

(dm display ((port <output-port>) x)
  (rep recur ((x x) (d -1))
    (if (>= d *max-print-depth*)
	(write-string port "*")
	(do-display port x (+ d 1) recur))))

(dm write-to-string (x => <str>)
  (call-with-string-output-port (rcurry write x)))

(dm write ((port <output-port>) x)
  (rep recur ((x x) (d -1))
    (if (>= d *max-print-depth*)
	(write-string port "*")
	(recurring-write port x (+ d 1) recur))))

(dm writeln ((port <output-port>) x)
  (write port x) (newline port))

(dm recurring-write ((port <output-port>) (x <lst>) (d <int>) (recur <fun>))
  (if (empty? x)
      (write-string port "()")
      (maybe-write-proto-name (port x <lst>)
        (write-list port x d recur))))

(dm recurring-write ((port <output-port>) (x <vec>) (d <int>) (recur <fun>))
  (maybe-write-proto-name (port x <vec>)
    (write-vector port x d recur)))

(dm recurring-write ((port <output-port>) (x <map>) (d <int>) (recur <fun>))
  (maybe-write-proto-name (port x <map>)
    (write-map port x d recur)))

(dm recurring-write ((port <output-port>) (x <log>) (d <int>) (recur <fun>))
  (if x
      (write-boolean port 't)
      (write-boolean port 'f)))

(dm recurring-write ((port <output-port>) (x <sym>) (d <int>) (recur <fun>))
  (maybe-write-proto-name (port x <sym>)
    (write-string port (as <str> x))))

(dm recurring-write ((port <output-port>) (x <loc>) (d <int>) (recur <fun>))
  (maybe-write-proto-name (port x <loc>)
    (write-string port "&0x")
    (num-to-str (%ib (%lu x)) 16)))

(dm recurring-write ((port <output-port>) (x <num>) (d <int>) (recur <fun>))
  (if (== x <num>)
      (write-string port (as-binding-name "<num>"))
      (write-number port x)))

(dm recurring-write ((port <output-port>) (x <str>) (d <int>) (recur <fun>))
  (maybe-write-proto-name (port x <str>)
    (write-string-literal port x)))

(dm recurring-write ((port <output-port>) (x <chr>) (d <int>) (recur <fun>))
  (maybe-write-proto-name (port x <chr>)
    (write-char-literal port x)))

(dm write-boolean ((port <output-port>) mumble)
  (write-char port #\#)
  (write port mumble))

(dm write-number ((port <output-port>) (x <num>))
  (maybe-write-proto-name (port x <int>)
    (maybe-write-proto-name (port x <flo>)
      (write-string port (num-to-str x 10)))))

(dm write-char-literal ((port <output-port>) x)
  (let ((probe (character-name x)))
    (write-string port "#\\")
    (if probe
	(write port probe)
	(write-char port x))))

(dm character-name ((char <chr>) => <any>)
  (let ((assoc (assqn char $char-long-names 1)))
    (and assoc (1st assoc))))

(dm write-string-literal ((port <output-port>) x)
  (write-char port #\")
  (let ((len (len x)))
    (rep loop ((i 0))
      (if (= i len)
	  (write-char port #\")
	  (let ((c (elt x i)))
	    (if (or (= c #\\) (= c #\"))
		(write-char port #\\))
	    (write-char port c)
	    (loop (+ i 1)))))))

(dm write-list ((port <output-port>) (x <lst>) (d <int>) (recur <fun>))
  (if (quotation? x)
      (seq (write-char port #\')
	   (recur (head (tail x)) d))
      (seq (write-char port #\()
	   (recur (head x) d)
	   (rep loop ((l (tail x)) (n 1))
	     (unless (empty? l)
	       (if (>= n *max-print-length*)
		   (write-string port " ...")
		   (seq (write-char port #\space)
			(recur (head l) d)
			(loop (tail l) (+ n 1))))))
	   (write-char port #\) ))))

(dm quotation? (x => <log>)
  (and (isa? x <lst>) 
       (== (head x) 'quote)
       (isa? (tail x) <lst>)
       (empty? (tail (tail x)))))

(dm write-vector ((port <output-port>) (x <vec>) (d <int>) (recur <fun>))
  (write-string port "#(")
  (let ((z (len x)))
    (when (> z 0)
      (recur (elt x 0) d)
      (rep loop ((i 1))
	(if (>= i *max-print-length*)
	    (write-string port " ...")
	    (unless (>= i z)
	      (write-char port #\space)
	      (recur (elt x i) d)
	      (loop (+ i 1)))))))
  (write-char port #\)))

(dm write-map ((port <output-port>) (x <map>) (d <int>) (recur <fun>))
  (let ((name (object-name x)))
    (if name
	(write-string port (as-binding-name name))
	(seq (write-string port "#[")
	     (let ((owner (object-name (1st (object-parents x)))))
	       (display port owner)
	       (lab blow
	         (for (((tup key val) x) (i (from 0)))
		   (when (>= i *max-print-length*)
		     (write-string port " ...") (blow #f))
		   (write-char port #\space)
		   (recur key d)
		   (write-string port ": ")
		   (recur val d))))
	     (write-char port #\])))))

(dm recurring-write
    ((port <output-port>) (x <input-port>) (d <int>) (recur <fun>))
  (write-string port "#{Input-port}"))

(dm recurring-write
    ((port <output-port>) (x <output-port>) (d <int>) (recur <fun>))
  (write-string port "#{Output-port}"))

;; TODO: CHANGE C IMPLEMENTATION

(dv *glo-name?* #f)

(dm object-name (x)
  (let ((name (or (%binding-name x) (and *glo-name?* (env-object-name x)))))
    (and name (as <str> name))))

(dm write-params ((port <output-port>) (x <fun>) (recur <fun>))
  (let ((names (fun-names x)))
    (write-char port #\()
    (let ((names (fun-names x)))
      (for ((i (from 0)) (spec (fun-specs x)) (first? (first-then #t #f)))
        (unless first? (write-char port #\space))
	(if (empty? names)
	    (write port spec)
	    (format port "(%s %=)" (as <str> (elt names i)) spec))))
    (let ((value (fun-value x)))
      (unless (or (not value) (== value <any>))
	(format port " => %=" value)))
    (write-char port #\))))

(dm write-fun-guts ((port <output-port>) (x <fun>) (name <str>) (recur <fun>))
  (write-string port "#{")
  (write-string port name)
  (let ((name (fun-name x)))
    (and name (seq (write-char port #\space) 
		   (write-string port (as <str> name)))))
  (write-char port #\space)
  (write-params port x recur)
  (write-string port "}"))

(dm recurring-write ((port <output-port>) (x <gen>) (d <int>) (recur <fun>))
  (maybe-write-proto-name (port x <gen>)
    (write-fun-guts port x "Gen" recur)))

(dm recurring-write ((port <output-port>) (x <met>) (d <int>) (recur <fun>))
  (maybe-write-proto-name (port x <met>)
    (write-fun-guts port x "Met" recur)))

(dm recurring-write ((port <output-port>) (x <slot>) (d <int>) (recur <fun>))
  (write-string port "#{Slot ")
  (recur (slot-getter x) d)
  (write-string port "}"))

(dm recurring-write ((port <output-port>) x (d <int>) (recur <fun>))
  (let ((name (object-name x)))
    (if name
	(write-string port (as-binding-name name))
	(let ((owner (object-name (1st (object-parents x)))))
	  (write-string port "#{")
	  (display port owner)
	  (lab blow
	    (for ((slot (object-slots x)) (i (from 0)))
	      (when (>= i *max-print-length*)
		(write-string port " ...") (blow #f))
	      (let ((getter (slot-getter slot)))
		(write-char port #\space)
		(display port (fun-name getter))
		(write-string port ": ")
		(recur (getter x) d))))
	  (write-string port "}")))))

(dm recurring-write
    ((port <output-port>) (x (eof-object)) (d <int>) (recur <fun>))
  (write-string port "#{End-of-file}"))

(dm format ((port <output-port>) (message <str>) (arguments ...))
  (let ((found-percent?         #f)
	((argument-index <int>) 0)
	(num-arguments          (len arguments)))
    (loc ((arg ((char <chr>) (class <any>) => <any>)
	    (let ((current-index argument-index))
	      (set argument-index (+ argument-index 1))
	      (assert (< current-index num-arguments)
		      "Too few arguments for format string %=: %="
		      message arguments)
	      (let ((argument (elt arguments current-index)))
		(assert (or (== class <any>) (isa? argument class))
		  "Format argument for directive '%%%c' not of class %s: %="
		  char class argument)
		argument))))
      (do (fun ((c <chr>))
	    (if found-percent?
		(seq (select (as-uppercase c)
		       ((#\D) (write-string port (num-to-str (arg c <num>))))
		       ((#\B) (write-string port (num-to-str (arg c <int>) 2)))
		       ((#\O) (write-string port (num-to-str (arg c <int>) 8)))
		       ((#\X) (write-string port (num-to-str (arg c <int>) 16)))
		       ((#\C) (write-char port (arg c <chr>)))
		       ((#\S) (display port (arg c <any>)))
		       ((#\=) (write port (arg c <any>)))
		       ((#\%) (write-char port #\%))
		       (#t
			 (error "Invalid format directive '%s' in \"%s\""
				c message)))
		     (set found-percent? #f))
		(if (== c #\%)
		    (set found-percent? #t)
		    (write-char port c))))
	  message))
    (assert (not found-percent?)
	    "Incomplete format directive in \"%s\"" message)))
  
;; (set *debug-tables?* #t)

(need-implementation
  env-object-name)

(export
  format
  display
  write
  writeln
  write-to-string)
