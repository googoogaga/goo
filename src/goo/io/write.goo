;  Copyright (c) 1993, 1994 Richard Kelsey and Jonathan Rees. 
;;  See file COPYING.
;;  Copyright (c) 2001 Jonathan Bachrach

(use boot)
(use macros)
(use runtime)
(use read)

(ddv *max-print-depth*  4)

(ddv *max-print-length* 12)

(dm as-binding-name (name) 
  (as <str> name))

(dm do-display ((port <output-port>) (x <str>) (d <int>) (recur <fun>))
  (write-string port x))

(dm do-display ((port <output-port>) (x <chr>) (d <int>) (recur <fun>))
  (write-char port x))

(dm do-display ((port <output-port>) x (d <int>) (recur <fun>))
  (recurring-write port x d recur))

(dm display ((port <output-port>) x)
  (rep recur ((x x) (d -1))
    (if (>= d *max-print-depth*)
	(write-string port "*")
	(do-display port x (+ d 1) recur))))

(dm write-to-string (x => <str>)
  (call-with-string-output-port (rcurry write x)))

(dm write ((port <output-port>) x)
  (rep recur ((x x) (d -1))
    (if (>= d *max-print-depth*)
	(write-string port "*")
	(recurring-write port x (+ d 1) recur))))

(dm writeln ((port <output-port>) x)
  (write port x) (newline port))

(dm recurring-write ((port <output-port>) (x <lst>) (d <int>) (recur <fun>))
  (if (empty? x)
      (write-string port "()")
      (write-list port x d recur)))

(dm recurring-write ((port <output-port>) (x <flat>) (d <int>) (recur <fun>))
  (write-flat port x d recur))

(dm recurring-write ((port <output-port>) (x <map>) (d <int>) (recur <fun>))
  (write-map port x d recur))

(dm recurring-write ((port <output-port>) (x <log>) (d <int>) (recur <fun>))
  (if x
      (write-boolean port 't)
      (write-boolean port 'f)))

(dm recurring-write ((port <output-port>) (x <sym>) (d <int>) (recur <fun>))
  (write-string port (as <str> x)))

(dm recurring-write ((port <output-port>) (x <loc>) (d <int>) (recur <fun>))
  (write-string port "&0x")
  (num-to-str (%ib (%lu x)) 16))

(dm recurring-write ((port <output-port>) (x <num>) (d <int>) (recur <fun>))
  (if (== x <num>)
      (write-string port (as-binding-name "<num>"))
      (write-number port x)))

(dm recurring-write ((port <output-port>) (x <str>) (d <int>) (recur <fun>))
  (write-string-literal port x))

(dm recurring-write ((port <output-port>) (x <chr>) (d <int>) (recur <fun>))
  (write-char-literal port x))

(dm write-boolean ((port <output-port>) mumble)
  (write-char port #\#)
  (write port mumble))

(dm write-number ((port <output-port>) (x <num>))
  (write-string port (num-to-str x 10)))

(dm write-char-literal ((port <output-port>) x)
  (let ((probe (character-name x)))
    (write-string port "#\\")
    (if probe
	(write port probe)
	(write-char port x))))

(dm character-name ((char <chr>) => <any>)
  (let ((assoc (assqn char $char-long-names 1)))
    (and assoc (1st assoc))))

(dm write-string-literal ((port <output-port>) x)
  (write-char port #\")
  (let ((len (len x)))
    (rep loop ((i 0))
      (if (= i len)
	  (write-char port #\")
	  (let ((c (elt x i)))
	    (if (or (= c #\\) (= c #\"))
		(write-char port #\\))
	    (write-char port c)
	    (loop (+ i 1)))))))

(dm write-list ((port <output-port>) (x <lst>) (d <int>) (recur <fun>))
  (if (quotation? x)
      (seq (write-char port #\')
	   (recur (head (tail x)) d))
      (seq (write-char port #\()
	   (recur (head x) d)
	   (rep loop ((l (tail x)) (n 1))
	     (unless (empty? l)
	       (if (>= n *max-print-length*)
		   (write-string port " ...")
		   (seq (write-char port #\space)
			(recur (head l) d)
			(loop (tail l) (+ n 1))))))
	   (write-char port #\) ))))

(dm quotation? (x => <log>)
  (and (isa? x <lst>) 
       (== (head x) 'quote)
       (isa? (tail x) <lst>)
       (empty? (tail (tail x)))))

(dm write-flat ((port <output-port>) (x <flat>) (d <int>) (recur <fun>))
  (if (isa? x <vec>)
      (write-string port "#(")
      (seq
        (write-string port "$$")
        (display port (class-name (object-class x)))
        (write-string port "(")))
  (let ((z (len x)))
    (when (> z 0)
      (recur (elt x 0) d)
      (rep loop ((i 1))
	(if (>= i *max-print-length*)
	    (write-string port " ...")
	    (unless (>= i z)
	      (write-char port #\space)
	      (recur (elt x i) d)
	      (loop (+ i 1)))))))
  (write-char port #\)))

(dm write-map ((port <output-port>) (x <map>) (d <int>) (recur <fun>))
  (write-string port "#[")
  (display port (class-name (object-class x)))
  (lab blow
    (for (((tup key val) x) (i (from 0)))
      (when (>= i *max-print-length*)
        (write-string port " ...") (blow #f))
      (write-char port #\space)
      (recur key d)
      (write-string port ": ")
      (recur val d)))
  (write-char port #\]))

(dm recurring-write
    ((port <output-port>) (x <input-port>) (d <int>) (recur <fun>))
  (write-string port "#{Input-port}"))

(dm recurring-write
    ((port <output-port>) (x <output-port>) (d <int>) (recur <fun>))
  (write-string port "#{Output-port}"))

;; TODO: CHANGE C IMPLEMENTATION

(dm write-params ((port <output-port>) (x <fun>) (recur <fun>))
  (let ((names (fun-names x)))
    (write-char port #\()
    (let ((names (fun-names x)))
      (for ((i (from 0)) (spec (fun-specs x)) (first? (first-then #t #f)))
        (unless first? (write-char port #\space))
	(if (empty? names)
	    (write-type port spec)
	    (seq (format port "(%s " (as <str> (elt names i)))
                 (write-type port spec)
                 (write-char port #\))))))
    (let ((value (fun-value x)))
      (unless (or (not value) (== value <any>))
	(format port " => ") (write-type port value)))
    (write-char port #\))))

(dm write-fun-guts ((port <output-port>) (x <fun>) (name <str>) (recur <fun>))
  (write-string port "#{")
  (write-string port name)
  (let ((name (fun-name x)))
    (and name (seq (write-char port #\space) 
		   (write-string port (as <str> name)))))
  (write-char port #\space)
  (write-params port x recur)
  (write-string port "}"))

(dm recurring-write ((port <output-port>) (x <gen>) (d <int>) (recur <fun>))
  (write-fun-guts port x "Gen" recur))

(dm recurring-write ((port <output-port>) (x <met>) (d <int>) (recur <fun>))
  (write-fun-guts port x "Met" recur))

(dm recurring-write ((port <output-port>) (x <class>) (d <int>) (recur <fun>))
  (write-string port "#{Class ")
  (write-string port (as <str> (class-name x)))
  (write-string port " ")
  (recur (map class-name (class-direct-parents x)) d)
  (write-string port "}"))

(dm recurring-write 
    ((port <output-port>) (x <singleton>) (d <int>) (recur <fun>))
  (write-string port "#{T= ")
  (recur (type-object x) d)
  (write-string port "}"))

(dm recurring-write 
    ((port <output-port>) (x <subclass>) (d <int>) (recur <fun>))
  (write-string port "#{T< ")
  (write-type port (type-class x))
  (write-string port "}"))

(dm recurring-write 
    ((port <output-port>) (x <union>) (d <int>) (recur <fun>))
  (write-string port "#{T+")
  (do (fun (t) (write-char port #\space) (write-type port t)) (type-elts x))
  (write-string port "}"))

(dm recurring-write-type ((port <output-port>) (x <class>) (d <int>) (recur <fun>))
  (write-string port (as <str> (class-name x))))

(dm recurring-write-type ((port <output-port>) x (d <int>) (recur <fun>))
  (recurring-write port x d recur))

(dm write-type ((port <output-port>) x)
  (rep recur ((x x) (d 0))
    (recurring-write-type port x d recur)))

(dm recurring-write ((port <output-port>) (x <slot>) (d <int>) (recur <fun>))
  (write-string port "#{Slot ")
  (recur (slot-getter x) d)
  (write-string port "}"))

(dm recurring-write ((port <output-port>) x (d <int>) (recur <fun>))
  (write-string port "#{")
  (display port (class-name (object-class x)))
  (lab blow
    (for ((slot (object-slots x)) (i (from 0)))
      (when (>= i *max-print-length*)
        (write-string port " ...") (blow #f))
      (let ((getter (slot-getter slot)))
        (write-char port #\space)
        (display port (fun-name getter))
        (write-string port ": ")
        (recur (getter x) d))))
  (write-string port "}"))

(dm recurring-write
    ((port <output-port>) (x (t= (eof-object))) (d <int>) (recur <fun>))
  (write-string port "#{End-of-file}"))

(dm recurring-write
    ((port <output-port>) (x (t= nul)) (d <int>) (recur <fun>))
  (write-string port "nul"))

(dm format ((port <output-port>) (message <str>) (arguments ...))
  (let ((found-percent?         #f)
	((argument-index <int>) 0)
	(num-arguments          (len arguments)))
    (loc ((arg ((char <chr>) (class <any>) => <any>)
	    (let ((current-index argument-index))
	      (set argument-index (+ argument-index 1))
	      (assert (< current-index num-arguments)
		      "Too few arguments for format string %=: %="
		      message arguments)
	      (let ((argument (elt arguments current-index)))
		(assert (or (== class <any>) (isa? argument class))
		  "Format argument for directive '%%%c' not of class %s: %="
		  char class argument)
		argument))))
      (do (fun ((c <chr>))
	    (if found-percent?
		(seq (select (as-uppercase c)
		       ((#\D) (write-string port (num-to-str (arg c <num>))))
		       ((#\B) (write-string port (num-to-str (arg c <int>) 2)))
		       ((#\O) (write-string port (num-to-str (arg c <int>) 8)))
		       ((#\X) (write-string port (num-to-str (arg c <int>) 16)))
		       ((#\C) (write-char port (arg c <chr>)))
		       ((#\S) (display port (arg c <any>)))
		       ((#\=) (write port (arg c <any>)))
		       ((#\%) (write-char port #\%))
		       (#t
			 (error "Invalid format directive '%s' in \"%s\""
				c message)))
		     (set found-percent? #f))
		(if (== c #\%)
		    (set found-percent? #t)
		    (write-char port c))))
	  message))
    (assert (not found-percent?)
	    "Incomplete format directive in \"%s\"" message)))

(df format-to-string ((message <str>) (arguments ...) => <str>)
  (call-with-string-output-port
   (fun (out)
     (apply format out message arguments)
     (port-contents out))))

;; (set *debug-tables?* #t)

(export
  format
  format-to-string
  display
  write
  writeln
  write-to-string
  recurring-write
  *max-print-length*
  *max-print-depth*)
