(use runtime/boot)
(use goo/macros)
(use goo/magnitude)
(use goo/types)

;;; DYNAMIC BINDING

;;; <any>

;; (dm nyi-error ()
;;   (nyi) ;; nyi nyi
;;   )

(dm to-str (x|<any> => <str>)
  (cat "{ obj(" (to-str (class-name (object-class x))) ") }"))

(df address-of (x => <int>)
  ;; treat pointer as integer
  (%ib x))

;;; BOTTOM

(dc <bot> (<any>)) ;; todo: should be disjoint from <any>

;;; BOOLEAN

(dm to-str ((x (t= #t)) => <str>) "#t")
(dm to-str ((x (t= #f)) => <str>) "#f")

(dm as (type x => <any>)
  (if (isa? x type) 
      x
      (error "NO AS METHOD FOR %= AND %=" type x)))

;; TODO: DEAL WITH ==

(df as-log (x => <log>) (and x #t))

(dm == (x y => <log>) (%bb (%eq? x y)))

(dm = (x y => <log>) (== x y))

(dm ~= (x y => <log>)
  (not (= x y)))

(dm ~== (x y => <log>)
  (not (== x y)))

;;; character

(dm as ((_ (t= <chr>)) i|<int> => <chr>)
  (%cb (%iu i)))

(dm as ((_ (t= <int>)) c|<chr> => <int>)
  (%ib (%cu c)))

(dm < (x|<chr> y|<chr> => <log>)
  (%bb (%c< (%cu x) (%cu y))))

(dm == (x|<chr> y|<chr> => <log>)
  (%bb (%c= (%cu x) (%cu y))))

(dm lower? (x|<chr> => <log>)
  (def code (as <int> x))
  (if (>= code (as <int> #\a))
      (<= code (as <int> #\z))
      #f))

(dm upper? (x|<chr> => <log>)
  (def code (as <int> x))
  (if (>= code (as <int> #\A))
      (<= code (as <int> #\Z))
      #f))

(dm to-lower (x|<chr> => <chr>)
  (if (upper? x)
      (as <chr> (+ (as <int> x) (- (as <int> #\a) (as <int> #\A))))
      x))

(dm to-upper (x|<chr> => <chr>)
  (if (lower? x)
      (as <chr> (+ (as <int> x) (- (as <int> #\A) (as <int> #\a))))
      x))

(dm to-str (x|<chr> => <str>)
  (fabs <str> x))

(dm alpha? (x|<chr> => <log>)
  (or (and (<= #\a x) (<= x #\z))
      (and (<= #\A x) (<= x #\Z))))

(dm digit? (x|<chr> => <log>)
  (and (<= #\0 x) (<= x #\9)))

(dm to-digit (digit|<chr> => <int>)
  (- (char->ascii digit) (char->ascii #\0)))

(dm eof-object? (x => <log>) 
  #f)

(dm eof-object? (x|<chr> => <log>)
  (%bb (%eq? (%cu x) (%eof-object))))

(dm eof-object (=> <chr>)
  (%cb (%eof-object)))

;;; NUMBER

(dg contagious-type (x|<num> y|<num> => (t< <num>)))

(dg contagious-call (f|<fun> x|<num> y|<num> => <any>))

(dm contagious-call (f|<fun> x|<num> y|<num> => <any>)
  (def type (contagious-type x y))
  (f (as type x) (as type y)))

(dm < (x|<num> y|<num> => <log>)
  (contagious-call < x y))

(dm + (x|<num> y|<num> => <num>)
  (contagious-call + x y))

(dm 1+ (x|<num> => <num>)
  (+ x 1))

(dm - (x|<num> y|<num> => <num>)
  (contagious-call - x y))

(dm 1- (x|<num> => <num>)
  (- x 1))

(dm * (x|<num> y|<num> => <num>)
  (contagious-call * x y))

(dm atan2 (y|<num> x|<num> => <num>)
  (contagious-call atan2 y x))

(dm logn (x|<num> b|<num> => <num>)
  (contagious-call logn x b))

(dm floor (x|<num> => <int>)
  (elt (contagious-call floor/ x 1) 0))

(dm ceil (x|<num> => <int>)
  (elt (contagious-call ceiling/ x 1) 0))

(dm round (x|<num> => <int>)
  (elt (contagious-call round/ x 1) 0))

(dm round-to (x|<num> n|<int> => <num>)
  (if (= n 0)
      (round x)
      (let ((f (pow 10.0 n)))
        (x (/ (round (* x f)) f)))))

(dm trunc (x|<num> => <int>)
  (elt (contagious-call trunc/ x 1) 0))

(dm floor/ (real|<num> divisor|<num> => (tup <int> rem|<num>))
  (def (tup (integer <int>) (remainder <num>)) (trunc/ real divisor))
  (if (and (not (zero? remainder))
           (if (neg? divisor)
               (pos? real)
               (neg? real)))
      (tup (- integer 1) (+ remainder divisor))
      (tup integer remainder)))

(dm ceiling/ (real|<num> divisor|<num> => (tup <int> rem|<num>))
  (def (tup (integer <int>) (remainder <num>)) (trunc/ real divisor))
  (if (and (not (zero? remainder))
           (if (neg? divisor)
               (neg? real)
               (pos? real)))
      (tup (+ integer 1) (- remainder divisor))
      (tup integer remainder)))

(dm round/ (real|<num> divisor|<num> => (tup <int> rem|<num>))
  (def (tup (integer <int>) (remainder <num>)) (trunc/ real divisor))
  (def threshold|<num> (/ (abs divisor) 2.0))
  (if (or (> remainder threshold) 
          (and (= remainder threshold) (odd? integer)))
      (if (neg? divisor)
          (tup (- integer 1) (+ remainder divisor))
          (tup (+ integer 1) (- remainder divisor)))
      (if (let ((minus-threshold (neg threshold)))
            (or (< remainder minus-threshold)
                (and (= remainder minus-threshold) (odd? integer))))
          (if (neg? divisor)
              (tup (+ integer 1) (- remainder divisor))
              (tup (- integer 1) (+ remainder divisor)))
          (tup integer remainder))))

(dm trunc/ (real|<num> divisor|<num> => (tup <int> rem|<num>))
  (contagious-call trunc/ real divisor))

(dm mod (real|<num> divisor|<num> => <num>)
  (def (tup _ (remainder <num>)) (floor/ real divisor))
  remainder)

(dm rem (real|<num> divisor|<num> => <num>)
  (def (tup _ (remainder <num>)) (trunc/ real divisor))
  remainder)

(dm pos? (x|<num> => <log>)
  (> x 0))

(dm zero? (x|<num> => <log>)
  (contagious-call = x 0))

(dm neg? (x|<num> => <log>)
  (< x 0))

(dm neg (x|<num> => <num>)
  (- 0 x))

(dm abs (x|<num> => <num>)
  (if (neg? x) (neg x) x))

(dm to-str (x|<num> => <str>)
  (num-to-str x))

;;; <INT>

(dm contagious-type (x|<int> y|<int> => <type>)
  <int>)

(dm contagious-type (x|<flo> y|<flo> => <type>)
  <flo>)

(dm contagious-type (x|<int> y|<flo> => <type>)
  <flo>)

(dm contagious-type (x|<flo> y|<int> => <type>)
  <flo>)

(dm == (x|<int> y|<int> => <log>)
  (%bb (%i= (%iu x) (%iu y))))

(dm < (x|<int> y|<int> => <log>)
  (%bb (%i< (%iu x) (%iu y))))

(dm + (x|<int> y|<int> => <int>)
  (%ib (%i+ (%iu x) (%iu y))))

(dm - (x|<int> y|<int> => <int>)
  (%ib (%i- (%iu x) (%iu y))))

(dm * (x|<int> y|<int> => <int>)
  (%ib (%i* (%iu x) (%iu y))))

(dm floor (x|<int> => <int>) x)

(dm ceil (x|<int> => <int>) x)

(dm round (x|<int> => <int>) x)

(dm trunc (x|<int> => <int>) x)

(dm trunc/ (x|<int> y|<int> => (tup <int> rem|<int>))
  (def result (%ib (%it/ (%iu x) (%iu y))))
  (tup result (- x (* result y))))

(dm mod (x|<int> y|<int> => <int>)
  (def res (%ib (%im (%iu x) (%iu y))))
  (if (< res 0)
      (if (> y 0)
          (+ res y)
          (- res y))
      res))

(dm pow (x|<int> n|<int> => <num>)
  (cond
    ((neg? n) (/ 1 (pow x (neg n))))
    ((= x 2)  (<< 1 n))
    ((neg? x) (if (odd? n) (neg (pow (neg x) n)) (pow (neg x) n)))
    (#t
     (rep loop ((x|<int> (if (> n 1) (* x x) x))
                (p|<int> (>> n 1))
                (y|<int> (if (odd? n) x 1)))
       (if (zero? p)
           y
           (loop (if (> p 1) (* x x) x)
                 (>> p 1)
                 (if (odd? p) (* x y) y)))))))

(dm #| (x|<int> y|<int> => <int>)
  (%ib (%iv (%iu x) (%iu y))))

(dm ^ (x|<int> y|<int> => <int>)
  (%ib (%i^ (%iu x) (%iu y))))

(dm & (x|<int> y|<int> => <int>)
  (%ib (%i& (%iu x) (%iu y))))

(dm ~ (x|<int> => <int>)
  (%ib (%i! (%iu x))))

(dm bit? (o|<int> x|<int> => <int>)
  (%ib (%i? (%iu o) (%iu x))))

(dm even? (x|<int> => <log>)
  (zero? (& x 1)))

(dm odd? (x|<int> => <log>)
  (not (even? x)))

(dm >> (x|<int> a|<int> => <int>)
  (%ib (%i>> (%iu x) (%iu a))))

(dm >>> (x|<int> a|<int> => <int>)
  (%ib (%i>>> (%iu x) (%iu a))))

(dm << (x|<int> a|<int> => <int>)
  (%ib (%i<< (%iu x) (%iu a))))

(dm power-of-two-ceiling (x|<int> => <int>)
  (rep search ((po2|<int> 1))
    (if (> po2 x)
	po2
	(search (+ po2 po2)))))

;;; FLO

(df flo-bits (x|<flo> => <int>)
  (%ib (%flo-bits (%fu x))))

(dm as ((_ (t= <flo>)) x|<int> => <flo>)
  (%fb (%fi2f (%iu x))))

(dm == (x|<flo> y|<flo> => <log>)
  (%bb (%f= (%fu x) (%fu y))))

(dm < (x|<flo> y|<flo> => <log>)
  (%bb (%f< (%fu x) (%fu y))))

(dm + (x|<flo> y|<flo> => <flo>)
  (%fb (%f+ (%fu x) (%fu y))))

(dm - (x|<flo> y|<flo> => <flo>)
  (%fb (%f- (%fu x) (%fu y))))

(dm * (x|<flo> y|<flo> => <flo>)
  (%fb (%f* (%fu x) (%fu y))))

(dm / (x|<flo> y|<flo> => <flo>)
  (%fb (%f/ (%fu x) (%fu y))))

(dm trunc/ (x|<flo> y|<flo> => (tup <int> rem|<flo>))
  (def divided (/ x y))
  (def result  (%ib (%ft (%fu divided))))
  (tup result (* y (- divided (as <flo> result)))))

(dm pow (x|<flo> n|<flo> => <flo>)
  (def res (%fb (%fpow (%fu (abs x)) (%iu n))))
  (if (and (neg? x) (odd? n)) (neg res) res))

(dv $pi 3.14159265)
(dv $e  2.71828182)

(dm isqrt (x|<int> => <int>)
  (round (sqrt (as <flo> x))))

;; (ct (dv cat-sym make-sym))

(ds (def-unary-trans ,name (,param) ,@prefix)
  (let ((%fp (cat-sym "%f" name)))
    `(seq (dg ,name ((,param <num>) => <num>))
          (dm ,name ((,param <int>) => <int>) 
            ,@prefix (,name (as <flo> ,param)))
          (dm ,name ((,param <flo>) => <flo>)
            ,@prefix (%fb (,%fp (%fu ,param)))))))

(def-unary-trans sqrt (x)
  (when (neg? x) (error "SQRT would produce complex number")))

(def-unary-trans log (x))
(def-unary-trans sin (x))
(def-unary-trans cos (x))
(def-unary-trans tan (x))
(def-unary-trans sinh (x))
(def-unary-trans cosh (x))
(def-unary-trans tanh (x))
(def-unary-trans asin (x)
  (when (neg? x) (error "SQRT would produce complex number")))
(def-unary-trans acos (x)
  (when (neg? x) (error "SQRT would produce complex number")))
(def-unary-trans atan (x))

(dg atan2 (y|<num> x|<num> => <num>))
(dm atan2 (y|<flo> x|<flo> => <flo>) 
  (%fb (%fatan2 (%fu y) (%fu x))))
(dm atan2 (y|<flo> x|<flo> => <flo>) 
  (%fb (%fatan2 (%fu y) (%fu x))))

(dg logn (x|<num> b|<num> => <num>))
(dm logn (x|<num> b|<num> => <num>) 
  (/ (log x) (log b)))

;; from strings.goo
(need-implementation
  num-to-str
  char->ascii
  fabs)

(export
  ;; nyi-error
  to-str
  address-of
  <bot>
  as
  as-log
  ==
  =
  ~=
  ~==
  >
  <
  <=
  >=
  min
  max
  lower?
  upper?
  to-lower
  to-upper
  alpha?
  digit?
  to-digit
  eof-object?
  eof-object
  contagious-type
  contagious-call
  + 1+ - 1- * / floor ceil round trunc
  floor/ ceiling/ round/ trunc/
  mod rem
  pos? zero? neg? neg abs
  #| ^ & ~ bit?
  even?
  odd?
  << >> >>>
  power-of-two-ceiling
  flo-bits
  log logn pow
  sqrt isqrt
  sin cos tan asin acos atan atan2 sinh cosh tanh
  $pi $e
  )
