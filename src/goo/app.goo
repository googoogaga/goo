(use boot)
(use macros)
(use proto/collections/collection)

(df napply ((proc <fun>) nexts (args ...))
  (let ((ilen (@+ (@olen args) -1))
        (lelt (@oelt args ilen))
        (tlen (@+ ilen (len lelt)))
        (stackspace (%lb (%allocate-stack (%i+ (%raw 2) (%iu tlen)))))
        (argend (%sp-reg)))
    (rep loop1 ((i 0))
      (let ((top (@+ tlen -1)))
        (when (@< i ilen)
          (set (%loc-off stackspace (%i- (%iu top) (%iu i)))
               (@oelt args i))
          (loop1 (@+ i 1)))))
    (rep loop2 ((s (ini-state lelt)) (i (@+ 1 ilen)))
      (unless (fin-state? lelt s)
        (set (%loc-off stackspace (%i- (%iu tlen) (%iu i))) (now-elt lelt s))
        (loop2 (nxt-state lelt s) (@+ i 1))))
    (set (%loc-off stackspace (%iu tlen)) (%iu tlen))
    (set (%loc-off stackspace (%i+ (%raw 1) (%iu tlen))) proc)
    (set (%sp-reg) argend)
    (%check-call-types)
    (%raw-call proc nexts)))

