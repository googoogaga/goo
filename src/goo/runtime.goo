;;;; Copyright (c) 2001 Jonathan Bachrach

;;; MACRO SUPPORT

(df match-empty-list ((x <lst>) (fail <fun>))
  (if (== x '())
      '()
      (fail "Match Empty Failure of %=" x)))

(df match-unquote ((x <lst>) (fail <fun>))
  (if (== x '())
      (fail "Match Failure Empty List on Unquote")
      (head x)))

(df match-atom ((x <lst>) pat (fail <fun>))
  (if (== x '())
      (fail "Match Failure Empty List on %=" pat)
      (let ((exp (head x)))
	(if (== exp pat)
	    (tail x)
	    (fail "Match Failure of %= on %=" exp pat)))))

(df match-sublist ((x <lst>) (fail <fun>))
  (let ((x (head x)))
    (if (isa? x <lst>)
	x
        (fail "Match Failure on Sub List on %=" x))))

(dm make-sym ((x ...)  => <sym>)
  (as <sym> (reduce (fun (r e) (cat r (to-str e))) "" x)))

(dv *gensym-counter* 1000)

(dm gensym (=> <sym>)
  (make-sym "x-" (inc *gensym-counter*)))

(dm make-setter-name ((x <sym>) => <sym>)
  (make-sym x "-setter"))

(dm var-name ((x <sym>)) x)

(dm var-name ((x <lst>)) (elt x 0))

(dm var-type ((x <sym>)) '<any>)

(dm var-type ((x <lst>)) (elt x 1))

;;; DYNAMIC BINDING

(df type-or ((args ...)) <any>) ;; TODO: FOR REAL

;;; <any>

(dm nyi-error ()
  (nyi) ;; nyi nyi
  )

(dm to-str ((x <any>) => <str>)
  (let ((name (%binding-name x)))
    (if name 
        (cat "$" (to-str name))
        (cat "{ obj(" (to-str (object-parents x)) ") }"))))

(df address-of (x => <int>)
  ;; treat pointer as integer
  (%ib x))

;;; BOTTOM

(dv bot (isa <any>)) ;; todo: should be disjoint from <any>

;;; BOOLEAN

(dm to-str ((x #t) => <str>) "#t")
(dm to-str ((x #f) => <str>) "#f")

(dm as (type x => <any>)
  (if (isa? x type) 
      x
      (error "NO AS METHOD FOR %= AND %=" type x)))

;; TODO: DEAL WITH ==

(dm == (x y => <log>) (%bb (%eq? x y)))

(dm = (x y => <log>) (== x y))

(dm ~= (x y => <log>)
  (not (= x y)))

(dm ~== (x y => <log>)
  (not (== x y)))

(dm > (x y => <log>)
  (< y x))

(dm <= (x y => <log>)
  (not (< y x)))

(dm >= (x y => <log>)
  (not (< x y)))

(dm min (x y => <num>)
  (if (< x y) x y))

(dm max (x y => <num>)
  (if (> x y) x y))

;;; character

(dm as ((_ <chr>) (i <int>) => <chr>)
  (%cb (%iu i)))

(dm as ((_ <int>) (c <chr>) => <int>)
  (%ib (%cu c)))

(dm < ((x <chr>) (y <chr>) => <log>)
  (%bb (%c< (%cu x) (%cu y))))

(dm == ((x <chr>) (y <chr>) => <log>)
  (%bb (%c= (%cu x) (%cu y))))

(dm lowercase? ((x <chr>) => <log>)
  (let ((code (as <int> x)))
    (if (>= code (as <int> #\a))
        (<= code (as <int> #\z))
        #f)))

(dm uppercase? ((x <chr>) => <log>)
  (let ((code (as <int> x)))
    (if (>= code (as <int> #\A))
        (<= code (as <int> #\Z))
        #f)))

(dm as-lowercase ((x <chr>) => <chr>)
  (if (uppercase? x)
      (as <chr> (+ (as <int> x) (- (as <int> #\a) (as <int> #\A))))
      x))

(dm as-uppercase ((x <chr>) => <chr>)
  (if (lowercase? x)
      (as <chr> (+ (as <int> x) (- (as <int> #\A) (as <int> #\a))))
      x))

(dm to-str ((x <chr>) => <str>)
  (fabs <str> x))

(dm alphabetic? ((x <chr>) => <log>)
  (or (and (<= #\a x) (<= x #\z))
      (and (<= #\A x) (<= x #\Z))))

(dm numeric? ((x <chr>) => <log>)
  (and (<= #\0 x) (<= x #\9)))

(dm to-digit ((digit <chr>) => <int>)
  (- (char->ascii digit) (char->ascii #\0)))

;;; NUMBER

(dg contagious-type ((x <num>) (y <num>) => <num>))

(dg contagious-call ((f <fun>) (x <num>) (y <num>) => <any>))

(dm contagious-call ((f <fun>) (x <num>) (y <num>) => <any>)
  (let ((type (contagious-type x y)))
    (f (as type x) (as type y))))

(dm < ((x <num>) (y <num>) => <log>)
  (contagious-call < x y))

(dm + ((x <num>) (y <num>) => <num>)
  (contagious-call + x y))

(dm - ((x <num>) (y <num>) => <num>)
  (contagious-call - x y))

(dm * ((x <num>) (y <num>) => <num>)
  (contagious-call * x y))

(dm floor ((x <num>) => (tup <int> (rem <num>)))
  (contagious-call floor/ x 1))

(dm ceiling ((x <num>) => (tup <int> (rem <num>)))
  (contagious-call ceiling/ x 1))

(dm round ((x <num>) => (tup <int> (rem <num>)))
  (contagious-call round/ x 1))

(dm truncate ((x <num>) => (tup <int> (rem <num>)))
  (contagious-call truncate/ x 1))

(dm floor/ ((real <num>) (divisor <num>) => (tup <int> (remainder <num>)))
  (let (((tup (integer <int>) (remainder <num>)) (truncate/ real divisor)))
    (if (and (not (zero? remainder))
	     (if (neg? divisor)
		 (pos? real)
		 (neg? real)))
	(tup (- integer 1) (+ remainder divisor))
	(tup integer remainder))))

(dm ceiling/ ((real <num>) (divisor <num>) => (tup <int> (remainder <num>)))
  (let (((tup (integer <int>) (remainder <num>)) (truncate/ real divisor)))
    (if (and (not (zero? remainder))
	     (if (neg? divisor)
		 (neg? real)
		 (pos? real)))
	(tup (+ integer 1) (- remainder divisor))
	(tup integer remainder))))

(dm round/ ((real <num>) (divisor <num>) => (tup <int> (remainder <num>)))
  (let (((tup (integer <int>) (remainder <num>)) (truncate/ real divisor))
	((threshold <num>) (/ (abs divisor) 2.0)))
    (if (or (> remainder threshold) 
	   (and (= remainder threshold) (odd? integer)))
	(if (neg? divisor)
	    (tup (- integer 1) (+ remainder divisor))
	    (tup (+ integer 1) (- remainder divisor)))
	(if (let ((minus-threshold (neg threshold)))
	      (or (< remainder minus-threshold)
		  (and (= remainder minus-threshold) (odd? integer))))
	    (if (neg? divisor)
		(tup (+ integer 1) (- remainder divisor))
		(tup (- integer 1) (+ remainder divisor)))
	    (tup integer remainder)))))

(dm truncate/ ((real <num>) (divisor <num>) => (tup <int> (remainder <num>)))
  (contagious-call truncate/ real divisor))

(dm modulo ((real <num>) (divisor <num>) => <num>)
  (let (((tup _ (remainder <num>)) (floor/ real divisor)))
    remainder))

(dm remainder ((real <num>) (divisor <num>) => <num>)
  (let (((tup _ (remainder <num>)) (truncate/ real divisor)))
    remainder))

(dm pos? ((x <num>) => <log>)
  (> x 0))

(dm zero? ((x <num>) => <log>)
  (= x 0))

(dm neg? ((x <num>) => <log>)
  (< x 0))

(dm neg ((x <num>) => <num>)
  (- 0 x))

(dm abs ((x <num>) => <num>)
  (if (neg? x) (neg x) x))

(dm to-str ((x <num>) => <str>)
  (num-to-str x))

(dm str-to-num ((string <str>) => <any>) ;; (false-or <num>) ;; S48
  (let ((s 1)
	(d 0)
	(n 0)
	(i 0)
	(scale 1)
	(length (len string))
	(seen-decimal-point? #f)
	(radix 10))
    (loc ((match (char)
	    (if (and (< i length) (= (elt string i) char))
		(seq (set i (+ i 1)) #t)
		#f))
	  (match-digit! (_)
	    (lab return
	      (loc ((fail!! () (return #f)))
		(if (>= i length) (fail!!))
		(let ((char (elt string i)))
		  (if (= char #\.)
		      (if seen-decimal-point?
			  (error "string->number: Two decimal points: %="
				 string)
			  (seq
			   (set seen-decimal-point? #t)
			   (set i (+ i 1))
			   (if (>= i length) (fail!!))
			   (set char (elt string i)))))
		  (if (not (numeric? char)) (fail!!))
		  (set d (to-digit (elt string i)))
		  (set i (+ i 1))
		  (if seen-decimal-point?
		      (set scale (* scale radix)))
		  #t))))
	  (looking-at-alphabetic? ()
	    (if (and (< i length) 
		     (alphabetic? (elt string i)))
		#t
		#f)))
  ;; Now we get to use all this matching machinery
  (and (or (match #\+)
	   (and (match #\-) (set s -1))
	   #t)
       (and (match-digit! d) (set n d))
       (rep loop ()
	 (if (and (match-digit! d) (set n (+ (* n radix) d)))
	     (loop)
	     #t))
       (= i length) ;; consumed all chars
       (let ((f (* (as <flo> s) (/ (as <flo> n) (as <flo> scale)))))
	 (if seen-decimal-point? f (1st (truncate f))))))))

;;; <INT>

(dm contagious-type ((x <int>) (y <int>) => <int>)
  <int>)

(dm contagious-type ((x <flo>) (y <flo>) => <flo>)
  <flo>)

(dm contagious-type ((x <int>) (y <flo>) => <flo>)
  <flo>)

(dm contagious-type ((x <flo>) (y <int>) => <flo>)
  <flo>)

(dm == ((x <int>) (y <int>) => <log>)
  (%bb (%i= (%iu x) (%iu y))))

(dm < ((x <int>) (y <int>) => <log>)
  (%bb (%i< (%iu x) (%iu y))))

(dm + ((x <int>) (y <int>) => <int>)
  (%ib (%i+ (%iu x) (%iu y))))

(dm - ((x <int>) (y <int>) => <int>)
  (%ib (%i- (%iu x) (%iu y))))

(dm * ((x <int>) (y <int>) => <int>)
  (%ib (%i* (%iu x) (%iu y))))

(dm floor ((x <int>) => (tup <int> (remainder <int>)))
  (tup x 0))

(dm ceiling ((x <int>) => (tup <int> (remainder <int>)))
  (tup x 0))

(dm round ((x <int>) => (tup <int> (remainder <int>)))
  (tup x 0))

(dm truncate ((x <int>) => (tup <int> (remainder <int>)))
  (tup x 0))

(dm truncate/ ((x <int>) (y <int>) => (tup <int> (remainder <int>)))
  (let ((result (%ib (%it/ (%iu x) (%iu y)))))
    (tup result (- x (* result y)))))

(dm modulo ((x <int>) (y <int>) => <int>)
  (%ib (%im (%iu x) (%iu y))))

(dm logior ((x <int>) (y <int>) => <int>)
  (%ib (%iv (%iu x) (%iu y))))

(dm logxor ((x <int>) (y <int>) => <int>)
  (%ib (%i^ (%iu x) (%iu y))))

(dm logand ((x <int>) (y <int>) => <int>)
  (%ib (%i& (%iu x) (%iu y))))

(dm lognot ((x <int>) => <int>)
  (%ib (%i! (%iu x))))

(dm logbit? ((o <int>) (x <int>) => <int>)
  (%ib (%i? (%iu o) (%iu x))))

(dm even? ((x <int>) => <log>)
  (zero? (logand x 1)))

(dm odd? ((x <int>) => <log>)
  (not (even? x)))

(dm ash ((x <int>) (a <int>) => <int>)
  (if (neg? a)
      (%ib (%i>> (%iu x) (%iu a)))
      (%ib (%i<< (%iu x) (%iu a)))))

(dm lsh ((x <int>) (a <int>) => <int>)
  (if (neg? a)
      (%ib (%i>>> (%iu x) (%iu a)))
      (%ib (%i<<< (%iu x) (%iu a)))))

(dm power-of-two-ceiling ((x <int>) => <int>)
  (rep search (((po2 <int>) 1))
    (if (> po2 x)
	po2
	(search (+ po2 po2)))))

(dv $digit-to-char "0123456789abcdefghijklmnopqrstuvwxyz")

(dv *print-base* 10)

(dv epsilon 0.000001)

(dm decode-radix-option ((rest <opts>) (default <int>) caller-name => <int>)
  (if (empty? rest)
      default
      (if (= (len rest) 1)
	  (head rest)
	  (error "too many arguments: %=, %=" caller-name rest))))

;;  (mif (() rest)
;;       default
;;       (mif ((,radix) rest)
;;            radix
;;            (error "too many arguments: %=, %=" caller-name rest)))

(dm num-to-str ((num <int>) (radix-option ...) => <str>)
  (let ((radix
	 (decode-radix-option radix-option *print-base* 'num-to-str))
        (s (if (< num 0) -1 1))
        (digit-list
         (rep loop ((digit-list '()) (num (* num s)))
           (if (= num 0)
               digit-list
	       (let ((digit (elt $digit-to-char (remainder num radix))))
		 (loop (pair digit digit-list)
		       (1st (truncate/ num radix))))))))
    (as <str> (if (< s 0)
		  (pair #\- digit-list)
		  (if (= num 0) "0" digit-list)))))

;;; FLO

(df flo-bits ((x <flo>) => <int>)
  (%ib (%flo-bits (%fu x))))

(dm as ((_ <flo>) (x <int>) => <flo>)
  (%fb (%fi2f (%iu x))))

(dm == ((x <flo>) (y <flo>) => <log>)
  (%bb (%f= (%fu x) (%fu y))))

(dm < ((x <flo>) (y <flo>) => <log>)
  (%bb (%f< (%fu x) (%fu y))))

(dm + ((x <flo>) (y <flo>) => <flo>)
  (%fb (%f+ (%fu x) (%fu y))))

(dm - ((x <flo>) (y <flo>) => <flo>)
  (%fb (%f- (%fu x) (%fu y))))

(dm * ((x <flo>) (y <flo>) => <flo>)
  (%fb (%f* (%fu x) (%fu y))))

(dm / ((x <flo>) (y <flo>) => <flo>)
  (%fb (%f/ (%fu x) (%fu y))))

(dm truncate/ ((x <flo>) (y <flo>) => (tup <int> (remainder <flo>)))
  (let ((divided (/ x y))
	(result  (%ib (%ft (%fu x)))))
    (tup result (* y (- divided (as <flo> result))))))

(dm num-to-str ((num <flo>) (radix-option ...) => <str>)
  (let ((radix
	 (decode-radix-option radix-option *print-base* 'num-to-str))
        (s (if (< num 0) -1 +1))
        (p (* num s))
        (string "")
        (e (rep loop ((p p) (e 0))
             (let (((tup i) (truncate p)))
               (if (< (- p i) epsilon)
                   (seq (set string (num-to-str i radix)) e)
                   (loop (* p radix) (+ e 1))))))
        (length (len string)))
    (set string
         (if (= e 0)
             (cat string ".0")
             (if (= e length)
                 (cat "0." string)
                 (if (< e length)
                     (cat (sub string 0 (- length e)) "." 
			  (sub string (- length e) length))
                     (cat (sub "0.0000000000000" 0 (+ (- e length) 2))
			  string)))))
    (if (< s 0) (cat "-" string) string)))

;;; COLLECTION

;;; TODO: NEED TEST ARGS AND NOT-FOUND HANDLERS

(dm empty? ((c <col>) => <log>)
  (= (len c) 0))

(dm empty ((c <col>) => <col>)
  (isa c))

(dm default ((c <col>) => <col>)
  #f)

(dm = ((c1 <col>) (c2 <col>) => <log>)
  (rep eq ((s1 (ini-state c1)) (s2 (ini-state c2)))
    (if (fin-state? c1 s1)
	(fin-state? c2 s2)
        (and (= (now-elt c1 s1)  (now-elt c2 s2))
             (eq (nxt-state c1 s1) (nxt-state c2 s2))))))

(dm fab ((c <col>) (s <int>) => bot)
  (nyi-error))

(dm as ((p <col>) (x <col>) => <col>)
  (into (fab p (len x)) x 0 (len x)))

(dm do-key-vals ((fn <fun>) (key-vals <opts>) => (tup))
  (rep rep (((key-vals <opts>) key-vals))
    (unless (empty? key-vals)
      (fn (head key-vals) (head (tail key-vals)))
      (rep (tail (tail key-vals))))))

(dm fabs ((p <col>) (key-vals ...))
  (let ((x (isa p)))
    (do-key-vals (fun (key val) (set (elt x key) val)) key-vals)
    x))

(dm len ((x <col>) => <int>)
  (rep count ((s (ini-state x)) (i 0))
    (if (fin-state? x s) i (count (nxt-state x s) (+ i 1)))))

;; TODO: ALIGN COL'S
(dm alter ((dst <col>) (src <col>) => <col>)
  (rep in ((ds (ini-state dst)) (ss (ini-state src)))
    (if (if (fin-state? dst ds) #t (fin-state? src ss))
        dst
        (seq (set (now-elt dst ds)  (now-elt src ss))
             (in (nxt-state dst ds) (nxt-state src ss))))))

(dm fill ((dst <col>) val => <col>)
  (rep in ((ds (ini-state dst)))
    (if (fin-state? dst ds)
        dst
        (seq (set (now-elt dst ds)  val)
             (in (nxt-state dst ds))))))

(dm any? ((test <fun>) (c <col>) => <log>)
  (rep fnd ((state (ini-state c)))
    (if (fin-state? c state)
        #f
        (or (test (now-elt c state))
            (fnd (nxt-state c state))))))
  
(dm any2? ((test <fun>) (x <col>) (y <col>) => <log>)
  (rep fnd ((sx (ini-state x)) (sy (ini-state y)))
    (if (or (fin-state? x sx) (fin-state? y sy))
	#f
        (or (test (now-elt x sx) (now-elt y sy)) 
	    (fnd (nxt-state x sx) (nxt-state y sy))))))

(dm all? ((test <fun>) (c <col>) => <log>)
  (rep fnd ((state (ini-state c)))
    (or (fin-state? c state)
        (and (test (now-elt c state))
             (fnd (nxt-state c state))))))
  
(dm all2? ((test <fun>) (x <col>) (y <col>) => <log>)
  (rep fnd ((sx (ini-state x)) (sy (ini-state y)))
    (or (fin-state? x sx) (fin-state? y sy)
        (and (test (now-elt x sx) (now-elt y sy)) 
	     (fnd (nxt-state x sx) (nxt-state y sy))))))

(dm reduce ((combine <fun>) init (c <col>) => <col>)
  (rep red ((res init) (state (ini-state c)))
    (if (fin-state? c state)
        res
        (red (combine res (now-elt c state)) (nxt-state c state)))))
  
(dm reduce+ ((combine <fun>) (c <col>) => <col>)
  (let ((state (ini-state c))
        (init  (now-elt c state)))
    (rep red ((res init) (state (nxt-state c state)))
      (if (fin-state? c state)
          res
          (red (combine res (now-elt c state)) (nxt-state c state))))))
  
(dm find-key ((f <fun>) (c <col>) => <any>)
  (rep fnd ((state (ini-state c)))
    (if (fin-state? c state)
        nul
        (if (f (now-elt c state))
            (now-key c state)
            (fnd (nxt-state c state))))))
  
(dm map ((f <fun>) (c <col>) => <col>)
  (rep con ((res '()) (s (ini-state c)))
    (if (fin-state? c s)
        (as c (rev! res))
        (con (add res (f (now-elt c s))) (nxt-state c s)))))

(dm do ((f <fun>) (c <col>))
  (rep lop ((s (ini-state c)))
    (unless (fin-state? c s)
      (f (now-elt c s)) (lop (nxt-state c s)))))

(dm map2 ((f <fun>) (x <col>) (y <col>) => <col>)
  (rep con ((res '()) (sx (ini-state x)) (sy (ini-state y)))
    (if (or (fin-state? x sx) (fin-state? y sy))
        (as x (rev! res))
        (con (add res (f (now-elt x sx) (now-elt y sy))) 
	     (nxt-state x sx) (nxt-state y sy)))))

(dm do2 ((f <fun>) (x <col>) (y <col>))
  (rep lop ((sx (ini-state x)) (sy (ini-state y)))
    (unless (or (fin-state? x sx) (fin-state? y sy))
      (f (now-elt x sx) (now-elt y sy))
      (lop (nxt-state x sx) (nxt-state y sy)))))

(dm map-keyed ((f <fun>) (c <col>) => <col>)
  (rep con ((res '()) (s (ini-state c)))
    (if (fin-state? c s)
        (as c (rev! res))
        (con (add res (f (now-key c s) (now-elt c s))) (nxt-state c s)))))

(dm do-keyed ((f <fun>) (c <col>))
  (rep lop ((s (ini-state c)))
    (unless (fin-state? c s)
      (f (now-key c s) (now-elt c s)) (lop (nxt-state c s)))))

(dm mem? ((c <col>) x => <log>)
  (any? (fun (e) (== e x)) c))

;;; BAG

(dv <bag> (isa <col>))

;;; MAP

(dv <map> (isa <col>))

;;; ASSOCS

(dv <assocs> (isa <map>))
  (slot <assocs> (assocs-test <fun>) ==)
  (slot <assocs> (assocs-keys <lst>) '())
  (slot <assocs> (assocs-vals <lst>) '())

(dm fab ((c <assocs>) (s <int>) => <assocs>)
  (isa <assocs>))

(dm len ((x <assocs>) => <int>)
  (len (assocs-keys x)))

(dm elt ((x <assocs>) key => <any>)
  (rep fnd (((keys <lst>) (assocs-keys x)) ((vals <lst>) (assocs-vals x)))
    (if (== keys '())
        nul
        (if ((assocs-test x) key (head keys))
            (head vals)
            (fnd (tail keys) (tail vals))))))

(dm elt-setter (val (x <assocs>) key)
  (rep fnd (((keys <lst>) (assocs-keys x)) ((vals <lst>) (assocs-vals x)))
    (if (== keys '())
        (seq (set (assocs-keys x) (pair key (assocs-keys x)))
             (set (assocs-vals x) (pair val (assocs-vals x)))
          val)
        (if ((assocs-test x) key (head keys))
            (set (head vals) val)
            (fnd (tail keys) (tail vals))))))

;;; SEQUENCE

(dm as ((d <seq>) (s <seq>) => <seq>)
  (alter (fab d (len s)) s))

(df range-error ((x <seq>) (i <int>))
  ;; TODO: REAL CONDITION
  (error "RANGE ERROR %= %=" x i))

(df range-check ((x <seq>) (i <int>))
  (when (or (< i 0) (>= i (len x)))
    (range-error x i)))

(dm 1st ((x <seq>) => <any>) (elt x 0))

(dm 2nd ((x <seq>) => <any>) (elt x 1))

(dm 3rd ((x <seq>) => <any>) (elt x 2))

;; TODO: SHOULD USE BACKWARD ITERATION PROTOCOL???

(dm last ((x <seq>) => <any>) (elt x (- (len x) 1)))

(dg add ((c <seq>) x => <seq>))

(dm add-new ((c <seq>) x => <seq>)
  (unless (mem? c x) (add c x)) 
  c)

(dm add! ((c <seq>) x => <seq>)
  (add c x))

(dm push ((c <seq>) x => <seq>)
  (add! c x))

(dm pos ((x <seq>) v => <any>) ;; TODO: (false-or <int>)
  (find-key (curry == v) x))

;; TODO: DEPRECATED
(dm into ((dst <seq>) (src <seq>) (from <int>) (below <int>) => <seq>)
  (rep in ((ds (ini-state dst)) (ss (ini-state src)))
    (if (if (fin-state? dst ds) #t (fin-state? src ss))
        dst
        (seq (set (now-elt dst ds)  (now-elt src ss))
             (in (nxt-state dst ds) (nxt-state src ss))))))

(dm sub-setter
    ((src <seq>) (dst <seq>) (from <int>) (below <int>) => <seq>)
  (let (((dst-len <int>) (len dst))
	((src-len <int>) (len src))
	((del-len <int>) (- below from)))
    (if (= del-len src-len) ;;  Can modify in place?
	(rep find ((ds (ini-state dst)) (i 0))
	  (if (= i from)
	      (rep in ((ds ds) (ss (ini-state src)))
		(if (fin-state? src ss)
		    dst
		    (seq (set (now-elt dst ds)  (now-elt src ss))
			 (in (nxt-state dst ds) (nxt-state src ss)))))
	      (find (nxt-state dst ds) (+ i 1))))
	;; Don't know if dst is stretchy so we have to create a new one
	(let ((new-len (+ (- dst-len del-len) src-len))
	      (ndst    (fab dst new-len)))
	  (rep copy ((nds (ini-state ndst)) (ds (ini-state dst)) (i 0))
	    (if (= i from)
		(rep insert ((nds nds) (ss (ini-state src)))
		  (if (fin-state? src ss)
		      (rep skip ((ds ds) (i from))
			(if (= i below)
			    (rep onto ((nds nds) (ds ds) (i below))
			      (if (= i dst-len)
				  ndst
				  (seq (set (now-elt ndst nds) (now-elt dst ds))
				       (onto (nxt-state ndst nds)
					     (nxt-state dst ds) (+ i 1)))))
			    (skip (nxt-state dst ds) (+ i 1))))
		      (seq (set (now-elt ndst nds) (now-elt src ss))
			   (insert (nxt-state ndst nds) (nxt-state src ss)))))
		(seq (set (now-elt ndst nds) (now-elt dst ds))
		     (copy (nxt-state ndst nds) (nxt-state dst ds) 
			   (+ i 1)))))))))

(dm rev ((x <seq>) => <seq>)
  (rep con ((seq '()) (sta (ini-state x)))
    (if (fin-state? x sta)
        (as x seq)
        (con (add seq (now-elt x sta)) (nxt-state x sta)))))

(dm cat2 ((x <seq>) (y <seq>) => <seq>)
  (rep con-x ((seq '()) (sta (ini-state x)))
    (if (fin-state? x sta)
        (rep con-y ((seq seq) (sta (ini-state y)))
          (if (fin-state? y sta)
              (as x (rev! seq))
              (con-y (add seq (now-elt y sta)) (nxt-state y sta))))
        (con-x (add seq (now-elt x sta)) (nxt-state x sta)))))

(dm cat ((x <seq>) (ss ...) => <seq>)
  (reduce cat2 x ss))

(dm cat! ((x <seq>) (more ...) => <seq>)
  (apply cat (pair x more)))

(dm cat! ((x <lst>) (more ...) => <lst>)
  ;; find first non-empty arg., to be destructively updated and returned
  (rep find-result (((r <lst>) x) ((more <lst>) more))
    (if (empty? more)
	r
	(if (empty? r)
	    ;; skip empty arg prefix
	    (find-result (as <lst> (head more)) (tail more)) 
	    ;; p points into r (which is growing).  p is non-empty.
	    (rep connect (((p <lst>) r) ((more <lst>) more))
	      (if (empty? more)
		  r
		  ;; find next non-empty arg. to add
		  (let ((x (as <lst> (head more))))
		    (if (empty? x)
			(connect p (tail more)) ;; skip empty arg
			;; cdr to end of p and side-effect tail
			(rep find-tail (((p <lst>) p))
			  (if (empty? (tail p))
			      (seq (set (tail p) x)         ;; DESTRUCTIVE UPDATE
				   (connect x (tail more))) ;; connect next arg
			      (find-tail (tail p))))))))))))

(dm sub ((x <seq>) (from <int>) (below <int>) => <seq>)
  (rep con-x ((seq '()) ((i <int>) 0) (sta (ini-state x)))
    (if (fin-state? x sta)
        (as x (rev! seq))
        (con-x (if (if (>= i from) (< i below)) (add seq (now-elt x sta)) seq)
               (+ i 1) (nxt-state x sta)))))

(dm pick ((test <fun>) (x <seq>) => <seq>)
  (rep con ((seq '()) (sta (ini-state x)))
    (if (fin-state? x sta)
        (as x seq)
        (let ((e (now-elt x sta)))
          (con (if (test e) (add seq e) seq) (nxt-state x sta))))))

(dm del-dups ((x <seq>) => <seq>)
  (as x (rev! (reduce (fun (s e) (if (mem? s e) s (pair e s))) '() x))))

(dm del ((s <seq>) x => <seq>)
  (pick (fun (e) (~== e x)) s))

(dm vals-to-str ((s <seq>) => <str>)
  (reduce (fun (s e) (cat s (if (empty? s) "" " ") (to-str e))) "" s))

;;; LIST

(dv <list> <lst>)

(dm to-str ((x <lst>) => <str>)
  (cat "(" (vals-to-str x) ")"))

(dm pair (h (t <lst>))
  (isa <lst> (set head h) (set tail t)))

(dm empty ((c <lst>) => <lst>) '())

(dm empty? ((c <lst>) => <log>) (== c (empty c)))

(dm fab ((x <lst>) (s <int>) => <lst>)
  (rep fab (((i <int>) s) ((res <lst>) (empty x)))
    (if (> i 0)
        (fab (- i 1) (isa x (set tail res)))
	res)))

;; TODO: DO THIS IN GENERAL FOR AS
(dm as ((p <lst>) (x <lst>) => <lst>) x)

(dm fabs ((c <lst>) (objects ...))
  (rep build (((index <int>) (- (len objects) 1)) ((result <lst>) (empty c)))
    (if (< index 0)
        result
        (build (- index 1) 
	       (isa c (set head (elt objects index)) (set tail result))))))

(dm lst ((objects ...))
  (apply fabs (pair <lst> objects)))

(dv list lst)

(dv %list list) ;; QUASIQUOTE SUPPORT -- FOR EMULATOR P2C

(dv %cat  cat)

(dm len ((x <lst>) => <int>)
  (rep sum (((count <int>) 0) ((x <lst>) x))
    (if (empty? x) count (sum (+ count 1) (tail x)))))

(dm elt ((x <lst>) (key <int>) => <any>)
  (rep fnd (((count <int>) 0) ((x <lst>) x))
    (if (empty? x)
        nul ;; TODO: RANGE ERROR
        (if (== count key)
            (head x)
            (fnd (+ count 1) (tail x))))))

(dm elt-setter (z (x <lst>) (key <int>))
  (rep fnd (((count <int>) 0) ((x <lst>) x))
    (if (empty? x)
        nul ;; TODO: RANGE ERROR
        (if (== count key)
            (set (head x) z)
            (fnd (+ count 1) (tail x))))))

(dm add ((c <lst>) x => <lst>)
  (pair x c))

(dm rev! ((c <lst>) => <lst>)
  (rep loop ((l c) (r (empty c)))
    (if (empty? l)
	r
	(let ((t (tail l)))
	  (set (tail l) r)
	  (loop t l)))))

;; TODO: CHANGE ORDER OF ARGS LIKE MEM?
(dm assq (x (l <lst>) => <any>)
  (if (empty? l)
      #f
      (if (== x (head (head l)))
	  (head l)
	  (assq x (tail l)))))

(dm assqn (x (l <lst>) (pos <int>) => <any>)
  (if (empty? l)
      #f
      (if (== x (elt (head l) pos))
        (head l)
        (assqn x (tail l) pos))))

(dm last ((x <lst>) => <any>)
  (rep fnd ((x x) (px x))
    (if (empty? x) (head px) (fnd (tail x) x))))

(dm ini-state ((c <lst>) => <lst>) c)

(dm fin-state? ((_ <lst>) (state <lst>) => <log>) (empty? state))

(dm nxt-state ((_ <lst>) (state <lst>) => <lst>) (tail state))

(dm now-elt ((_ <lst>) (state <lst>) => <any>) (head state))

(dm now-elt-setter (z (_ <lst>) (state <lst>)) (set (head state) z))

(dm now-key ((c <lst>) (state <lst>) => <int>)
  (rep fnd (((key <int>) 0) ((c <lst>) c))
    (if (== c state) key (fnd (+ key 1) (tail c)))))

(dm copy-state ((_ <lst>) (state <lst>) => <lst>) state)

;;; TUPLE

(dv tup lst)

;;; <FLAT>

(dm ini-state ((c <flat>) => <int>) 0)

(dm fin-state? ((c <flat>) (state <int>) => <log>) (== state (len c)))

(dm nxt-state ((_ <flat>) (state <int>) => <int>) (+ state 1))

(dm now-elt ((c <flat>) (state <int>) => <any>) (low-elt c state))

(dm now-elt-setter (z (c <flat>) (state <int>)) (set (low-elt c state) z))

(dm now-key ((_ <flat>) (state <int>) => <int>) state)

(dm copy-state ((_ <flat>) (state <int>) => <int>) state)

;;; VECTOR

(dm empty ((c <vec>) => <vec>)
  %vnul)

(df vec ((objects ...))
  (as <vec> objects))

(dm fabs ((c <vec>) (objects ...))
  (apply vec objects))

(dm fab ((x <vec>) (s <int>) => <vec>)
  (%vec (%iu s)))

(dm len ((x <vec>) => <int>)
  (%ib (%vlen x)))

(dm low-elt ((x <vec>) (i <int>) => <any>)
  (%velt x (%iu i)))

(dm low-elt-setter (z (x <vec>) (i <int>))
  (set (%velt x (%iu i)) z))

(dm elt ((x <vec>) (i <int>) => <any>)
  (range-check x i)
  (%velt x (%iu i))) ;; TODO: LOW-ELT

(dm elt-setter (z (x <vec>) (i <int>))
  (range-check x i)
  (set (%velt x (%iu i)) z)) ;; TODO: LOW-ELT

(dm to-str ((x <vec>) => <str>)
  (cat "#(" (vals-to-str x) ")"))

;;; STRETCHY-VECTOR

(dv <buf> (isa <flat>))
  (slot <buf> (buf-len <int>) 0)
  (slot <buf> (buf-dat <vec>) #())

(dm empty ((c <buf>) => <buf>) (isa <buf>))

(dm buf ((elts ...) => <buf>)
  (alter (fab <buf> (len elts)) elts))

(dm fabs ((c <buf>) (elts ...) => <buf>)
  (apply buf elts))

(dm fab ((c <buf>) (s <int>) => <buf>)
  (let ((dat (fab <vec> (power-of-two-ceiling s))))
    (isa <buf> (set buf-len s) (set buf-dat dat))))

(dm len ((c <buf>) => <int>)
  (buf-len c))

(dm len-setter ((new-len <int>) (c <buf>))
  (let ((dat (buf-dat c)))
    (if (> new-len (len dat))
	(let ((new-data (fab <vec> (power-of-two-ceiling new-len))))
	  (alter new-data dat)
	  (set (buf-len c) new-len)
	  (set (buf-dat c) new-data))
	(if (< new-len (len c))
	    (let ((old-len (len c)))
	      (set (buf-len c) new-len)
	      (rep fill (((i <int>) new-len))
		(and (< i old-len)
		     (set (low-elt dat i) nul)
		     (fill (+ i 1)))))
	    (set (buf-len c) new-len)))))

(dm low-elt ((x <buf>) (i <int>) => <any>)
  (low-elt (buf-dat x) i))

(dm low-elt-setter (z (x <buf>) (i <int>))
  (when (>= i (len x))
    (set (len x) (+ i 1)))
  (set (low-elt (buf-dat x) i) z))

(dm elt ((c <buf>) (i <int>) => <any>)
  (range-check c i)
  (low-elt c i))

(dm elt-setter (z (c <buf>) (i <int>))
  (when (< i 0) (range-error c i))
  (set (low-elt c i) z))

(dm add! ((c <buf>) x => <buf>)
  (set (low-elt c (len c)) x)
  c)

(dm push ((c <buf>) x => <buf>)
  (add! c x))

(dm pop ((c <buf>) => <any>)
  (let ((new-len (- (len c) 1))
	(x       (low-elt c new-len)))
    (set (len c) new-len)
    x))

;; TODO: HAVE THIS FALL OUT OF PROTOCOL
(dm cat! ((x <buf>) (more ...) => <buf>)
  (rep outer ((more more))
    (if (empty? more)
	x
	(let ((s (head more)))
          (rep inner ((sta (ini-state s)))
            (if (fin-state? s sta)
		(outer (tail more))
		(seq (add! x (now-elt s sta))
		     (inner (nxt-state s sta)))))))))

;;; RANGE
;;;
;;; TODO: FEWER SLOTS

(dv <range> (isa <seq>))
  (slot <range> (range-from  <num>) 0)
  (slot <range> (range-to    <num>))
  (slot <range> (range-below <num>))
  (slot <range> (range-above <num>))
  (slot <range> (range-by    <num>) 1)

(dm from ((from <num>) => <range>)
  (isa <range> (set range-from from)))

(dm from-by ((from <num>) (by <num>) => <range>)
  (isa <range> (set range-from from)  (set range-by by)))

(dm from-to ((from <num>) (to <num>) => <range>)
  (isa <range> (set range-from from) (set range-to to)))

(dm from-to-by ((from <num>) (to <num>) (by <num>) => <range>)
  (isa <range> (set range-from from) (set range-to to)  (set range-by by)))

(dm from-below ((from <num>) (below <num>) => <range>)
  (isa <range> (set range-from from) (set range-below below)))

(dm from-below-by ((from <num>) (below <num>) (by <num>) => <range>)
  (isa <range> (set range-from from) (set range-below below) (set range-by by)))

(dm from-above ((from <num>) (above <num>) => <range>)
  (isa <range> (set range-from from) (set range-above above)))

(dm from-above-by ((from <num>) (above <num>) (by <num>) => <range>)
  (isa <range> (set range-from from) (set range-above above) (set range-by by)))

(dm ini-state ((c <range>) => <num>)
  (range-from c))

(dm fin-state? ((c <range>) (state <num>) => <log>)
  (if (neg? (range-by c))
      (if (== (range-to c) nul) 
	  (if (== (range-above c) nul)
	      #f
	      (<= state (range-above c)))
	  (< state (range-to c)))
      (if (== (range-to c) nul) 
	  (if (== (range-below c) nul)
	      #f
	      (>= state (range-below c)))
	  (> state (range-to c)))))

(dm nxt-state ((c <range>) (state <num>) => <num>)
  (+ state (range-by c)))

(dm now-elt ((c <range>) (state <num>) => <any>)
  state)

(dm copy-state ((_ <range>) (state <num>) => <num>)
  state)

;;; STEP

(dv <step> (isa <seq>))
  (slot <step> step-first)
  (slot <step> step-then)

(dm first-then (first then => <step>)
  (isa <step> (set step-first first) (set step-then then)))

(dm ini-state ((c <step>) => <log>)
  #t)

(dm fin-state? ((c <step>) (state <log>) => <log>)
  #f)

(dm nxt-state ((c <step>) (state <log>) => <log>)
  #f)

(dm now-elt ((c <step>) (state <log>) => <any>)
  (if state (step-first c) (step-then c)))

(dm copy-state ((_ <step>) (state <log>) => <log>)
  state)

;;; ASSOC

(dv <assoc>     (isa <any>))
  (slot <assoc> assoc-key)
  (slot <assoc> assoc-value)
(df assoc (x y => <assoc>)
  (isa <assoc> (set assoc-key x) (set assoc-value y)))

(dm assocq (x (l <lst>) => <any>)
  (if (empty? l)
      #f
      (if (== x (assoc-key (head l)))
	  (head l)
	  (assocq x (tail l)))))

;; TODO: QUESTIONABLE SYNTAX
(dm to-str ((x <buf>) => <str>) 
  (cat "#[" (vals-to-str x) "]"))

;;; STRING

(dm empty ((c <str>) => <str>)
  %snul)

(dm default ((c <col>) => <col>)
  #\space)

(dm fab ((x <str>) (s <int>) => <str>)
  (%str (%iu s)))

(dm str ((objects ...))
  (alter (fab <str> (len objects)) objects))

(dm fabs ((c <str>) (objects ...))
  (apply str objects))

(dm len ((x <str>) => <int>)
  (%ib (%slen x)))

(dm low-elt ((x <str>) (i <int>) => <chr>)
  (%cb (%selt x (%iu i))))

(dm low-elt-setter ((z <chr>) (x <str>) (i <int>))
  (set (%selt x (%iu i)) (%cu z)))

(dm elt ((x <str>) (i <int>) => <chr>)
  (range-check x i)
  (%cb (%selt x (%iu i)))) ;; TODO: USE LOW-ELT

(dm elt-setter ((z <chr>) (x <str>) (i <int>))
  (range-check x i)
  (set (%selt x (%iu i)) (%cu z))) ;; TODO: USE LOW-ELT

(dm to-str ((x <str>) => <str>)
  x)

;;; ASCII -- S48

(dv ascii-limit 128)

(dv (ascii-chars <vec>)
  (let ((ascii-chars
	 (fill (fab <vec> ascii-limit) #f))
	(init
	 (fun (i s)
	   (rep loop ((i i) (j 0))
	     (unless (= j (len s))
	       (set (elt ascii-chars i) (elt s j))
	       (loop (+ i 1) (+ j 1)))))))
    (init 9 "\t")  ;; tab
    (init 10 "\n") ;; newline
    (init 12 "\f") ;; page
    (init 13 "\r") ;; carriage return
    (init 32 " !\"#$%&'()*+,-./0123456789:;<=>?")
    (init 64 "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_")
    (init 96 "`abcdefghijklmnopqrstuvwxyz{|}~")
    ascii-chars))

(dm ascii->char ((n <int>) => <chr>)
  (or (elt ascii-chars n)
      (error "not a standard character's ASCII code: %=" n)))

(dm char->integer ((char <chr>) => <int>)
  (as <int> char))

(dm integer->char ((n <int>) => <chr>)
  (as <chr> n))

(dv (native-chars <lst>)
  (let ((end259 (len ascii-chars)))
    (rep loop ((i 0) (least #f) (greatest #f))
      (if (= i end259)
	  (let ((v (fill (fab <vec> (+ (- greatest least) 1)) #f)))
	    (rep loop ((i 0))
	      (if (= i end259)
		  (lst least v)
		  (let ((c (elt ascii-chars i)))
		    (if c (set (elt v (- (char->integer c) least)) i))
		    (loop (+ i 1))))))
	  (let ((c (elt ascii-chars i)))
	    (if c
		(let ((n (char->integer c)))
		  (loop (+ i 1) (if least (min least n) n)
			(if greatest (max greatest n) n)))
		(loop (+ i 1) least greatest)))))))

(dm char->ascii ((char <chr>) => <int>)
  (or (elt (head (tail native-chars))
	   (- (char->integer char) (head native-chars)))
      (error "not a standard character: %=" char)))

(dv ascii-whitespaces '(32 10 9 12 13))

;;; SYMBOL

(dm sym-name ((x <sym>) => <str>) 
  (%sym-nam x))

(dm as ((_ <str>) (s <sym>) => <str>)
  (sym-name s))

(dm as ((_ <sym>) (s <str>) => <sym>)
  (fab-sym s)
  ;; (let ((sym (elt symbols s)))
  ;;   (if (== sym nul)
  ;;       (set (elt symbols s) sym)
  ;;       sym))
  )

(dm < ((x <sym>) (y <sym>))
  (< (sym-name x) (sym-name y)))

(dm to-str ((x <sym>) => <str>)
  (sym-name x))

;;; FUNCTIONAL 

(dm identity (x) x)

(dm compose ((fx <fun>) (fy <fun>) => <fun>)
  (fun ((args ...)) (fx (apply fy args))))

(dm rcurry ((f <fun>) (curried ...) => <fun>)
  (fun ((args ...)) (apply f (cat args curried))))     

(dm curry ((f <fun>) (curried ...) => <fun>)
  (fun ((args ...)) (apply f (cat curried args))))     

(dm always (x => <fun>)
  (fun ((args ...)) x))

;;; CONDITIONS

(dv <condition> (isa <any>))

(dm default-handler ((c <condition>))
  #f)

(dv <simple-condition> (isa <condition>))
  (slot <simple-condition> (condition-message <str>))
  (slot <simple-condition> (condition-arguments <str>))

(dv <serious-condition> (isa <condition>))

(dm default-handler ((c <serious-condition>))
  (when (isa? c <simple-condition>)
    (apply (curry format out (condition-message c)) (condition-arguments c)))  
  (%invoke-debugger c))

(dv <error> (isa <serious-condition>))

(dv <simple-error> (isa (<error> <simple-condition>)))

(dv *current-handlers* '())

(dv <handler> (isa <any>))
  (slot <handler> (handler-function <fun>))

(df make-handler ((f <fun>) => <handler>)
  (isa <handler> (set handler-function f)))

(df handler-matches? ((handler <handler>) (condition <condition>) => <log>)
  #t)

(dp %with-monitor ((user-handler <fun>) (main-fun <fun>))
  (lab _unwind-exception_
    (let ((_original-handlers_ *current-handlers*))
      (loc ((_handler-function_ (condition _next-handler_)
	      (set *current-handlers* _original-handlers_)
	      (lab _resume_
		(user-handler condition _resume_)
		(_next-handler_))))
	(set *current-handlers*
             (pair (make-handler _handler-function_) *current-handlers*))
	(fin (main-fun) (set *current-handlers* _original-handlers_))))))

(dm sig ((condition <condition>) (args ...))
  (rep search ((handlers *current-handlers*))
    (if (empty? handlers)
	(default-handler condition)
	(let ((handler (head handlers))
	      (remaining (tail handlers)))
	  (if (handler-matches? handler condition)
	      ((handler-function handler)
	       condition (fun () (search remaining)))
	      (search remaining))))))

(dm sig ((c <str>) (args ...)) 
  (sig (isa <simple-condition> 
	 (set condition-message c) (set condition-arguments args))))

;; (df error ((message <str>) (args ...))
;;   (%break (%su message)))

(dm error ((c <simple-error>) (args ...))
  (sig c))

(dm error ((c <str>) (args ...))
  (error (isa <simple-error>
	   (set condition-message c) (set condition-arguments args))))

(df wrong-number-arguments-error ((fun <fun>) (n <int>))
  (error "%= CALLED WITH %= ARGUMENTS EXPECTED %=" fun n (fun-arity fun)))

(df unknown-function-error ((fun <fun>))
  (error "UNKNOWN FUNCTION %= CALLED" fun))

(df type-error (arg type)
  (error "TYPE ERROR %= SHOULD BE A %=" arg type))

;;; LOCATIVES

;; (dv <loc> (isa <any>))
;;   (slot <loc> locative-dat)

(df locative-value ((x <loc>) => <any>)
  (%locative-value x))

(df locative-value-setter (z (x <loc>) => <any>)
  (set (%locative-value x) z))

;;; APPLICATION INPUT

(df app-filename () (%app-filename))

(df app-args () (%app-args))

;;; PORTS

(dv <port> (isa <any>))
  (slot <port> port-handle)

(dv <input-port> (isa <port>))

(dv <output-port> (isa <port>))

;;; FILE PORTS

(dv <file-port> (isa <port>))

(dv <file-input-port> (isa (<file-port> <input-port>)))

(dv <file-output-port> (isa (<file-port> <output-port>)))

(dm open-input-file ((filename <str>) => <file-input-port>)
  (isa <file-input-port>
       (set port-handle (%open-input-file (%su filename)))))

(dm file-opening-error ((filename <str>))
  (error "Cannot open file named %=" filename))

(dm open-output-file ((filename <str>) => <file-output-port>)
  (isa <file-output-port>
       (set port-handle (%open-output-file (%su filename)))))

(dm close-input-port ((port <file-input-port>))
  (%close-input-port (port-handle port)))

(dm close-output-port ((port <file-output-port>))
  (%close-output-port (port-handle port)))

(dm call-with-input-file ((string <str>) (proc <fun>))
  (let ((port #f))
    (fin (seq (set port (open-input-file string))
	      (proc port))
	 (and port (close-input-port port)))))
       

(dm call-with-output-file ((string <str>) (proc <fun>))
  (let ((port #f))
    (fin (seq (set port (open-output-file string))
	      (proc port))
	 (and port (close-output-port port)))))

(dv in (isa <file-input-port> (set port-handle (%current-input-port))))

(dv out (isa <file-output-port> (set port-handle (%current-output-port))))

(dm eof-object? (x => <log>) 
  #f)

(dm eof-object? ((x <chr>) => <log>)
  (%bb (%eq? (%cu x) (%eof-object))))

(dm eof-object (=> <chr>)
  (%cb (%eof-object)))

(dm read-char ((port <file-input-port>) => <chr>)
  (%cb (%read-char (port-handle port))))

(dm peek-char ((port <file-input-port>) => <chr>)
  (%cb (%peek-char (port-handle port))))

(dm char-ready? ((port <file-input-port>) => <log>)
  (%char-ready? (port-handle port)))

(dm newline ((port <output-port>)) 
  (write-char port #\newline))

(dm force-output ((port <file-output-port>))
  (%force-output (port-handle port)))

(dm write-char ((port <file-output-port>) (c <chr>))
  (%write-char (port-handle port) (%cu c)))

(dm write-string ((port <file-output-port>) (s <str>))
  (%write-string (port-handle port) (%su s)))

;;; STRING-PORT IMPLEMENTATION

(dv <string-port> (isa <port>))
  (slot <string-port> (port-guts <seq>) "")

(dm port-contents ((port <string-port>) => <str>)
  (as <str> (port-guts port)))

(dv <string-input-port> (isa (<string-port> <input-port>)))
  (slot <string-input-port> (port-index <int>) 0)

(dv <string-output-port> (isa (<string-port> <output-port>)))

(dm call-with-string-input-port ((string <str>) (proc <fun>))
  (proc (isa <string-input-port> (set port-guts string))))

;; VERY INEFFICIENT

(dm call-with-string-output-port ((proc <fun>))
  (proc (isa <string-output-port>)))

;; TODO: EOF OBJECT MUST BE A CHR

(dm peek-char ((port <string-input-port>) => <chr>)
  (if (>= (port-index port) (len (port-guts port)))
      (eof-object)
      (elt (port-guts port) (port-index port))))

(dm read-char ((port <string-input-port>) => <chr>)
  (if (>= (port-index port) (len (port-guts port)))
      (eof-object)
      (let ((res (elt (port-guts port) (port-index port))))
	(inc (port-index port))
	res)))

(dm char-ready? ((port <string-input-port>) => <log>)
  #t)

(dm write-char ((port <string-output-port>) (c <chr>))
  (set (port-guts port) (add (port-guts port) c)))

(dm write-string ((port <string-output-port>) (s <str>))
  (set (port-guts port) (cat (port-guts port) s)))

;;; TABLES

;; Is 1 million big enough?
;; (dv *max-prime-for-table* 1000000)
;; 
;; List of the first number in each prime pair
;; (dv *twin-primes* (compute-twin-primes *max-prime-for-table*))

(dv *twin-primes*
  (as <vec>
    '(3 5 11 17 29 41 47 59 71 101 107 137 149 167 179 191 197 227 239
      269 281 311 347 419 431 461 521 569 599 617 641 659 809 839 881 1019
      1049 1091 1151 1229 1277 1319 1367 1427 1481 1607 1667 1721 1787 1871
      1931 1997 2081 2141 2207 2267 2339 2549 2657 2729 2801 2969 3119 3251
      3359 3461 3557 3671 3767 3917 4019 4127 4241 4421 4547 4721 4931 5099
      5231 5417 5639 5849 6089 6269 6449 6659 6827 7127 7307 7547 7757 8009
      8219 8429 8819 9041 9281 9629 9929 10271 10529 10859 11159 11447
      11777 12107 12539 12917 13337 13679 14081 14447 14867 15269 15731
      16139 16631 17189 17657 18119 18911 19421 19961 20477 21011 21557
      22109 22697 23291 23909 24917 25577 26249 26951 27689 28409 29129
      29879 30839 31721 32531 33347 34211 35081 36011 36929 37991 39041
      40037 41141 42179 43319 44531 45821 47057 48311 49529 50891 52181
      53549 54917 56477 57899 59357 60887 62927 64577 66359 68111 69827
      71711 73607 75539 77477 79559 81551 83639 85817 88001 90371 92639
      95087 97499 99989 102497 105227 108011 110729 113537 116531 119549
      122597 125789 128939 132329 135647 139121 142607 146297 149969 153887
      157769 161729 166301 170537 174929 179381 183917 188831 193601 198461
      203429 208589 213947 219311 224909 230561 236477 242447 248639 254927
      261431 268517 275321 282239 289841 297467 304979 312617 320561 328589
      336827 345461 354251 363149 372269 381629 391217 401309 411527 422087
      432659 443561 454709 466181 478067 490031 502499 515087 527981 541361
      555041 569081 583337 598049 613007 628679 644489 660617 677231 694259
      711707 729557 747827 766541 785777 805499 825827 846749 868121 889871
      912449 935591 959207 983327)))

(dv <simple-table-vector> (isa <any>))
  ;; Number of filled and vacant elements
  (slot <simple-table-vector> (%vacated <int>) 0)
  ;; Modulus values for primary and secondary hash
  (slot <simple-table-vector> (%primary-modulus <int>))
  (slot <simple-table-vector> (%secondary-modulus <int>))
  ;; Number of buckets and number of elements in each bucket
  (slot <simple-table-vector> (%n-buckets <int>))
  (slot <simple-table-vector> (%bucket-depth <int>))
  ;; The actual table data representation
  (slot <simple-table-vector> (%data <vec>))
  ;; GC state
  (slot <simple-table-vector> %gc-state)

;; TODO: SIZE FILL N-BUCKETS BUCKET-DEPTH PRIMARY-MODULUS SECONDARY-MODULUS
(df fab-table-vector 
     ((size <int>) fill-value
      (n-buckets <int>) (bucket-depth <int>)
      (primary-modulus <int>) (secondary-modulus <int>)
      => <simple-table-vector>)
   (let ((v (isa <simple-table-vector>
	      (set %n-buckets n-buckets)
	      (set %bucket-depth bucket-depth)
	      (set %primary-modulus primary-modulus)
	      (set %secondary-modulus secondary-modulus))))
      (set (%data v) (fill (fab <vec> size) fill-value))
      v))

(dm elt ((vector <simple-table-vector>) (index <int>) => <any>)
  ;; (elt (%data vector) index)
  (%velt (%data vector) (%iu index)))

(dm elt-setter (new-value (vector <simple-table-vector>) (index <int>) => <any>)
  ;; (set (elt (%data vector) index) new-value)
  (set (%velt (%data vector) (%iu index)) new-value)
  )

(dm clr! ((vector <simple-table-vector>) fill-value)
  (fill (%data vector) fill-value)
  (set (%vacated vector) 0))

(dv *debug-tables?* #f)

(df trace (port msg (args ...))
  (and *debug-tables?* (apply format (cat (lst port msg) args))))
      

(dv <tab> (isa <map>))
  ;; Factor to grow by
  (slot <tab> (table-growth-factor <flo>) 2.0)
  ;; When to grow or shrink (percentage of table size)
  (slot <tab> (table-growth-threshold <flo>) 0.8)
  (slot <tab> (table-shrink-threshold <flo>) 0.5)
  (slot <tab> (%count <int>) 0)
  (slot <tab> (%vector <simple-table-vector>))

(dg table-protocol ((x <tab>) => (tup (test-fun <fun>) (hash-fun <fun>))))

(dm table-protocol ((x <tab>) => (tup (test-fun <fun>) (hash-fun <fun>)))
  (tup == id-hash))

(dv $empty-cell-marker (lst "empty cell"))
(dv $vacated-cell-marker (lst "vacated cell"))

(df hash-moduli ((hash <int>) (primary <int>) (secondary <int>)
		 => (tup (index <int>) (offset <int>)))
   (tup (modulo hash primary) (+ (modulo hash secondary) 1)))

(dm fab ((type <tab>) (size <int>) => <tab>)
  ;; (trace out "FAB %= SIZE %=\n" type size)
  (let (((tup n-buckets bucket-depth) (choose-table-geometry size))
	(table (isa type)))
    (set (%vector table)
	 (fab-table-vector 
	  (* n-buckets (* bucket-depth 2)) $empty-cell-marker
	  n-buckets bucket-depth
	  n-buckets (- n-buckets 2)))
    table))

(ds (with-hash ((tup ,bucket-index ,bucket-offset) (,table ,key)) ,@body)
  `(let (((tup test-function hash-function) (table-protocol ,table))
	 ((tup (hash <int>) state) (hash-function ,key))
	  (vector (%vector table))
         ((tup ,bucket-index ,bucket-offset)
	   (hash-moduli 
	    hash (%primary-modulus vector) (%secondary-modulus vector))))
     ,@body))

(dm elt ((table <tab>) key => <any>)
  (lab return
    (let (((tup test-function hash-function) (table-protocol table))
	  ((tup (hash <int>) state) (hash-function key))
	  (vector       (%vector table))
	  (n-buckets    (%n-buckets vector))
	  (bucket-depth (%bucket-depth vector))
	  ((tup bucket-index bucket-offset)
	   (hash-moduli 
	    hash (%primary-modulus vector) (%secondary-modulus vector))))
      ;; Search each bucket
      (rep outer ((probes 0))
	(when (< probes n-buckets)
	  (let ((index (* bucket-index (* bucket-depth 2))))
	    (rep inner ((i 0) (this-bucket-raw-index index))
	      (when (< i bucket-depth)
		(let ((this-key (elt vector this-bucket-raw-index)))
		  (when (== this-key $empty-cell-marker)
		    (return nul))
		  ;; N.B. Don't look at already vacated cells along
		  ;; the collision chain 
		  (when (and ;; (~== this-key $vacated-cell-marker)
			     (test-function key this-key))
		    (return
		     (elt vector (+ this-bucket-raw-index bucket-depth))))
		  (inner (+ i 1) (+ this-bucket-raw-index 1)))))
	    ;; Not in this bucket try the next one
	    (dec bucket-index bucket-offset)
	    (when (neg? bucket-index)
	      (inc bucket-index n-buckets))
	    (outer (+ probes 1)))))
      ;; Table totally full???  That's not right
      (error "The table is totally full this shouldn't happen"))))

(dm elt-setter (value (table <tab>) key => <any>)
  ;; (trace out "PUT COUNT %=\n" (%count table))
  (let ((vector (%vector table)))
    (if (> (%count table) 
	   (* (* (%n-buckets vector) (%bucket-depth vector))
	      (table-growth-threshold table)))
	;; Grow the table if it's too full
	(set vector (%vector (grow-table table)))
	(if (> (+ (%count table) (%vacated vector)) 
	       (* (* (%n-buckets vector) (%bucket-depth vector))
		  (table-growth-threshold table))) 
            ;; Rehash when there are too many vacated elements
	    (set vector (%vector (rehash-table table)))))
    (lab return
      (let (((tup test-function hash-function) (table-protocol table))
	    ((tup (hash <int>) state) (hash-function key))
	    (bucket-depth (%bucket-depth vector))
	    (n-buckets    (%n-buckets vector))
	    ((tup bucket-index bucket-offset)
	     (hash-moduli 
	      hash (%primary-modulus vector) (%secondary-modulus vector))))
	;; Search each bucket
	(rep outer (((probes <int>) 0))
	  (when (< probes n-buckets)
	    (let ((index (* bucket-index (* bucket-depth 2))))
	      ;; (trace out "LOOKING AT %=\n" index)
	      (rep inner (((i <int>) 0) ((this-bucket-raw-index <int>) index))
		(when (< i bucket-depth)
		  (let ((vacancy-index #f)
			(this-key (elt vector this-bucket-raw-index)))
		    (case
		      ;; end of chain and not found
		      ((== this-key $empty-cell-marker)
		       (let ((index 
			      (if vacancy-index
				  ;; use a vacant cell if you found one
				  (seq (dec (%vacated vector))
				       vacancy-index)
				  ;; use this cell
				  this-bucket-raw-index)))
			 ;; (trace out "FOUND EMPTY CELL @ %d\n"
			 ;; 	   this-bucket-raw-index)
			 (set (elt vector index) key)
			 (set (elt vector (+ index bucket-depth)) value)
			 (inc (%count table))
			 (return value)))
		      ((== this-key $vacated-cell-marker) ;; remember vacancy
		       ;; N.B. Only record the _first_ vacant cell
		       (unless vacancy-index 
			 ;; (trace out "FOUND VACATED CELL @ %d\n" vacancy-index)
			 (set vacancy-index this-bucket-raw-index)))
		      ;; key already in table update value
		      ((test-function key this-key)
		       (set (elt vector (+ this-bucket-raw-index bucket-depth))
			    value)
		       ;; (trace out "FOUND KEY @ %d\n" this-bucket-raw-index)
		       (return value)))
		   (inner (+ i 1) (+ this-bucket-raw-index 1)))))
	      ;; Not in this bucket try the next one
	      (dec bucket-index bucket-offset)
	      (when (neg? bucket-index)
		(inc bucket-index n-buckets))
	      (outer (+ probes 1)))))
	;; Table totally full???  That's not right
	(error "The table is totally full this shouldn't happen")))))

(dm del-key ((table <tab>) key => (found? <log>))
  (lab return
    (let (((tup test-function hash-function) (table-protocol table))
	  ((tup (hash <int>) state) (hash-function key))
	  (vector       (%vector table))
	  (n-buckets    (%n-buckets vector))
	  (bucket-depth (%bucket-depth vector))
	  ((tup bucket-index bucket-offset)
	   (hash-moduli
	    hash (%primary-modulus vector) (%secondary-modulus vector))))
      ;; Search each bucket
      (rep outer (((probes <int>) 0))
	(when (< probes n-buckets)
	  (let (((index <int>) (* bucket-index (* bucket-depth 2))))
	    ;; (trace out "LOOKING AT %=\n" index)
	    (rep inner (((i <int>) 0) ((this-bucket-raw-index <int>) index))
	      (when (< i bucket-depth)
		(let ((this-key (elt vector this-bucket-raw-index)))
		  (when (== this-key $empty-cell-marker)
		    (return #f))
		  ;; N.B. Don't look at already vacated cells along
		  ;;      the collision chain 
		  (when (and (~== this-key $vacated-cell-marker)
			     (test-function key this-key))
		    (set (elt vector this-bucket-raw-index)
			 $vacated-cell-marker)
		    ;; In a GC-ed environment clear the value cell too!
		    (dec (%count table))
		    (inc (%vacated vector))
		    (return #t))
		  (inner (+ i 1) (+ this-bucket-raw-index 1)))))
	    ;; Not in this bucket try the next one
	    (dec bucket-index bucket-offset)
	    (when (neg? bucket-index)
	      (inc bucket-index n-buckets))
	    (outer (+ probes 1)))))
      ;; Table totally full???  That's not right
      (error "The table is totally full this shouldn't happen"))))

(dm do-keyed ((function <fun>) (table <tab>) => <any>) ;; TODO: => (tup)
  (let ((vector    (%vector table))
	(n-buckets (%n-buckets vector))
	(depth     (%bucket-depth vector)))
    (rep outer (((b <int>) 0))
      (when (< b n-buckets)
	(rep inner (((i <int>) 0))
	  (when (< i depth)
	    (let ((key (elt vector (+ i (* b (* depth 2))))))
	      (unless (or (== key $empty-cell-marker) 
			  (== key $vacated-cell-marker))
		(trace out "B %= I %=\n" b i)
		(let ((index (+ i (+ (* b (* depth 2)) depth))))
		  (function key (elt vector index)))))
	    (inner (+ i 1))))
	(outer (+ b 1))))))

(dm do ((function <fun>) (table <tab>) => <any>) ;; TODO: => (tup)
  (let ((vector    (%vector table))
	(n-buckets (%n-buckets vector))
	(depth     (%bucket-depth vector)))
    (rep outer (((b <int>) 0))
      (when (< b n-buckets)
	(rep inner (((i <int>) 0))
	  (when (< i depth)
	    (let ((key (elt vector (+ i (* b (* depth 2))))))
	      (unless (or (== key $empty-cell-marker) 
			  (== key $vacated-cell-marker))
		(let ((index (+ i (+ (* b (* depth 2)) depth))))
		  (function (elt vector index)))))
	    (inner (+ i 1))))
	(outer (+ b 1))))))

(dm del-keys ((table <tab>) => <any>) ;; TODO: (tup)
  (clr! (%vector table) $empty-cell-marker)
  (set (%count table) 0))

(dm len ((table <tab>) => <int>)
  (%count table))

(dv <tab-state> (isa <any>))
  (slot <tab-state> (%vector <simple-table-vector>))
  (slot <tab-state> (%bucket <int>) 0)
  (slot <tab-state> (%index <int>) 0)

(dm ini-state ((table <tab>))
  (if (= (len table) 0)
      #f
      (lab return
	(let ((vector    (%vector table))
	      (n-buckets (%n-buckets vector))
	      (depth     (%bucket-depth vector)))
	  (rep outer (((b <int>) 0))
	    (when (< b n-buckets)
	      (rep inner (((i <int>) 0))
                (when (< i depth)
		  (let ((key (elt vector (+ i (* b (* depth 2))))))
		    (unless (or (== key $empty-cell-marker)
				(== key $vacated-cell-marker))
		      (return (isa <tab-state>
				(set %vector vector)
				(set %bucket b)
				(set %index  i))))
		    (inner (+ i 1)))))
	      (outer (+ b 1))))
	  #f))))

(dm nxt-state ((table <tab>) (state <tab-state>) => <any>)
  (let ((vector    (%vector state))
	(n-buckets (%n-buckets vector))
	(depth     (%bucket-depth vector))
	(bucket    (%bucket state))
	(index     (%index state)))
    ;; (inc index)
    ;; (when (= index depth)
    ;;   (inc bucket)
    ;;   (set index 0))
    (lab return
      (rep outer (((b <int>) bucket) (first? #t))
	(when (< b n-buckets)
	  (rep inner (((i <int>) (if first? (+ index 1) 0)))
	    (when (< i depth)
	      (let ((key (elt vector (+ i (* b (* depth 2))))))
		(unless (or (== key $empty-cell-marker)
			    (== key $vacated-cell-marker))
		  (set (%bucket state) b)
		  (set (%index state)  i)
		  (return state))
		(inner (+ i 1)))))
	  (outer (+ b 1) #f)))
      #f)))

(dm fin-state? ((table <tab>) state => <log>)
  (not state))

(dm now-key ((table <tab>) (state <tab-state>) => <any>)
  (let ((vector (%vector state))
	(depth  (%bucket-depth vector)))
    (elt vector (+ (%index state) (* (%bucket state) (* depth 2))))))

(dm now-elt
    ((table <tab>) (state <tab-state>) => <any>)
  (let ((vector (%vector state))
	(depth  (%bucket-depth vector)))
    (elt vector (+ (%index state) (+ depth (* (%bucket state) (* depth 2)))))))

(dm now-elt-setter
    (value (table <tab>) (state <tab-state>) => <any>)
  (let ((vector (%vector state))
	(index  (%index state))
	(depth  (%bucket-depth vector)))
    (set (elt vector (+ index (+ depth (* (%bucket state) (* depth 2)))))
	 value)))

(dm copy-state
    ((table <tab>) (state <tab-state>) => <tab-state>)
  (isa <tab-state>
    (set %vector (%vector state))
    (set %bucket (%bucket state))
    (set %index  (%index state))))  

;;; Internal functions

(dm tab-keys ((table <tab>) => <lst>)
  (collecting () (do-keyed (fun (k v) (collect k)) table)))

(dm grow-table ((table <tab>) => <tab>)
  ;; (let ((vec (%vector table)))
  ;;   (trace out "GROWING TABLE %= %= OF %=\n" (object-name table)
  ;; 	      (%count table) (* (%n-buckets vec) (%bucket-depth vec))))
  (let ((vector (%vector table))
	((tup new-n-buckets new-bucket-depth)
	 (choose-table-geometry
	  (elt (floor (* (* (%n-buckets vector) (%bucket-depth vector))
			 (table-growth-factor table))) 0)))
	(new-vector
	 (fab-table-vector
           (* new-n-buckets (* new-bucket-depth 2))
           $empty-cell-marker
	   new-n-buckets new-bucket-depth new-n-buckets (- new-n-buckets 2))))
    ;; (trace out "OLD DATA %=\n" (%data (%vector table)))
    (copy-to-new-vector table new-vector)
    (set (%vector table) new-vector)
    ;; (trace out "NEW DATA %=\n" (%data (%vector table)))
    ;;--- It would be nice to be able to deallocate the old vector
    table))

(dm rehash-table ((table <tab>) => <tab>)
  (let ((vector (%vector table))
	(new-vector
	 (fab-table-vector 
	   (* (%n-buckets vector) (* (%bucket-depth vector) 2))
           $empty-cell-marker 
	   (%n-buckets vector) (%bucket-depth vector)
	   (%primary-modulus vector) 
           (%secondary-modulus vector))))
    (copy-to-new-vector table new-vector)
    (set (%vector table) new-vector)
    table))

(df choose-table-geometry 
     ((capacity <int>) => (tup (n-buckets <int>) (bucket-depth <int>)))
   ;;--- These numbers are completely arbitrary and need to be tuned up
   (lab return
     (let ((depth
	    (case
	      ((< capacity 2000)    1)
	      ((< capacity 5000)    2)
	      ((< capacity 15000)   4)
	      ((< capacity 50000)   8)
	      ((< capacity 250000) 16)
	      (#t                  32))))
       (do (fun ((p <int>))
	     (when (> p (elt (ceiling/ capacity depth) 0))
	       (return (tup (+ p 2) depth))))
	   *twin-primes*)
       (error "Not enough primes to compute new table size"))))

(dm copy-to-new-vector ((table <tab>) new-vector => <any>) ;; TODO: => (tup)
  (do-keyed
    (fun (k v)
      (lab return
	(let (((tup test-function hash-function) (table-protocol table))
	      ((tup (hash <int>) state) (hash-function k))
	      (new-n-buckets         (%n-buckets new-vector))
	      (new-bucket-depth      (%bucket-depth new-vector))
	      (new-primary-modulus   (%primary-modulus new-vector))
	      (new-secondary-modulus (%secondary-modulus new-vector))
	      ((tup new-bucket-index new-bucket-offset)
	       (hash-moduli hash new-primary-modulus new-secondary-modulus)))
	  ;; (trace out "VISITING (%= %=)\n" k v)
	  ;; Search each bucket
	  (rep outer (((probes <int>) 0))
	    (when (< probes new-n-buckets)
	      (let ((bucket-start (* new-bucket-index (* new-bucket-depth 2))))
		(rep inner (((i <int>) 0) ((index <int>) bucket-start))
		  (when (< i new-bucket-depth)
		    (let ((this-key (elt new-vector index)))
		      (when (== this-key $empty-cell-marker)
			;; (trace out "COPYING TO (%= %=) %=\n" k v index)
			(set (elt new-vector index) k)
			(set (elt new-vector (+ index new-bucket-depth)) v)
			(return #f))
		      (inner (+ i 1) (+ index 1)))))
		;; No room in this bucket try the next one
		(dec new-bucket-index new-bucket-offset)
		(when (neg? new-bucket-index)
		  (inc new-bucket-index new-n-buckets))
		(outer (+ probes 1)))))
	  ;; Table totally full???  That's not right
	  (error "The table is totally full this shouldn't happen"))))
    table))

;;; HASHING FUNCTIONS

;; TODO: NEED ADDRESS-OF

(dv $permanent-hash-state #f)
(df current-gc-state () $permanent-hash-state)

(dm id-hash (x)
  (tup (address-of x) (current-gc-state)))

(dm id-hash ((x <log>))
  (tup (if x 131 149) $permanent-hash-state))

;; TODO: CHECK FOR CORRECTNESS
(df rot ((x <int>) (a <int>) => <int>)
  (logior (ash x (neg a)) (ash x a)))

(dm id-hash ((x <int>))
  ;; Offset it so that 0 doesn't hash to 0
  (tup (abs (+ (- (rot x 15) x) 31)) $permanent-hash-state))
  
(dm id-hash ((x <chr>))
  (id-hash (as <int> x)))

(dm id-hash ((x <flo>))
  (tup (+ (flo-bits x) 89) $permanent-hash-state))

(df case-insensitive-string-hash ((x <str>) => (tup (hi <int>) hash-state))
  (let ((s 0) (e (len x)))
    (rep loop (((i <int>) s) ((hash <int>) 0))
      (if (< i e)
	  (loop (+ i 1)
		(modulo (+ (ash hash 6) 
			   (logand (as <int> (elt x i)) 159)) ;; #x9f
			970747))
	  (tup hash $permanent-hash-state)))))

(df case-insensitive-string-equal ((x <str>) (y <str>) => <log>)
  (let ((sy 0) (ey (len y)))
    (when (== (len x) (- ey sy))
      (rep loop (((i <int>) sy))
	(or (== i ey)
	    (let (((cx <chr>) (elt x (- i sy)))
		  ((cy <chr>) (elt y i)))
	      (and (or (== cx cy) (== (as-lowercase cx) (as-lowercase cy)))
		   (loop (+ i 1)))))))))

(dv <str-tab> (isa <tab>))

(dm table-protocol ((_ <str-tab>) => (tup (equal-fun <fun>) (hash-fun <fun>)))
  (tup case-insensitive-string-equal case-insensitive-string-hash))

(dv symbols (fab <str-tab> 3000))

(dp booted-fab-sym-using (name given-sym)
  (let ((sym (elt symbols name)))
    (if (== sym nul)
	(set (elt symbols name) (or given-sym (%sym name)))
	sym)))

(df booted-fab-sym (name)
  (booted-fab-sym-using name #f))

(df boot-symbols ()
  (rep boot ((syms %symbols))
    (unless (empty? syms)
      (let ((sym (head syms))) (booted-fab-sym-using (%sym-nam sym) sym))
      (boot (tail syms)))))

(boot-symbols)

(set fab-sym booted-fab-sym)

