;;;; Copyright (c) 2001 Jonathan Bachrach

(use boot)
(use macros)
(use proto/math)
(use proto/types)
(use runtime1)
(use proto/collections/collection)
(use proto/collections/sequence)
(use proto/collections/opts)
(use proto/collections/list)
(use proto/collections/buffer)
(use proto/collections/table)
(use proto/ports)

;;; APP

; (df napp (proc|<fun> nexts args|...)
;   (if (== (len args) 1)
;       (%%apply proc nexts (as <vec> (elt args 0)))
;       (let ((ilen|<int> (- (len args) 1))
;             (lelt|<seq> (elt args ilen))
;             (tlen|<int> (+ ilen (len lelt)))
;             (out|<vec>  (fab <vec> tlen)))
;         (rep loop ((i 0))
;           (if (== i ilen)
;               #f
;               (seq
;                 (set (elt out i) (elt args i))
;                 (loop (+ i 1)))))
;         (rep loop ((s (ini-state lelt)) (i ilen))
;           (if (fin-state? lelt s)
;               #f
;               (seq (set (elt out i) (now-elt lelt s))
;                    (loop (nxt-state lelt s) (+ i 1)))))
;          (%%apply proc nexts out))))


;;; MACRO SUPPORT

(df match-empty-list (x|<lst> fail|<fun>)
  (if (== x '())
      '()
      (fail "Match Empty Failure of %=" x)))

(df match-unquote (x|<lst> fail|<fun>)
  (if (== x '())
      (fail "Match Failure Empty List on Unquote")
      (head x)))

(df match-atom (x|<lst> pat fail|<fun>)
  (if (== x '())
      (fail "Match Failure Empty List on %=" pat)
      (let ((exp (head x)))
	(if (== exp pat)
	    (tail x)
	    (fail "Match Failure of %= on %=" exp pat)))))

(df match-sublist (x|<lst> fail|<fun>)
  (def x (head x))
  (if (isa? x <lst>)
      x
      (fail "Match Failure on Sub List on %=" x)))

(dm cat-sym (x|...  => <sym>)
  (as <sym> (fold (fun (r e) (cat r (to-str e))) "" x)))

(dv *gensym-counter* 1000)

(dm gensym (=> <sym>)
  (cat-sym "x-" (incf *gensym-counter*)))

(dm fab-setter-name (x|<sym> => <sym>)
  (cat-sym x "-setter"))

(dm var-name (x|<sym>) x)

(dm var-name (x|<lst>) (elt x 0))

(dm var-type (x|<sym>) '<any>)

(dm var-type (x|<lst>) (elt x 1))

;;; FUNCTIONAL 

(dm identity (x) x)

(dm compose (fx|<fun> fy|<fun> => <fun>)
  (fun ((args ...)) (fx (app fy args))))

;;FIXME:
;; the let is to work around compiler bug:
;;   it doens't do extent analysis of restargs like it should.

(dm rcurry (f|<fun> curried|... => <fun>)
  (def savedcurried (as <vec> curried))
  (fun ((args ...)) (app f (cat '() args savedcurried))))

(dm curry (f|<fun> curried|... => <fun>)
  (def savedcurried (as <vec> curried))
  (fun ((args ...)) (app f (cat '() savedcurried args))))

(dm always (x => <fun>)
  (fun ((args ...)) x))

(dm spread (x => <fun>)
  (fun ((t <tup>)) (app x t)))

;;; CONDITIONS

(dc <condition> (<any>))

(dm default-handler (c|<condition>)
  #f)

(dm describe-condition (c|<condition> => <str>)
  (format-to-string "Anonymous condition %=" c))

(dm default-handler-description ((cond-type (t< <condition>)) => <str>)
  (format-to-string "Anonymous handler for %s" cond-type))

(dm build-condition-interactively
    ((cond-type (t< <condition>)) in out => <condition>)
  (new cond-type))

(dc <simple-condition> (<condition>))
  (dp condition-message (x|<simple-condition> => <str>)   "")
  (dp condition-arguments (x|<simple-condition> => <lst>) '())

(dm describe-condition (c|<simple-condition> => <str>)
  (app format-to-string (condition-message c)
                          (condition-arguments c)))

(dm build-condition-interactively
    ((cond-type (t< <simple-condition>)) in out => <condition>)
  (def cond (sup cond-type in out))
  (format out "Condition format string: ")
  (set (condition-message cond) (read in))
  (format out "Condition format arguments: ")
  (set (condition-arguments cond) (read in))
  cond)

(dc <serious-condition> (<condition>))

(dm default-handler (c|<serious-condition>)
  (format out "%s\n" (describe-condition c))
  (%invoke-debugger c))

(dc <error> (<serious-condition>))

(dc <simple-error> (<error> <simple-condition>))

(export
  <condition>
  default-handler
  describe-condition
  condition-message
  condition-arguments
  
  default-handler-description
  build-condition-interactively
  <simple-condition>
  <serious-condition>
  <error>
  <simple-error>)

(dc <restart> (<condition>))

(dm default-handler-description ((cond-type (t< <restart>)) => <str>)
  (format-to-string "Anonymous restart of type %s" cond-type))

(dc <incongruent-method-error> (<error>))
  (dp incongruent-method-error-generic (x|<incongruent-method-error> => <gen>))
  (dp incongruent-method-error-method (x|<incongruent-method-error> => <met>))

(dm describe-condition (c|<incongruent-method-error> => <str>)
  (format-to-string "Method %= incongruent with generic %=.\n"
                    (incongruent-method-error-method c)
                    (incongruent-method-error-generic c)))

(dc <replace-generic-restart> (<restart>))

(dm default-handler-description 
    ((cond-type (t< <replace-generic-restart>)) => <str>)
  "Replace the generic function with an empty, congruent one")

(export
  <restart>
  <replace-generic-restart>
  default-handler-description
  build-condition-interactively)

;;;; Handler Info
;;;; Debugger-level info used for describing handlers and calling them
;;;; interactively.  This probably doesn't need to be an actual class;
;;;; a few well-chosen props on <handler> might work better.

(dc <handler-info> (<any>))

(dm describe-handler (info|<handler-info> condition-type => <str>)
  (default-handler-description condition-type))

(dm build-condition-for-handler-interactively
    (info|<handler-info> condition-type in out => <condition>)
  (build-condition-interactively condition-type in out))

(dv $default-handler-info (new <handler-info>))

(dc <simple-handler-info> (<handler-info>))
  (dp handler-info-message (x|<simple-handler-info> => <str>))
  (dp handler-info-arguments (x|<simple-handler-info> => <lst>) '())

(dm describe-handler (info|<simple-handler-info> condition-type => <str>)
  (app format-to-string
         (handler-info-message info)
         (handler-info-arguments info)))

(export
  <handler-info>
  describe-handler
  build-condition-for-handler-interactively
  $default-handler-info
  <simple-handler-info>
  handler-info-message
  handler-info-arguments
  describe-handler)

;;;; Handlers

(dv *current-handlers* '())

(dc <handler> (<any>))
  (dp handler-condition-type (x|<handler> => (t< <condition>)))
  (dp handler-info (x|<handler> => <handler-info>))
  (dp handler-test (x|<handler> => <fun>))
  (dp handler-function (x|<handler> => <fun>))

(df fab-handler
    ((type (t< <condition>)) info|<handler-info> test|<fun> f|<fun> => <handler>)
  (new <handler>
    handler-condition-type type
    handler-info           info
    handler-test           test
    handler-function       f))

(df handler-active? (handler|<handler> => <log>)
  ((handler-test handler)))

(df handler-matches? (handler|<handler> condition|<condition> => <log>)
  (and (isa? condition (handler-condition-type handler))
       (handler-active? handler)))

(df %with-monitor
    ((type (t< <condition>)) info|<handler-info> test-fun|<fun>
     user-handler|<fun> main-fun|<fun>)
  (esc _unwind-exception_
    (def _original-handlers_ *current-handlers*)
    (loc ((_handler-function_ (condition _next-handler_)
	    (esc _resume_
              (user-handler condition _resume_)
              (_next-handler_))))
      (pushf *current-handlers*
             (fab-handler type info test-fun _handler-function_))
      (fin (main-fun) (set *current-handlers* _original-handlers_)))))

;;; Pass a signal to a list of handlers for processing.
(df signal-handler-list (condition|<condition> handlers|<lst> => <any>)
  (if (empty? handlers)
      (default-handler condition)
      (let ((handler (head handlers))
            (remaining (tail handlers)))
        (if (handler-matches? handler condition)
            ((handler-function handler)
             condition (fun () (signal-handler-list condition remaining)))
            (signal-handler-list condition remaining)))))

(dm sig (condition|<condition> args|...)
  (signal-handler-list condition *current-handlers*))

(dm sig (c|<str> args|...) 
  (sig (new <simple-condition> 
         condition-message c condition-arguments (as <lst> args))))

;; (df error (message|<str> args|...)
;;   (%break (%su message)))

(dm error (c|<error> args|...)
  (sig c))

(dm error (c|<str> args|...)
  (error (new <simple-error> 
           condition-message c condition-arguments (as <lst> args))))

(df wrong-number-arguments-error (fun|<fun> n|<int>)
  (error "%= CALLED WITH %= ARGUMENTS EXPECTED %=" fun n (fun-arity fun)))

(df unknown-function-error (fun|<fun>)
  (error "UNKNOWN FUNCTION %= CALLED" fun))

(df type-error (arg type)
  (error "TYPE ERROR %= SHOULD BE A %=" arg type))

(df incongruent-method-error (gen|<gen> met|<met> => #f)
  (error (new <incongruent-method-error>
           incongruent-method-error-generic gen
           incongruent-method-error-method  met)))

;;; INTERACTIVE HANDLER MUNGING

;;; Apply 'f' to all handlers whose type is a subtype of 'type'.
(df do-handlers-of-type ((type (t< <condition>)) f|<fun> => #f)
  (rep search ((handlers *current-handlers*))
    (if (empty? handlers)
        #f
        (let ((handler (head handlers))
              (remaining (tail handlers)))
          (when (and (subtype? (handler-condition-type handler) type)
                     (handler-active? handler))
            (f handler))
          (search remaining)))))

;;; Print out descriptions all active handlers matching 'type' (numbered
;;; from 1) and return a sequence of those handlers in the same order
;;; (indexed from zero).  This allows us to keep track of which handlers
;;; correspond to which user-visible numbers.
(df list-handlers ((type (t< <condition>)) out => <buf>)
  (def i          1)
  (def applicable (fab <buf> 0))
  (do-handlers-of-type type
    (fun (handler)
      (format out "%d. %s.\n" i
              (describe-handler (handler-info handler)
                                (handler-condition-type handler)))
      (push-last! applicable handler)
      (incf i)))
  applicable)

;;; Attempt to invoke the specified handler directly, bypassing any other
;;; handlers "in the way". 
(df invoke-handler-interactively (handler|<handler> in out => <any>)
  (def condition
    (build-condition-for-handler-interactively
     (handler-info handler) (handler-condition-type handler) in out))
  (unless (handler-matches? handler condition)
    (error "Handler %= does not match condition %=" handler condition))
  (rep search ((handlers *current-handlers*))
    (if (empty? handlers)
        (error "Handler %= is not installed" handler)
        (let ((current (head handlers))
              (remaining (tail handlers)))
          (if (== handler current)
              ((handler-function handler)
               condition (fun () (signal-handler-list condition remaining)))
              (search remaining))))))

;;; Chose a handler matching 'type', and call it interactively.
(df choose-handler ((type (t< <condition>)) in out => <any>)
  (def handlers (list-handlers type out))
  (format out "Please pick a handler: ")
  (def n (- (read in) 1))
  (when (or (< n 0) (>= n (len handlers)))
    (error "No such handler %d" n))
  (invoke-handler-interactively (elt handlers n) in out))

;;; Enable some low-level restarts, now that it's safe to do so.
(set *restarts-ok?* #t)

(export
  list-handlers
  invoke-handler-interactively
  choose-handler)

;;; LOCATIVES

;; (dc <loc> (<any>))
;;   (dp loc-dat (x|<loc> => <any>))

(df loc-val (x|<loc> => <any>)
  (%loc-val x))

(df loc-val-setter (z x|<loc> => <any>)
  (set (%loc-val x) z))

;;; APPLICATION INPUT

(df app-filename () (%app-filename))

(df app-args () (%app-args))

(dv symbols (fab <str-tab> 10000))

(dl booted-fab-sym-using (name given-sym)
  (or (elt-or symbols name #f)
      (set (elt symbols name) (or given-sym (new <sym> sym-name name)))))

(df booted-fab-sym (name)
  (booted-fab-sym-using name #f))

(df boot-symbols ()
  (rep boot ((syms %symbols))
    (unless (empty? syms)
      (def sym (head syms)) (booted-fab-sym-using (sym-name sym) sym)
      (boot (tail syms)))))

(boot-symbols)

(set fab-sym booted-fab-sym)

(need-implementation
  read
  format
  format-to-string)

;; TODO: TEMPORARY EXPORTS
(export
  napp
  match-empty-list
  match-unquote
  match-atom
  match-sublist
  cat-sym
  *gensym-counter*
  gensym
  fab-setter-name
  var-name
  var-type
  identity
  compose
  rcurry
  curry
  always
  spread
  loc-val
  loc-val-setter
  app-filename
  app-args
  sig
  error
  <handler>
  handler-function
  fab-handler
  handler-matches?
  %with-monitor
  )

;(export
"  always
  app-args app-filename
  as
  ascii-limit ascii-whitespaces
  buf <buf>
  ceil ceiling/
  describe-condition
  port-contents
  case-insensitive-string-hash
  case-insensitive-string-equal
  cat cat2 cat!
  char->ascii
  ready?
  compose
  <condition> condition-arguments condition-message
  current-gc-state
  curry
  default
  default-handler
  del-vals
  del-dups
  del zap
  do do2 do3 do-keyed
  elt elt-setter elt-or low-elt low-elt-setter
  empty empty?
  eof-object eof-object?
  error <error> <simple-error>
  even?
  fab fabs
  <file-port> <file-in-port> 
  <file-out-port> 
  fill
  fin-state?
  first-then
  find
  flo-bits
  floor floor/
  force-out
  from from-below from-to from-by from-to-by from-below-by from-above
  from-above from-above-by
  gensym
  <handler> handler-function fab-handler handler-matches?
  id-hash
  identity
  in
  <incongruent-method-error>
  ini-state copy-state
  <in-port> port-line 
  keys
  last
  len len-setter len/fill-setter
  list <list>
  loc-val loc-val-setter
  | ^ & ~ bit?
  lower? upper?
  lst
  fab-setter-name
  cat-sym
  map map2 map-keyed
  <map>
  fab-map
  match-atom match-empty-list match-sublist match-unquote
  max min 
  modulo remainder
  mem?
  napp
  neg neg?
  newline
  now-elt now-elt-setter
  now-key
  nul?
  num-to-str
  digit?
  nxt-state
  odd?
  out
  <out-port>
  pair
  pick
  peek
  $permanent-hash-state
  <port> port-index
  pos pos?
  pop pop-last! push push-last!
  *print-base*
  <range>
  rcurry
  get
  fold fold+
  rev!
  rev
  round round/
  <serious-condition>
  sig
  <simple-condition>
  <step>
  str
  <str-tab>
  str-to-num
  <str-port> <str-in-port> <str-out-port>
  sub sub-setter
  <tab>
  tab-growth-factor tab-growth-threshold tab-shrink-threshold tab-test tab-hash
  to-digit
  to-str
  trunc
  trunc/
  tup
  t+ t= t< t?
  var-name var-type
  vec
  %with-monitor
  put puts
  zero?
  )
"
