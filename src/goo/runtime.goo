;;;; Copyright (c) 2001 Jonathan Bachrach

;;; MACRO SUPPORT

(df match-empty-list ((x <lst>) (fail <fun>))
  (if (== x '())
      '()
      (fail "Match Empty Failure of %=" x)))

(df match-unquote ((x <lst>) (fail <fun>))
  (if (== x '())
      (fail "Match Failure Empty List on Unquote")
      (head x)))

(df match-atom ((x <lst>) pat (fail <fun>))
  (if (== x '())
      (fail "Match Failure Empty List on %=" pat)
      (let ((exp (head x)))
	(if (== exp pat)
	    (tail x)
	    (fail "Match Failure of %= on %=" exp pat)))))

(df match-sublist ((x <lst>) (fail <fun>))
  (let ((x (head x)))
    (if (isa? x <lst>)
	x
        (fail "Match Failure on Sub List on %=" x))))

(dm make-sym ((x ...)  => <sym>)
  (as <sym> (reduce (fun (r e) (cat r (to-str e))) "" x)))

(dv *gensym-counter* 1000)

(dm gensym (=> <sym>)
  (make-sym "x-" (set *gensym-counter* (+ *gensym-counter* 1))))

(dm make-setter-name ((x <sym>) => <sym>)
  (make-sym x "-setter"))

(dm var-name ((x <sym>)) x)

(dm var-name ((x <lst>)) (elt x 0))

(dm var-type ((x <sym>)) '<any>)

(dm var-type ((x <lst>)) (elt x 1))

;;; DYNAMIC BINDING

(df type-or ((args ...)) <any>) ;; TODO: FOR REAL

;;; <any>

(dm nyi-error ()
  (nyi) ;; nyi nyi
  )

(dm to-str ((x <any>) => <str>)
  (let ((name (%binding-name x)))
    (if name 
        (cat "$" (to-str name))
        (cat "{ obj(" (to-str (object-parents x)) ") }"))))

;;; BOTTOM

(dv bot (isa <any>)) ;; todo: should be disjoint from <any>

;;; BOOLEAN

(dm to-str ((x #t) => <str>) "#t")
(dm to-str ((x #f) => <str>) "#f")

(dm as (type x => <any>)
  (if (isa? x type) 
      x
      (error "NO AS METHOD FOR %= AND %=" type x)))

;; TODO: DEAL WITH ==

(dm == (x y => <log>) (%bb (%eq? x y)))

(dm = (x y => <log>) (== x y))

(dm ~= (x y => <log>)
  (not (= x y)))

(dm ~== (x y => <log>)
  (not (== x y)))

(dm > (x y => <log>)
  (< y x))

(dm <= (x y => <log>)
  (not (< y x)))

(dm >= (x y => <log>)
  (not (< x y)))

(dm min (x y => <num>)
  (if (< x y) x y))

(dm max (x y => <num>)
  (if (> x y) x y))

;;; character

;; (dv <chr> (isa <any>))
;;   (slot <chr> (%chr-val <int>))

(dm as ((_ <chr>) (i <int>) => <chr>)
  (%cb (%iu i)))

(dm as ((_ <int>) (c <chr>) => <int>)
  (%ib (%cu c)))

(dm < ((x <chr>) (y <chr>) => <log>)
  (%bb (%c< (%cu x) (%cu y))))

(dm == ((x <chr>) (y <chr>) => <log>)
  (%bb (%c= (%cu x) (%cu y))))

(dm lowercase? ((x <chr>) => <log>)
  (let ((code (as <int> x)))
    (if (>= code (as <int> #\a))
        (<= code (as <int> #\z))
        #f)))

(dm uppercase? ((x <chr>) => <log>)
  (let ((code (as <int> x)))
    (if (>= code (as <int> #\A))
        (<= code (as <int> #\Z))
        #f)))

(dm as-lowercase ((x <chr>) => <chr>)
  (if (uppercase? x)
      (as <chr> (+ (as <int> x) (- (as <int> #\a) (as <int> #\A))))
      x))

(dm as-uppercase ((x <chr>) => <chr>)
  (if (lowercase? x)
      (as <chr> (+ (as <int> x) (- (as <int> #\A) (as <int> #\a))))
      x))

(dm to-str ((x <chr>) => <str>)
  (fabs <str> x))

(dm alphabetic? ((x <chr>) => <log>)
  (or (and (<= #\a x) (<= x #\z))
      (and (<= #\A x) (<= x #\Z))))

(dm numeric? ((x <chr>) => <log>)
  (and (<= #\0 x) (<= x #\9)))

(dm to-digit ((digit <chr>) => <int>)
  (- (char->ascii digit) (char->ascii #\0)))

;;; NUMBER

(dg contagious-type ((x <num>) (y <num>) => <num>))

(dg contagious-call ((f <fun>) (x <num>) (y <num>) => <any>))

(dm contagious-call ((f <fun>) (x <num>) (y <num>) => <any>)
  (let ((type (contagious-type x y)))
    (f (as type x) (as type y))))

(dm < ((x <num>) (y <num>) => <log>)
  (contagious-call < x y))

(dm + ((x <num>) (y <num>) => <num>)
  (contagious-call + x y))

(dm - ((x <num>) (y <num>) => <num>)
  (contagious-call - x y))

(dm * ((x <num>) (y <num>) => <num>)
  (contagious-call * x y))

(dm floor ((x <num>) => (tup <int> (rem <num>)))
  (contagious-call floor/ x 1))

(dm ceiling ((x <num>) => (tup <int> (rem <num>)))
  (contagious-call ceiling/ x 1))

(dm round ((x <num>) => (tup <int> (rem <num>)))
  (contagious-call round/ x 1))

(dm truncate ((x <num>) => (tup <int> (rem <num>)))
  (contagious-call truncate/ x 1))

(dm floor/ ((real <num>) (divisor <num>) => (tup <int> (remainder <num>)))
  (let (((tup (integer <int>) (remainder <num>)) (truncate/ real divisor)))
    (if (and (not (zero? remainder))
	     (if (neg? divisor)
		 (pos? real)
		 (neg? real)))
	(tup (- integer 1) (+ remainder divisor))
	(tup integer remainder))))

(dm ceiling/ ((real <num>) (divisor <num>) => (tup <int> (remainder <num>)))
  (let (((tup (integer <int>) (remainder <num>)) (truncate/ real divisor)))
    (if (and (not (zero? remainder))
	     (if (neg? divisor)
		 (neg? real)
		 (pos? real)))
	(tup (+ integer 1) (- remainder divisor))
	(tup integer remainder))))

(dm round/ ((real <num>) (divisor <num>) => (tup <int> (remainder <num>)))
  (let (((tup (integer <int>) (remainder <num>)) (truncate/ real divisor))
	((threshold <num>) (/ (abs divisor) 2.0)))
    (if (or (> remainder threshold) 
	   (and (= remainder threshold) (odd? integer)))
	(if (neg? divisor)
	    (tup (- integer 1) (+ remainder divisor))
	    (tup (+ integer 1) (- remainder divisor)))
	(if (let ((minus-threshold (neg threshold)))
	      (or (< remainder minus-threshold)
		  (and (= remainder minus-threshold) (odd? integer))))
	    (if (neg? divisor)
		(tup (+ integer 1) (- remainder divisor))
		(tup (- integer 1) (+ remainder divisor)))
	    (tup integer remainder)))))

(dm truncate/ ((real <num>) (divisor <num>) => (tup <int> (remainder <num>)))
  (contagious-call truncate/ real divisor))

(dm modulo ((real <num>) (divisor <num>) => <num>)
  (let (((tup _ (remainder <num>)) (floor/ real divisor)))
    remainder))

(dm remainder ((real <num>) (divisor <num>) => <num>)
  (let (((tup _ (remainder <num>)) (truncate/ real divisor)))
    remainder))

(dm pos? ((x <num>) => <log>)
  (> x 0))

(dm zero? ((x <num>) => <log>)
  (= x 0))

(dm neg? ((x <num>) => <log>)
  (< x 0))

(dm neg ((x <num>) => <num>)
  (- 0 x))

(dm abs ((x <num>) => <num>)
  (if (neg? x) (neg x) x))

(dm to-str ((x <num>) => <str>)
  (num-to-str x))

(dm str-to-num ((string <str>) => <any>) ;; (false-or <num>) ;; S48
  (let ((s 1)
	(d 0)
	(n 0)
	(i 0)
	(scale 1)
	(length (len string))
	(seen-decimal-point? #f)
	(radix 10))
    (loc ((match (char)
	    (if (and (< i length) (= (elt string i) char))
		(seq (set i (+ i 1)) #t)
		#f))
	  (match-digit! (_)
	    (lab return
	      (loc ((fail!! () (return #f)))
		(if (>= i length) (fail!!))
		(let ((char (elt string i)))
		  (if (= char #\.)
		      (if seen-decimal-point?
			  (error "string->number: Two decimal points: %="
				 string)
			  (seq
			   (set seen-decimal-point? #t)
			   (set i (+ i 1))
			   (if (>= i length) (fail!!))
			   (set char (elt string i)))))
		  (if (not (numeric? char)) (fail!!))
		  (set d (to-digit (elt string i)))
		  (set i (+ i 1))
		  (if seen-decimal-point?
		      (set scale (* scale radix)))
		  #t))))
	  (looking-at-alphabetic? ()
	    (if (and (< i length) 
		     (alphabetic? (elt string i)))
		#t
		#f)))
  ;; Now we get to use all this matching machinery
  (and (or (match #\+)
	   (and (match #\-) (set s -1))
	   #t)
       (and (match-digit! d) (set n d))
       (rep loop ()
	 (if (and (match-digit! d) (set n (+ (* n radix) d)))
	     (loop)
	     #t))
       (= i length) ;; consumed all chars
       (let ((f (* (as <flo> s) (/ (as <flo> n) (as <flo> scale)))))
	 (if seen-decimal-point? f (1st (truncate f))))))))

;;; <INT>

(dm contagious-type ((x <int>) (y <int>) => <int>)
  <int>)

(dm contagious-type ((x <flo>) (y <flo>) => <flo>)
  <flo>)

(dm contagious-type ((x <int>) (y <flo>) => <flo>)
  <flo>)

(dm contagious-type ((x <flo>) (y <int>) => <flo>)
  <flo>)

(dm == ((x <int>) (y <int>) => <log>)
  (%bb (%i= (%iu x) (%iu y))))

(dm < ((x <int>) (y <int>) => <log>)
  (%bb (%i< (%iu x) (%iu y))))

(dm + ((x <int>) (y <int>) => <int>)
  (%ib (%i+ (%iu x) (%iu y))))

(dm - ((x <int>) (y <int>) => <int>)
  (%ib (%i- (%iu x) (%iu y))))

(dm * ((x <int>) (y <int>) => <int>)
  (%ib (%i* (%iu x) (%iu y))))

(dm floor ((x <int>) => (tup <int> (remainder <int>)))
  (tup x 0))

(dm ceiling ((x <int>) => (tup <int> (remainder <int>)))
  (tup x 0))

(dm round ((x <int>) => (tup <int> (remainder <int>)))
  (tup x 0))

(dm truncate ((x <int>) => (tup <int> (remainder <int>)))
  (tup x 0))

(dm truncate/ ((x <int>) (y <int>) => (tup <int> (remainder <int>)))
  (let ((result (%ib (%it/ (%iu x) (%iu y)))))
    (tup result (- x (* result y)))))

(dm modulo ((x <int>) (y <int>) => <int>)
  (%ib (%im (%iu x) (%iu y))))

(dm logior ((x <int>) (y <int>) => <int>)
  (%ib (%iv (%iu x) (%iu y))))

(dm logxor ((x <int>) (y <int>) => <int>)
  (%ib (%i^ (%iu x) (%iu y))))

(dm logand ((x <int>) (y <int>) => <int>)
  (%ib (%i& (%iu x) (%iu y))))

(dm lognot ((x <int>) => <int>)
  (%ib (%i! (%iu x))))

(dm logbit? ((o <int>) (x <int>) => <int>)
  (%ib (%i? (%iu o) (%iu x))))

(dm even? ((x <int>) => <log>)
  (zero? (logand x 1)))

(dm odd? ((x <int>) => <log>)
  (not (even? x)))

(dm ash ((x <int>) (a <int>) => <int>)
  (if (neg? a)
      (%ib (%i>> (%iu x) (%iu a)))
      (%ib (%i<< (%iu x) (%iu a)))))

(dm lsh ((x <int>) (a <int>) => <int>)
  (if (neg? a)
      (%ib (%i>>> (%iu x) (%iu a)))
      (%ib (%i<<< (%iu x) (%iu a)))))

(dm power-of-two-ceiling ((x <int>) => <int>)
  (rep search (((po2 <int>) 1))
    (if (> po2 x)
	po2
	(search (+ po2 po2)))))

(dv $digit-to-char "0123456789abcdefghijklmnopqrstuvwxyz")

(dv *print-base* 10)

(dv epsilon 0.000001)

(dm decode-radix-option ((rest <opts>) (default <int>) caller-name => <int>)
  (if (empty? rest)
      default
      (if (= (len rest) 1)
	  (head rest)
	  (error "too many arguments: %=, %=" caller-name rest))))

;;  (mif (() rest)
;;       default
;;       (mif ((,radix) rest)
;;            radix
;;            (error "too many arguments: %=, %=" caller-name rest)))

(dm num-to-str ((num <int>) (radix-option ...) => <str>)
  (let ((radix
	 (decode-radix-option radix-option *print-base* 'num-to-str))
        (s (if (< num 0) -1 1))
        (digit-list
         (rep loop ((digit-list '()) (num (* num s)))
           (if (= num 0)
               digit-list
	       (let ((digit (elt $digit-to-char (remainder num radix))))
		 (loop (pair digit digit-list)
		       (1st (truncate/ num radix))))))))
    (as <str> (if (< s 0)
		  (pair #\- digit-list)
		  (if (= num 0) "0" digit-list)))))

;;; FLO

(df flo-bits ((x <flo>) => <int>)
  (%ib (%flo-bits (%fu x))))

(dm as ((_ <flo>) (x <int>) => <flo>)
  (%fb (%fi2f (%iu x))))

(dm == ((x <flo>) (y <flo>) => <log>)
  (%bb (%f= (%fu x) (%fu y))))

(dm < ((x <flo>) (y <flo>) => <log>)
  (%bb (%f< (%fu x) (%fu y))))

(dm + ((x <flo>) (y <flo>) => <flo>)
  (%fb (%f+ (%fu x) (%fu y))))

(dm - ((x <flo>) (y <flo>) => <flo>)
  (%fb (%f- (%fu x) (%fu y))))

(dm * ((x <flo>) (y <flo>) => <flo>)
  (%fb (%f* (%fu x) (%fu y))))

(dm / ((x <flo>) (y <flo>) => <flo>)
  (%fb (%f/ (%fu x) (%fu y))))

(dm truncate/ ((x <flo>) (y <flo>) => (tup <int> (remainder <flo>)))
  (let ((divided (/ x y))
	(result  (%ib (%ft (%fu x)))))
    (tup result (* y (- divided (as <flo> result))))))

(dm num-to-str ((num <flo>) (radix-option ...) => <str>)
  (let ((radix
	 (decode-radix-option radix-option *print-base* 'num-to-str))
        (s (if (< num 0) -1 +1))
        (p (* num s))
        (string "")
        (e (rep loop ((p p) (e 0))
             (let (((tup i) (truncate p)))
               (if (< (- p i) epsilon)
                   (seq (set string (num-to-str i radix)) e)
                   (loop (* p radix) (+ e 1))))))
        (length (len string)))
    (set string
         (if (= e 0)
             (cat string ".0")
             (if (= e length)
                 (cat "0." string)
                 (if (< e length)
                     (cat (sub string 0 (- length e)) "." 
			  (sub string (- length e) length))
                     (cat (sub "0.0000000000000" 0 (+ (- e length) 2))
			  string)))))
    (if (< s 0) (cat "-" string) string)))

;;; COLLECTION

;;; TODO: NEED TEST ARGS AND NOT-FOUND HANDLERS

(dm empty? ((c <col>) => <log>)
  (= (len c) 0))

(dm empty ((c <col>) => <col>)
  (isa c))

(dm default ((c <col>) => <col>)
  #f)

(dm = ((c1 <col>) (c2 <col>) => <log>)
  (rep eq ((s1 (ini-state c1)) (s2 (ini-state c2)))
    (if (fin-state? c1 s1)
	(fin-state? c2 s2)
        (and (= (now-elt c1 s1)  (now-elt c2 s2))
             (eq (nxt-state c1 s1) (nxt-state c2 s2))))))

(dm fab ((c <col>) (s <int>) => bot)
  (nyi-error))

(dm as ((p <col>) (x <col>) => <col>)
  (into (fab p (len x)) x 0 (len x)))

(dm do-key-vals ((fn <fun>) (key-vals <opts>) => (tup))
  (rep rep (((key-vals <opts>) key-vals))
    (unless (empty? key-vals)
      (fn (head key-vals) (head (tail key-vals)))
      (rep (tail (tail key-vals))))))

(dm fabs ((p <col>) (key-vals ...))
  (let ((x (isa p)))
    (do-key-vals (fun (key val) (set (elt x key) val)) key-vals)
    x))

(dm len ((x <col>) => <int>)
  (rep count ((s (ini-state x)) (i 0))
    (if (fin-state? x s) i (count (nxt-state x s) (+ i 1)))))

;; TODO: ALIGN COL'S
(dm alter ((dst <col>) (src <col>) => <col>)
  (rep in ((ds (ini-state dst)) (ss (ini-state src)))
    (if (if (fin-state? dst ds) #t (fin-state? src ss))
        dst
        (seq (set (now-elt dst ds)  (now-elt src ss))
             (in (nxt-state dst ds) (nxt-state src ss))))))

(dm fill ((dst <col>) val => <col>)
  (rep in ((ds (ini-state dst)))
    (if (fin-state? dst ds)
        dst
        (seq (set (now-elt dst ds)  val)
             (in (nxt-state dst ds))))))

(dm any? ((test <fun>) (c <col>) => <log>)
  (rep fnd ((state (ini-state c)))
    (if (fin-state? c state)
        #f
        (or (test (now-elt c state))
            (fnd (nxt-state c state))))))
  
(dm any2? ((test <fun>) (x <col>) (y <col>) => <log>)
  (rep fnd ((sx (ini-state x)) (sy (ini-state y)))
    (if (or (fin-state? x sx) (fin-state? y sy))
	#f
        (or (test (now-elt x sx) (now-elt y sy)) 
	    (fnd (nxt-state x sx) (nxt-state y sy))))))

(dm all? ((test <fun>) (c <col>) => <log>)
  (rep fnd ((state (ini-state c)))
    (or (fin-state? c state)
        (and (test (now-elt c state))
             (fnd (nxt-state c state))))))
  
(dm all2? ((test <fun>) (x <col>) (y <col>) => <log>)
  (rep fnd ((sx (ini-state x)) (sy (ini-state y)))
    (or (fin-state? x sx) (fin-state? y sy)
        (and (test (now-elt x sx) (now-elt y sy)) 
	     (fnd (nxt-state x sx) (nxt-state y sy))))))

(dm reduce ((combine <fun>) init (c <col>) => <col>)
  (rep red ((res init) (state (ini-state c)))
    (if (fin-state? c state)
        res
        (red (combine res (now-elt c state)) (nxt-state c state)))))
  
(dm reduce+ ((combine <fun>) (c <col>) => <col>)
  (let ((state (ini-state c))
        (init  (now-elt c state)))
    (rep red ((res init) (state (nxt-state c state)))
      (if (fin-state? c state)
          res
          (red (combine res (now-elt c state)) (nxt-state c state))))))
  
(dm find-key ((f <fun>) (c <col>) => <any>)
  (rep fnd ((state (ini-state c)))
    (if (fin-state? c state)
        nul
        (if (f (now-elt c state))
            (now-key c state)
            (fnd (nxt-state c state))))))
  
(dm map ((f <fun>) (c <col>) => <col>)
  (rep con ((res '()) (s (ini-state c)))
    (if (fin-state? c s)
        (as c (rev! res))
        (con (add res (f (now-elt c s))) (nxt-state c s)))))

(dm do ((f <fun>) (c <col>))
  (rep lop ((s (ini-state c)))
    (unless (fin-state? c s)
      (f (now-elt c s)) (lop (nxt-state c s)))))

(dm map2 ((f <fun>) (x <col>) (y <col>) => <col>)
  (rep con ((res '()) (sx (ini-state x)) (sy (ini-state y)))
    (if (or (fin-state? x sx) (fin-state? y sy))
        (as x (rev! res))
        (con (add res (f (now-elt x sx) (now-elt y sy))) 
	     (nxt-state x sx) (nxt-state y sy)))))

(dm do2 ((f <fun>) (x <col>) (y <col>))
  (rep lop ((sx (ini-state x)) (sy (ini-state y)))
    (unless (or (fin-state? x sx) (fin-state? y sy))
      (f (now-elt x sx) (now-elt y sy))
      (lop (nxt-state x sx) (nxt-state y sy)))))

(dm map-keyed ((f <fun>) (c <col>) => <col>)
  (rep con ((res '()) (s (ini-state c)))
    (if (fin-state? c s)
        (as c (rev! res))
        (con (add res (f (now-key c s) (now-elt c s))) (nxt-state c s)))))

(dm do-keyed ((f <fun>) (c <col>))
  (rep lop ((s (ini-state c)))
    (unless (fin-state? c s)
      (f (now-key c s) (now-elt c s)) (lop (nxt-state c s)))))

(dm mem? ((c <col>) x => <log>)
  (any? (fun (e) (== e x)) c))

;;; BAG

(dv <bag> (isa <col>))

;;; MAP

(dv <map> (isa <col>))

;;; ASSOCS

(dv <assocs> (isa <map>))
  (slot <assocs> (assocs-test <fun>) ==)
  (slot <assocs> (assocs-keys <lst>) '())
  (slot <assocs> (assocs-vals <lst>) '())

(dm fab ((c <assocs>) (s <int>) => <assocs>)
  (isa <assocs>))

(dm len ((x <assocs>) => <int>)
  (len (assocs-keys x)))

(dm elt ((x <assocs>) key => <any>)
  (rep fnd (((keys <lst>) (assocs-keys x)) ((vals <lst>) (assocs-vals x)))
    (if (== keys '())
        nul
        (if ((assocs-test x) key (head keys))
            (head vals)
            (fnd (tail keys) (tail vals))))))

(dm elt-setter (val (x <assocs>) key)
  (rep fnd (((keys <lst>) (assocs-keys x)) ((vals <lst>) (assocs-vals x)))
    (if (== keys '())
        (seq (set (assocs-keys x) (pair key (assocs-keys x)))
             (set (assocs-vals x) (pair val (assocs-vals x)))
          val)
        (if ((assocs-test x) key (head keys))
            (set (head vals) val)
            (fnd (tail keys) (tail vals))))))

;;; SEQUENCE

(dm as ((d <seq>) (s <seq>) => <seq>)
  (alter (fab d (len s)) s))

(df range-error ((x <seq>) (i <int>))
  ;; TODO: REAL CONDITION
  (error "RANGE ERROR %= %=" x i))

(df range-check ((x <seq>) (i <int>))
  (when (or (< i 0) (>= i (len x)))
    (range-error x i)))

(dm 1st ((x <seq>) => <any>) (elt x 0))

(dm 2nd ((x <seq>) => <any>) (elt x 1))

(dm 3rd ((x <seq>) => <any>) (elt x 2))

;; TODO: SHOULD USE BACKWARD ITERATION PROTOCOL???

(dm last ((x <seq>) => <any>) (elt x (- (len x) 1)))

(dg add ((c <seq>) x => <seq>))

(dm add! ((c <seq>) x => <seq>)
  (add c x))

(dm push ((c <seq>) x => <seq>)
  (add! c x))

(dm pos ((x <seq>) v => <any>) ;; TODO: (false-or <int>)
  (find-key (curry == v) x))

;; TODO: DEPRECATED
(dm into ((dst <seq>) (src <seq>) (from <int>) (below <int>) => <seq>)
  (rep in ((ds (ini-state dst)) (ss (ini-state src)))
    (if (if (fin-state? dst ds) #t (fin-state? src ss))
        dst
        (seq (set (now-elt dst ds)  (now-elt src ss))
             (in (nxt-state dst ds) (nxt-state src ss))))))

(dm sub-setter
    ((src <seq>) (dst <seq>) (from <int>) (below <int>) => <seq>)
  (let (((dst-len <int>) (len dst))
	((src-len <int>) (len src))
	((del-len <int>) (- below from)))
    (if (= del-len src-len) ;;  Can modify in place?
	(rep find ((ds (ini-state dst)) (i 0))
	  (if (= i from)
	      (rep in ((ds ds) (ss (ini-state src)))
		(if (fin-state? src ss)
		    dst
		    (seq (set (now-elt dst ds)  (now-elt src ss))
			 (in (nxt-state dst ds) (nxt-state src ss)))))
	      (find (nxt-state dst ds) (+ i 1))))
	;; Don't know if dst is stretchy so we have to create a new one
	(let ((new-len (+ (- dst-len del-len) src-len))
	      (ndst    (fab dst new-len)))
	  (rep copy ((nds (ini-state ndst)) (ds (ini-state dst)) (i 0))
	    (if (= i from)
		(rep insert ((nds nds) (ss (ini-state src)))
		  (if (fin-state? src ss)
		      (rep skip ((ds ds) (i from))
			(if (= i below)
			    (rep onto ((nds nds) (ds ds) (i below))
			      (if (= i dst-len)
				  ndst
				  (seq (set (now-elt ndst nds) (now-elt dst ds))
				       (onto (nxt-state ndst nds)
					     (nxt-state dst ds) (+ i 1)))))
			    (skip (nxt-state dst ds) (+ i 1))))
		      (seq (set (now-elt ndst nds) (now-elt src ss))
			   (insert (nxt-state ndst nds) (nxt-state src ss)))))
		(seq (set (now-elt ndst nds) (now-elt dst ds))
		     (copy (nxt-state ndst nds) (nxt-state dst ds) 
			   (+ i 1)))))))))

(dm rev ((x <seq>) => <seq>)
  (rep con ((seq '()) (sta (ini-state x)))
    (if (fin-state? x sta)
        (as x seq)
        (con (add seq (now-elt x sta)) (nxt-state x sta)))))

(dm cat2 ((x <seq>) (y <seq>) => <seq>)
  (rep con-x ((seq '()) (sta (ini-state x)))
    (if (fin-state? x sta)
        (rep con-y ((seq seq) (sta (ini-state y)))
          (if (fin-state? y sta)
              (as x (rev! seq))
              (con-y (add seq (now-elt y sta)) (nxt-state y sta))))
        (con-x (add seq (now-elt x sta)) (nxt-state x sta)))))

(dm cat ((x <seq>) (ss ...) => <seq>)
  (reduce cat2 x ss))

(dm cat! ((x <seq>) (more ...) => <seq>)
  (apply cat (pair x more)))

(dm cat! ((x <lst>) (more ...) => <lst>)
  ;; find first non-empty arg., to be destructively updated and returned
  (rep find-result (((r <lst>) x) ((more <lst>) more))
    (if (empty? more)
	r
	(if (empty? r)
	    ;; skip empty arg prefix
	    (find-result (as <lst> (head more)) (tail more)) 
	    ;; p points into r (which is growing).  p is non-empty.
	    (rep connect (((p <lst>) r) ((more <lst>) more))
	      (if (empty? more)
		  r
		  ;; find next non-empty arg. to add
		  (let ((x (as <lst> (head more))))
		    (if (empty? x)
			(connect p (tail more)) ;; skip empty arg
			;; cdr to end of p and side-effect tail
			(rep find-tail (((p <lst>) p))
			  (if (empty? (tail p))
			      (seq (set (tail p) x)         ;; DESTRUCTIVE UPDATE
				   (connect x (tail more))) ;; connect next arg
			      (find-tail (tail p))))))))))))

(dm sub ((x <seq>) (from <int>) (below <int>) => <seq>)
  (rep con-x ((seq '()) ((i <int>) 0) (sta (ini-state x)))
    (if (fin-state? x sta)
        (as x (rev! seq))
        (con-x (if (if (>= i from) (< i below)) (add seq (now-elt x sta)) seq)
               (+ i 1) (nxt-state x sta)))))

(dm pick ((test <fun>) (x <seq>) => <seq>)
  (rep con ((seq '()) (sta (ini-state x)))
    (if (fin-state? x sta)
        (as x seq)
        (let ((e (now-elt x sta)))
          (con (if (test e) (add seq e) seq) (nxt-state x sta))))))

(dm del-dups ((x <seq>) => <seq>)
  (as x (rev! (reduce (fun (s e) (if (mem? s e) s (pair e s))) '() x))))

(dm del ((s <seq>) x => <seq>)
  (pick (fun (e) (~== e x)) s))

(dm vals-to-str ((s <seq>) => <str>)
  (reduce (fun (s e) (cat s (if (empty? s) "" " ") (to-str e))) "" s))

;;; LIST

(dv <list> <lst>)

(dm to-str ((x <lst>) => <str>)
  (cat "(" (vals-to-str x) ")"))

(dm pair (h (t <lst>))
  (isa <lst> (set head h) (set tail t)))

(dm empty ((c <lst>) => <lst>) '())

(dm empty? ((c <lst>) => <log>) (== c (empty c)))

(dm fab ((x <lst>) (s <int>) => <lst>)
  (rep fab (((i <int>) s) ((res <lst>) (empty x)))
    (if (> i 0)
        (fab (- i 1) (isa x (set tail res)))
	res)))

;; TODO: DO THIS IN GENERAL FOR AS
(dm as ((p <lst>) (x <lst>) => <lst>) x)

(dm fabs ((c <lst>) (objects ...))
  (rep build (((index <int>) (- (len objects) 1)) ((result <lst>) (empty c)))
    (if (< index 0)
        result
        (build (- index 1) 
	       (isa c (set head (elt objects index)) (set tail result))))))

(dm lst ((objects ...))
  (apply fabs (pair <lst> objects)))

(dv list lst)

(dm len ((x <lst>) => <int>)
  (rep sum (((count <int>) 0) ((x <lst>) x))
    (if (empty? x) count (sum (+ count 1) (tail x)))))

(dm elt ((x <lst>) (key <int>) => <any>)
  (rep fnd (((count <int>) 0) ((x <lst>) x))
    (if (empty? x)
        nul ;; TODO: RANGE ERROR
        (if (== count key)
            (head x)
            (fnd (+ count 1) (tail x))))))

(dm elt-setter (z (x <lst>) (key <int>))
  (rep fnd (((count <int>) 0) ((x <lst>) x))
    (if (empty? x)
        nul ;; TODO: RANGE ERROR
        (if (== count key)
            (set (head x) z)
            (fnd (+ count 1) (tail x))))))

(dm add ((c <lst>) x => <lst>)
  (pair x c))

(dm rev! ((c <lst>) => <lst>)
  (rep loop ((l c) (r (empty c)))
    (if (empty? l)
	r
	(let ((t (tail l)))
	  (set (tail l) r)
	  (loop t l)))))

;; TODO: CHANGE ORDER OF ARGS LIKE MEM?
(dm assq (x (l <lst>) => <any>)
  (if (empty? l)
      #f
      (if (== x (head (head l)))
	  (head l)
	  (assq x (tail l)))))

(dm assqn (x (l <lst>) (pos <int>) => <any>)
  (if (empty? l)
      #f
      (if (== x (elt (head l) pos))
        (head l)
        (assqn x (tail l) pos))))

(dm last ((x <lst>) => <any>)
  (rep fnd ((x x) (px x))
    (if (empty? x) (head px) (fnd (tail x) x))))

(dm ini-state ((c <lst>) => <lst>) c)

(dm fin-state? ((_ <lst>) (state <lst>) => <log>) (empty? state))

(dm nxt-state ((_ <lst>) (state <lst>) => <lst>) (tail state))

(dm now-elt ((_ <lst>) (state <lst>) => <any>) (head state))

(dm now-elt-setter (z (_ <lst>) (state <lst>)) (set (head state) z))

(dm now-key ((c <lst>) (state <lst>) => <int>)
  (rep fnd (((key <int>) 0) ((c <lst>) c))
    (if (== c state) key (fnd (+ key 1) (tail c)))))

(dm copy-state ((_ <lst>) (state <lst>) => <lst>) state)

;;; TUPLE

(dv tup lst)

;;; <FLAT>

(dm ini-state ((c <flat>) => <int>) 0)

(dm fin-state? ((c <flat>) (state <int>) => <log>) (== state (len c)))

(dm nxt-state ((_ <flat>) (state <int>) => <int>) (+ state 1))

(dm now-elt ((c <flat>) (state <int>) => <any>) (low-elt c state))

(dm now-elt-setter (z (c <flat>) (state <int>)) (set (low-elt c state) z))

(dm now-key ((_ <flat>) (state <int>) => <int>) state)

(dm copy-state ((_ <flat>) (state <int>) => <int>) state)

;;; VECTOR

(dm empty ((c <vec>) => <vec>)
  %vnul)

(df vec ((objects ...))
  (as <vec> objects))

(dm fabs ((c <vec>) (objects ...))
  (apply vec objects))

(dm fab ((x <vec>) (s <int>) => <vec>)
  (%vec (%iu s)))

(dm len ((x <vec>) => <int>)
  (%ib (%vlen x)))

(dm low-elt ((x <vec>) (i <int>) => <any>)
  (%velt x (%iu i)))

(dm low-elt-setter (z (x <vec>) (i <int>))
  (set (%velt x (%iu i)) z))

(dm elt ((x <vec>) (i <int>) => <any>)
  (range-check x i)
  (%velt x (%iu i))) ;; TODO: LOW-ELT

(dm elt-setter (z (x <vec>) (i <int>))
  (range-check x i)
  (set (%velt x (%iu i)) z)) ;; TODO: LOW-ELT

(dm to-str ((x <vec>) => <str>)
  (cat "#(" (vals-to-str x) ")"))

;;; STRETCHY-VECTOR

(dv <buf> (isa <flat>))
  (slot <buf> (buf-len <int>) 0)
  (slot <buf> (buf-dat <vec>) #())

(dm empty ((c <buf>) => <buf>) (isa <buf>))

(dm buf ((elts ...) => <buf>)
  (alter (fab <buf> (len elts)) elts))

(dm fabs ((c <buf>) (elts ...) => <buf>)
  (apply buf elts))

(dm fab ((c <buf>) (s <int>) => <buf>)
  (let ((dat (fab <vec> (power-of-two-ceiling s))))
    (isa <buf> (set buf-len s) (set buf-dat dat))))

(dm len ((c <buf>) => <int>)
  (buf-len c))

(dm len-setter ((new-len <int>) (c <buf>))
  (let ((dat (buf-dat c)))
    (if (> new-len (len dat))
	(let ((new-data (fab <vec> (power-of-two-ceiling new-len))))
	  (alter new-data dat)
	  (set (buf-len c) new-len)
	  (set (buf-dat c) new-data))
	(if (< new-len (len c))
	    (let ((old-len (len c)))
	      (set (buf-len c) new-len)
	      (rep fill (((i <int>) new-len))
		(and (< i old-len)
		     (set (low-elt dat i) nul)
		     (fill (+ i 1)))))
	    (set (buf-len c) new-len)))))

(dm low-elt ((x <buf>) (i <int>) => <any>)
  (low-elt (buf-dat x) i))

(dm low-elt-setter (z (x <buf>) (i <int>))
  (when (>= i (len x))
    (set (len x) (+ i 1)))
  (set (low-elt (buf-dat x) i) z))

(dm elt ((c <buf>) (i <int>) => <any>)
  (range-check c i)
  (low-elt c i))

(dm elt-setter (v (c <buf>) (i <int>))
  (when (< i 0) (range-error c i))
  (set (low-elt x i) z))

(dm add! ((c <buf>) x => <buf>)
  (set (low-elt c (len c)) x)
  c)

(dm push ((c <buf>) x => <buf>)
  (add! c x))

(dm pop ((c <buf>) => <any>)
  (let ((new-len (- (len c) 1))
	(x       (low-elt c new-len)))
    (set (len c) new-len)
    x))

;; TODO: HAVE THIS FALL OUT OF PROTOCOL
(dm cat! ((x <buf>) (more ...) => <buf>)
  (rep outer ((more more))
    (if (empty? more)
	x
	(let ((s (head more)))
          (rep inner ((sta (ini-state s)))
            (if (fin-state? s sta)
		(outer (tail more))
		(seq (add! x (now-elt s sta))
		     (inner (nxt-state s sta)))))))))

;;; RANGE
;;;
;;; TODO: FEWER SLOTS

(dv <range> (isa <seq>))
  (slot <range> (range-from  <num>) 0)
  (slot <range> (range-to    <num>))
  (slot <range> (range-below <num>))
  (slot <range> (range-above <num>))
  (slot <range> (range-by    <num>) 1)

(dm from ((from <num>) => <range>)
  (isa <range> (set range-from from)))

(dm from-by ((from <num>) (by <num>) => <range>)
  (isa <range> (set range-from from)  (set range-by by)))

(dm from-to ((from <num>) (to <num>) => <range>)
  (isa <range> (set range-from from) (set range-to to)))

(dm from-to-by ((from <num>) (to <num>) (by <num>) => <range>)
  (isa <range> (set range-from from) (set range-to to)  (set range-by by)))

(dm from-below ((from <num>) (below <num>) => <range>)
  (isa <range> (set range-from from) (set range-below below)))

(dm from-below-by ((from <num>) (below <num>) (by <num>) => <range>)
  (isa <range> (set range-from from) (set range-below below) (set range-by by)))

(dm from-above ((from <num>) (above <num>) => <range>)
  (isa <range> (set range-from from) (set range-above above)))

(dm from-above-by ((from <num>) (above <num>) (by <num>) => <range>)
  (isa <range> (set range-from from) (set range-above above) (set range-by by)))

(dm ini-state ((c <range>) => <num>)
  (range-from c))

(dm fin-state? ((c <range>) (state <num>) => <log>)
  (if (neg? (range-by c))
      (if (== (range-to c) nul) 
	  (if (== (range-above c) nul)
	      #f
	      (<= state (range-above c)))
	  (< state (range-to c)))
      (if (== (range-to c) nul) 
	  (if (== (range-below c) nul)
	      #f
	      (>= state (range-below c)))
	  (> state (range-to c)))))

(dm nxt-state ((c <range>) (state <num>) => <num>)
  (+ state (range-by c)))

(dm now-elt ((c <range>) (state <num>) => <any>)
  state)

(dm copy-state ((_ <range>) (state <num>) => <num>)
  state)

;;; STEP

(dv <step> (isa <seq>))
  (slot <step> step-first)
  (slot <step> step-then)

(dm first-then (first then => <step>)
  (isa <step> (set step-first first) (set step-then then)))

(dm ini-state ((c <step>) => <log>)
  #t)

(dm fin-state? ((c <step>) (state <log>) => <log>)
  #f)

(dm nxt-state ((c <step>) (state <log>) => <log>)
  #f)

(dm now-elt ((c <step>) (state <log>) => <any>)
  (if state (step-first c) (step-then c)))

(dm copy-state ((_ <step>) (state <log>) => <log>)
  state)

;;; ASSOC

(dv <assoc>     (isa <any>))
  (slot <assoc> assoc-key)
  (slot <assoc> assoc-value)
(df assoc (x y => <assoc>)
  (isa <assoc> (set assoc-key x) (set assoc-value y)))

(dm assocq (x (l <lst>) => <any>)
  (if (empty? l)
      #f
      (if (== x (assoc-key (head l)))
	  (head l)
	  (assocq x (tail l)))))

;; TODO: QUESTIONABLE SYNTAX
(dm to-str ((x <buf>) => <str>) 
  (cat "#[" (vals-to-str x) "]"))

;;; STRING

(dm empty ((c <str>) => <str>)
  %snul)

(dm default ((c <col>) => <col>)
  #\space)

(dm fab ((x <str>) (s <int>) => <str>)
  (%str (%iu s)))

(dm str ((objects ...))
  (alter (fab <str> (len objects)) objects))

(dm fabs ((c <str>) (objects ...))
  (apply str objects))

(dm len ((x <str>) => <int>)
  (%ib (%slen x)))

(dm low-elt ((x <str>) (i <int>) => <chr>)
  (%cb (%selt x (%iu i))))

(dm low-elt-setter ((z <chr>) (x <str>) (i <int>))
  (set (%selt x (%iu i)) (%cu z)))

(dm elt ((x <str>) (i <int>) => <chr>)
  (range-check x i)
  (%cb (%selt x (%iu i)))) ;; TODO: USE LOW-ELT

(dm elt-setter ((z <chr>) (x <str>) (i <int>))
  (range-check x i)
  (set (%selt x (%iu i)) (%cu z))) ;; TODO: USE LOW-ELT

(dm to-str ((x <str>) => <str>)
  x)

;;; SYMBOL

(dm as ((_ <str>) (s <sym>) => <str>)
  (sym-name s))

(dm as ((_ <sym>) (s <str>) => <sym>)
  (fab-sym s)
  ;; (let ((sym (elt symbols s)))
  ;;   (if (== sym nul)
  ;;       (set (elt symbols s) sym)
  ;;       sym))
  )

(dm < ((x <sym>) (y <sym>))
  (< (sym-name x) (sym-name y)))

(dm to-str ((x <sym>) => <str>)
  (sym-name x))

;;; FUNCTIONAL 

(dm identity (x) x)

(dm compose ((fx <fun>) (fy <fun>) => <fun>)
  (fun ((args ...)) (fx (apply fy args))))

(dm rcurry ((f <fun>) (curried ...) => <fun>)
  (fun ((args ...)) (apply f (cat args curried))))     

(dm curry ((f <fun>) (curried ...) => <fun>)
  (fun ((args ...)) (apply f (cat curried args))))     

(dm always (x => <fun>)
  (fun ((args ...)) x))

;;; CONDITIONS

(dv <condition> (isa <any>))

(dm default-handler ((c <condition>))
  #f)

(dv <simple-condition> (isa <condition>))
  (slot <simple-condition> (condition-message <str>))
  (slot <simple-condition> (condition-arguments <str>))

(dv <serious-condition> (isa <condition>))

(dm default-handler ((c <serious-condition>))
  (when (isa? c <simple-condition>)
    (apply (curry format out (condition-message c)) (condition-arguments c)))  
  (%invoke-debugger c))

(dv <error> (isa <serious-condition>))

(dv <simple-error> (isa (<error> <simple-condition>)))

(dv *current-handlers* '())

(dv <handler> (isa <any>))
  (slot <handler> (handler-function <fun>))

(df make-handler ((f <fun>) => <handler>)
  (isa <handler> (set handler-function f)))

(df handler-matches? ((handler <handler>) (condition <condition>) => <log>)
  #t)

(dp %with-monitor ((user-handler <fun>) (main-fun <fun>))
  (lab _unwind-exception_
    (let ((_original-handlers_ *current-handlers*))
      (loc ((_handler-function_ (condition _next-handler_)
	      (set *current-handlers* _original-handlers_)
	      (lab _resume_
		(user-handler condition _resume_)
		(_next-handler_))))
	(set *current-handlers*
             (pair (make-handler _handler-function_) *current-handlers*))
	(fin (main-fun) (set *current-handlers* _original-handlers_))))))

(dm sig ((condition <condition>) (args ...))
  (rep search ((handlers *current-handlers*))
    (if (empty? handlers)
	(default-handler condition)
	(let ((handler (head handlers))
	      (remaining (tail handlers)))
	  (if (handler-matches? handler condition)
	      ((handler-function handler)
	       condition (fun () (search remaining)))
	      (search remaining))))))

(dm sig ((c <str>) (args ...)) 
  (sig (isa <simple-condition> 
	 (set condition-message c) (set condition-arguments args))))

;; (df error ((message <str>) (args ...))
;;   (%break (%su message)))

(dm error ((c <simple-error>) (args ...))
  (sig c))

(dm error ((c <str>) (args ...))
  (error (isa <simple-error>
	   (set condition-message c) (set condition-arguments args))))

(df wrong-number-arguments-error ((fun <fun>) (n <int>))
  (error "%= CALLED WITH %= ARGUMENTS EXPECTED %=" fun n (fun-arity fun)))

(df unknown-function-error ((fun <fun>))
  (error "UNKNOWN FUNCTION %= CALLED" fun))

(df type-error (arg type)
  (error "TYPE ERROR %= SHOULD BE A %=" arg type))

;;; LOCATIVES

;; (dv <loc> (isa <any>))
;;   (slot <loc> locative-dat)

(df locative-value ((x <loc>) => <any>)
  (%locative-value x))

(df locative-value-setter (z (x <loc>) => <any>)
  (set (%locative-value x) z))

;;; APPLICATION INPUT

(df app-filename () (%app-filename))

(df app-args () (%app-args))

;;; PORTS

(dv <port> (isa <any>))
  (slot <port> port-handle)

(dv <input-port> (isa <port>))

(dv <output-port> (isa <port>))

;;; FILE PORTS

(dv <file-port> (isa <port>))

(dv <file-input-port> (isa (<file-port> <input-port>)))

(dv <file-output-port> (isa (<file-port> <output-port>)))

(dm open-input-file ((filename <str>) => <file-input-port>)
  (isa <file-input-port>
       (set port-handle (%open-input-file (%su filename)))))

(dm file-opening-error ((filename <str>))
  (error "Cannot open file named %=" filename))

(dm open-output-file ((filename <str>) => <file-output-port>)
  (isa <file-output-port>
       (set port-handle (%open-output-file (%su filename)))))

(dm close-input-port ((port <file-input-port>))
  (%close-input-port (port-handle port)))

(dm close-output-port ((port <file-output-port>))
  (%close-output-port (port-handle port)))

(dm call-with-input-file ((string <str>) (proc <fun>))
  (let ((port #f))
    (fin (seq (set port (open-input-file string))
	      (proc port))
	 (and port (close-input-port port)))))
       

(dm call-with-output-file ((string <str>) (proc <fun>))
  (let ((port #f))
    (fin (seq (set port (open-output-file string))
	      (proc port))
	 (and port (close-output-port port)))))

(dv in (isa <file-input-port> (set port-handle (%current-input-port))))

(dv out (isa <file-output-port> (set port-handle (%current-output-port))))

(dm eof-object? (x => <log>) 
  #f)

(dm eof-object? ((x <chr>) => <log>)
  (%bb (%eq? (%cu x) (%eof-object))))

(dm eof-object (=> <chr>)
  (%cb (%eof-object)))

(dm read-char ((port <file-input-port>) => <chr>)
  (%cb (%read-char (port-handle port))))

(dm peek-char ((port <file-input-port>) => <chr>)
  (%cb (%peek-char (port-handle port))))

(dm char-ready? ((port <file-input-port>) => <log>)
  (%char-ready? (port-handle port)))

(dm newline ((port <output-port>)) 
  (write-char port #\newline))

(dm force-output ((port <file-output-port>))
  (%force-output (port-handle port)))

(dm write-char ((port <file-output-port>) (c <chr>))
  (%write-char (port-handle port) (%cu c)))

(dm write-string ((port <file-output-port>) (s <str>))
  (%write-string (port-handle port) (%su s)))

;;; STRING-PORT IMPLEMENTATION

(dv <string-port> (isa <port>))
  (slot <string-port> (port-guts <seq>) "")

(dm port-contents ((port <string-port>) => <str>)
  (as <str> (port-guts port)))

(dv <string-input-port> (isa (<string-port> <input-port>)))
  (slot <string-input-port> (port-index <int>) 0)

(dv <string-output-port> (isa (<string-port> <output-port>)))

(dm call-with-string-input-port ((string <str>) (proc <fun>))
  (proc (isa <string-input-port> (set port-guts string))))

;; VERY INEFFICIENT

(dm call-with-string-output-port ((proc <fun>))
  (proc (isa <string-output-port>)))

;; TODO: EOF OBJECT MUST BE A CHR

(dm peek-char ((port <string-input-port>) => <chr>)
  (if (>= (port-index port) (len (port-guts port)))
      (eof-object)
      (elt (port-guts port) (port-index port))))

(dm read-char ((port <string-input-port>) => <chr>)
  (if (>= (port-index port) (len (port-guts port)))
      (eof-object)
      (let ((res (elt (port-guts port) (port-index port))))
	(inc (port-index port))
	res)))

(dm char-ready? ((port <string-input-port>) => <log>)
  #t)

(dm write-char ((port <string-output-port>) (c <chr>))
  (set (port-guts port) (add (port-guts port) c)))

(dm write-string ((port <string-output-port>) (s <str>))
  (set (port-guts port) (cat (port-guts port) s)))

