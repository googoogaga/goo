;;;; Copyright (c) 2001 Jonathan Bachrach

(use boot)
(use macros)
(use proto/math)
(use proto/types)
(use proto/ports)
(use runtime1)
(use proto/collections/collection)
(use proto/collections/sequence)
(use proto/collections/opts)
(use proto/collections/list)
(use proto/collections/buffer)
(use proto/collections/table)

;;; APPLY

; (df napply ((proc <fun>) nexts (args ...))
;   (if (== (len args) 1)
;       (%%apply proc nexts (as <vec> (elt args 0)))
;       (let (((ilen <int>) (- (len args) 1))
;             ((lelt <seq>) (elt args ilen))
;             ((tlen <int>) (+ ilen (len lelt)))
;             ((out  <vec>) (fab <vec> tlen)))
;         (rep loop ((i 0))
;           (if (== i ilen)
;               #f
;               (seq
;                 (set (elt out i) (elt args i))
;                 (loop (+ i 1)))))
;         (rep loop ((s (ini-state lelt)) (i ilen))
;           (if (fin-state? lelt s)
;               #f
;               (seq (set (elt out i) (now-elt lelt s))
;                    (loop (nxt-state lelt s) (+ i 1)))))
;          (%%apply proc nexts out))))


;;; MACRO SUPPORT

(df match-empty-list ((x <lst>) (fail <fun>))
  (if (== x '())
      '()
      (fail "Match Empty Failure of %=" x)))

(df match-unquote ((x <lst>) (fail <fun>))
  (if (== x '())
      (fail "Match Failure Empty List on Unquote")
      (head x)))

(df match-atom ((x <lst>) pat (fail <fun>))
  (if (== x '())
      (fail "Match Failure Empty List on %=" pat)
      (let ((exp (head x)))
	(if (== exp pat)
	    (tail x)
	    (fail "Match Failure of %= on %=" exp pat)))))

(df match-sublist ((x <lst>) (fail <fun>))
  (let ((x (head x)))
    (if (isa? x <lst>)
	x
        (fail "Match Failure on Sub List on %=" x))))

(dm make-sym ((x ...)  => <sym>)
  (as <sym> (reduce (fun (r e) (cat r (to-str e))) "" x)))

(dv *gensym-counter* 1000)

(dm gensym (=> <sym>)
  (make-sym "x-" (inc *gensym-counter*)))

(dm make-setter-name ((x <sym>) => <sym>)
  (make-sym x "-setter"))

(dm var-name ((x <sym>)) x)

(dm var-name ((x <lst>)) (elt x 0))

(dm var-type ((x <sym>)) '<any>)

(dm var-type ((x <lst>)) (elt x 1))

;;; FUNCTIONAL 

(dm identity (x) x)

(dm compose ((fx <fun>) (fy <fun>) => <fun>)
  (fun ((args ...)) (fx (apply fy args))))

;;FIXME:
;; the let is to work around compiler bug:
;;   it doens't do extent analysis of restargs like it should.

(dm rcurry ((f <fun>) (curried ...) => <fun>)
  (let ((savedcurried (as <vec> curried)))
    (fun ((args ...)) (apply f (cat '() args savedcurried)))))

(dm curry ((f <fun>) (curried ...) => <fun>)
  (let ((savedcurried (as <vec> curried)))
    (fun ((args ...)) (apply f (cat '() savedcurried args)))))

(dm always (x => <fun>)
  (fun ((args ...)) x))

;;; CONDITIONS

(dc <condition> (<any>))

(dm default-handler ((c <condition>))
  #f)

(dm describe-condition ((c <condition>) => <str>)
  (format-to-string "Anonymous condition %=" c))

(dm default-handler-description ((cond-type <condition>) => <str>)
  (format-to-string "Anonymous handler for %s" cond-type))

(dm build-condition-interactively
  ((cond-type (t< <condition>)) in out => <condition>)
  (isa cond-type))

(dc <simple-condition> (<condition>))
  (slot <simple-condition> (condition-message <str>)   "")
  (slot <simple-condition> (condition-arguments <lst>) '())

(dm describe-condition ((c <simple-condition>) => <str>)
  (apply format-to-string (condition-message c)
                          (condition-arguments c)))

(dm build-condition-interactively
    ((cond-type (t< <simple-condition>)) in out => <condition>)
  (let ((cond (next-method cond-type in out)))
    (format out "Condition format string: ")
    (set (condition-message cond) (read in))
    (format out "Condition format arguments: ")
    (set (condition-arguments cond) (read in))
    cond))

(dc <serious-condition> (<condition>))

(dm default-handler ((c <serious-condition>))
  (format out "%s\n" (describe-condition c))
  (%invoke-debugger c))

(dc <error> (<serious-condition>))

(dc <simple-error> (<error> <simple-condition>))

(export
  <condition>
  default-handler
  describe-condition
  condition-message
  condition-arguments
  
  default-handler-description
  build-condition-interactively
  <simple-condition>
  <serious-condition>
  <error>
  <simple-error>)

(dc <restart> (<condition>))

(dm default-handler-description ((cond-type <restart>) => <str>)
  (format-to-string "Anonymous restart of type %s" cond-type))

(dc <incongruent-method-error> (<error>))
  (slot <incongruent-method-error> (incongruent-method-error-generic <gen>))
  (slot <incongruent-method-error> (incongruent-method-error-method <met>))

(dm describe-condition ((c <incongruent-method-error>) => <str>)
  (format-to-string "Method %= incongruent with generic %=.\n"
                    (incongruent-method-error-method c)
                    (incongruent-method-error-generic c)))

(dc <replace-generic-restart> (<restart>))

(dm default-handler-description ((cond-type <replace-generic-restart>)
                                 => <str>)
  "Replace the generic function with an empty, congruent one")

(export
  <restart>
  <replace-generic-restart>
  default-handler-description
  build-condition-interactively)

;;;; Handler Info
;;;; Debugger-level info used for describing handlers and calling them
;;;; interactively.  This probably doesn't need to be an actual class;
;;;; a few well-chosen slots on <handler> might work better.

(dc <handler-info> (<any>))

(dm describe-handler ((info <handler-info>) condition-type => <str>)
  (default-handler-description condition-type))

(dm build-condition-for-handler-interactively
  ((info <handler-info>) condition-type in out => <condition>)
  (build-condition-interactively condition-type in out))

(dv $default-handler-info (isa <handler-info>))

(dc <simple-handler-info> (<handler-info>))
  (slot <simple-handler-info> (handler-info-message <str>))
  (slot <simple-handler-info> (handler-info-arguments <str>) '())

(dm describe-handler ((info <simple-handler-info>) condition-type => <str>)
  (apply format-to-string
         (handler-info-message info)
         (handler-info-arguments info)))

(export
  <handler-info>
  describe-handler
  build-condition-for-handler-interactively
  $default-handler-info
  <simple-handler-info>
  handler-info-message
  handler-info-arguments
  describe-handler)

;;;; Handlers

(dv *current-handlers* '())

(dc <handler> (<any>))
  (slot <handler> (handler-condition-type (t< <condition>)))
  (slot <handler> (handler-info <handler-info>))
  (slot <handler> (handler-test <fun>))
  (slot <handler> (handler-function <fun>))

(df make-handler
  ((type (t< <condition>)) (info <handler-info>) (test <fun>) (f <fun>)
   => <handler>)
  (isa <handler>
    (set handler-condition-type type)
    (set handler-info info)
    (set handler-test test)
    (set handler-function f)))

(df handler-active? ((handler <handler>) => <log>)
  ((handler-test handler)))

(df handler-matches? ((handler <handler>) (condition <condition>) => <log>)
  (and (isa? condition (handler-condition-type handler))
       (handler-active? handler)))

(df %with-monitor
  ((type (t< <condition>)) (info <handler-info>) (test-fun <fun>)
   (user-handler <fun>) (main-fun <fun>))
  (lab _unwind-exception_
    (let ((_original-handlers_ *current-handlers*))
      (loc ((_handler-function_ (condition _next-handler_)
	      (lab _resume_
		(user-handler condition _resume_)
		(_next-handler_))))
	(pushf *current-handlers*
               (make-handler type info test-fun _handler-function_))
	(fin (main-fun) (set *current-handlers* _original-handlers_))))))

;;; Pass a signal to a list of handlers for processing.
(df signal-handler-list ((condition <condition>) (handlers <lst>) => <any>)
  (if (empty? handlers)
      (default-handler condition)
      (let ((handler (head handlers))
            (remaining (tail handlers)))
        (if (handler-matches? handler condition)
            ((handler-function handler)
             condition (fun () (signal-handler-list condition remaining)))
            (signal-handler-list condition remaining)))))

(dm sig ((condition <condition>) (args ...))
  (signal-handler-list condition *current-handlers*))

(dm sig ((c <str>) (args ...)) 
  (sig (isa <simple-condition> 
	 (set condition-message c) (set condition-arguments args))))

;; (df error ((message <str>) (args ...))
;;   (%break (%su message)))

(dm error ((c <error>) (args ...))
  (sig c))

(dm error ((c <str>) (args ...))
  (error (isa <simple-error>
	   (set condition-message c) (set condition-arguments args))))

(df wrong-number-arguments-error ((fun <fun>) (n <int>))
  (error "%= CALLED WITH %= ARGUMENTS EXPECTED %=" fun n (fun-arity fun)))

(df unknown-function-error ((fun <fun>))
  (error "UNKNOWN FUNCTION %= CALLED" fun))

(df type-error (arg type)
  (error "TYPE ERROR %= SHOULD BE A %=" arg type))

(df incongruent-method-error ((gen <gen>) (met <met>) => #f)
  (error (isa <incongruent-method-error>
           (set incongruent-method-error-generic gen)
           (set incongruent-method-error-method met))))

;;; INTERACTIVE HANDLER MUNGING

;;; Apply 'f' to all handlers whose type is a subtype of 'type'.
(df do-handlers-of-type ((type (t< <condition>)) (f <fun>) => #f)
  (rep search ((handlers *current-handlers*))
    (if (empty? handlers)
        #f
        (let ((handler (head handlers))
              (remaining (tail handlers)))
          (when (and (subtype? (handler-condition-type handler) type)
                     (handler-active? handler))
            (f handler))
          (search remaining)))))

;;; Print out descriptions all active handlers matching 'type' (numbered
;;; from 1) and return a sequence of those handlers in the same order
;;; (indexed from zero).  This allows us to keep track of which handlers
;;; correspond to which user-visible numbers.
(df list-handlers ((type (t< <condition>)) out => <buf>)
  (let ((i 1)
        (applicable (fab <buf> 0)))
    (do-handlers-of-type type
      (fun (handler)
        (format out "%d. %s.\n" i
                (describe-handler (handler-info handler)
                                  (handler-condition-type handler)))
        (push-last! applicable handler)
        (inc i)))
    applicable))

;;; Attempt to invoke the specified handler directly, bypassing any other
;;; handlers "in the way". 
(df invoke-handler-interactively ((handler <handler>) in out => <any>)
  (let ((condition
         (build-condition-for-handler-interactively
          (handler-info handler) (handler-condition-type handler) in out)))
    (unless (handler-matches? handler condition)
      (error "Handler %= does not match condition %=" handler condition))
    (rep search ((handlers *current-handlers*))
      (if (empty? handlers)
          (error "Handler %= is not installed" handler)
          (let ((current (head handlers))
                (remaining (tail handlers)))
            (if (== handler current)
                ((handler-function handler)
                 condition (fun () (signal-handler-list condition remaining)))
                (search remaining)))))))

;;; Chose a handler matching 'type', and call it interactively.
(df choose-handler ((type (t< <condition>)) in out => <any>)
  (let ((handlers (list-handlers type out)))
    (format out "Please pick a handler: ")
    (let ((n (- (read in) 1)))
      (when (or (< n 0) (>= n (len handlers)))
        (error "No such handler %d" n))
      (invoke-handler-interactively (elt handlers n) in out))))

;;; Enable some low-level restarts, now that it's safe to do so.
(set *restarts-ok?* #t)

(export
  list-handlers
  invoke-handler-interactively
  choose-handler)

;;; LOCATIVES

;; (dc <loc> (<any>))
;;   (slot <loc> locative-dat)

(df locative-value ((x <loc>) => <any>)
  (%locative-value x))

(df locative-value-setter (z (x <loc>) => <any>)
  (set (%locative-value x) z))

;;; APPLICATION INPUT

(df app-filename () (%app-filename))

(df app-args () (%app-args))

(dv symbols (fab <str-tab> 10000))

(dp booted-fab-sym-using (name given-sym)
  (let ((sym (elt symbols name)))
    (if (== sym nul)
	(set (elt symbols name) (or given-sym (isa <sym> (set sym-name name))))
	sym)))

(df booted-fab-sym (name)
  (booted-fab-sym-using name #f))

(df boot-symbols ()
  (rep boot ((syms %symbols))
    (unless (empty? syms)
      (let ((sym (head syms))) (booted-fab-sym-using (sym-name sym) sym))
      (boot (tail syms)))))

(boot-symbols)

(set fab-sym booted-fab-sym)

(need-implementation
  read
  format
  format-to-string)

;; TODO: TEMPORARY EXPORTS
(export
  napply
  match-empty-list
  match-unquote
  match-atom
  match-sublist
  make-sym
  *gensym-counter*
  gensym
  make-setter-name
  var-name
  var-type
  identity
  compose
  rcurry
  curry
  always
  locative-value
  locative-value-setter
  app-filename
  app-args
  sig
  error
  <handler>
  handler-function
  make-handler
  handler-matches?
  %with-monitor
  )

;(export
"  always
  app-args app-filename
  as
  ascii-limit ascii-whitespaces
  buf <buf>
  call-with-input-file call-with-output-file
  call-with-string-input-port call-with-string-output-port
  ceiling ceiling/
  describe-condition
  port-contents
  case-insensitive-string-hash
  case-insensitive-string-equal
  cat cat2 cat!
  char->ascii
  char-ready?
  compose
  <condition> condition-arguments condition-message
  current-gc-state
  curry
  default
  default-handler
  del
  del-dups
  del-key del-keys
  do do2 do3 do-keyed
  elt elt-setter elt-or low-elt low-elt-setter
  empty empty?
  eof-object eof-object?
  error <error> <simple-error>
  even?
  fab fabs
  <file-port> <file-input-port> open-input-file close-input-port
  <file-output-port> open-output-file close-output-port
  fill
  fin-state?
  first-then
  find-key
  flo-bits
  floor floor/
  force-output
  from from-below from-to from-by from-to-by from-below-by from-above
  from-above from-above-by
  gensym
  <handler> handler-function make-handler handler-matches?
  id-hash
  identity
  in
  <incongruent-method-error>
  ini-state copy-state
  <input-port> port-line 
  keys
  last
  len len-setter len/fill-setter
  list <list>
  locative-value locative-value-setter
  logior logxor logand lognot logbit?
  lowercase? uppercase?
  lst
  make-setter-name
  make-sym
  map map2 map-keyed
  <map>
  fab-map
  match-atom match-empty-list match-sublist match-unquote
  max min 
  modulo remainder
  mem?
  napply
  neg neg?
  newline
  now-elt now-elt-setter
  now-key
  nul?
  num-to-str
  numeric?
  nxt-state
  odd?
  out
  <output-port>
  pair
  pick
  peek-char
  $permanent-hash-state
  <port> port-index
  pos pos?
  pop pop-last! push push-last!
  *print-base*
  <range>
  rcurry
  read-char
  reduce reduce+
  rev!
  rev
  round round/
  <serious-condition>
  sig
  <simple-condition>
  <step>
  str
  <str-tab>
  str-to-num
  <string-port> <string-input-port> <string-output-port>
  sub sub-setter
  <tab>
  table-growth-factor table-growth-threshold table-shrink-threshold
  table-protocol
  to-digit
  to-str
  truncate
  truncate/
  tup
  t+ t= t< false-or
  var-name var-type
  vec
  %with-monitor
  write-char write-string
  zero?
  )
"