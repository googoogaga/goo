;;;; Copyright (c) 2001 Jonathan Bachrach

(use boot)

;; TODO: Fix next-method to do a normal call with a next-method instead of
;;       apply, as apply is not necessary, and slow.
(ds (next-method ,@args)
  `(let ((next-mets (%next-methods)))
     (if next-mets
         (napply (head next-mets) (tail next-mets) ,@args '())
         (error "No next methods"))))

(ds (apply-next-method ,args)
  `(let ((next-mets (%next-methods)))
     (if next-mets
         (napply (head next-mets) (tail next-mets) ,args)
         (error "No next methods"))))

(ds (apply ,f ,@args)
  `(napply ,f #f ,@args))

;; TODO: GENERALIZED VERSION -- PROTOCOL + MULTIPLES

(ds (collecting () ,@body)
  (let ((name 'collector-))
    `(let ((,name '()))
       ,@body
       (collected ,name))))

(ds (collect ,value)
  (let ((name 'collector-))
    `(set ,name (pair ,value ,name))))
  
(ds (collected ,name)
  `(rev! ,name))

(ct-also

  ;; Lift subforms out of a place form.  Return a series of gensym bindings
  ;; and a new place form which uses them instead of the original
  ;; expressions.  This can be used to prevent multiple evaluation when
  ;; expanding incf, decf, and similar macros.  For example:
  ;;   '(foo x y z) =>
  ;;       (tup '((g1 x) (g2 y) (g3 z)) '(foo g1 g2 g3))
  ;;   'bar => (tup '() 'bar)
  (df lift-place-subforms (place => (tup (g-decls <lst>) (g-place <lst>)))
    (loc ((munch ((subforms <lst>) => (tup (g-decls <lst>) (g-args <lst>)))
            (if (empty? subforms)
                '()
                (let (((tup g-decls g-args) (munch (tail subforms))))
                  (let ((g (gensym)))
                    (tup (pair `(,g ,(head subforms)) g-decls)
                         (pair g g-args)))))))
      (if (isa? place <sym>)
          (tup '() place)
          (let (((tup g-decls g-args) (munch (tail place))))
            (tup g-decls (pair (head place) g-args))))))

  )
           
;; TODO: GENERALIZED VERSION

(ds (inc ,place ,@amount)
  (let (((tup g-decls g-place) (lift-place-subforms place))
        (amount (mif ((,amount) amount) amount 1)))
    `(let (,@g-decls)
       (set ,g-place (+ ,g-place ,amount)))))

(ds (dec ,place ,@amount)
  (let (((tup g-decls g-place) (lift-place-subforms place))
        (amount (mif ((,amount) amount) amount 1)))
    `(let (,@g-decls)
       (set ,g-place (- ,g-place ,amount)))))

(ds (pushf ,place ,value)
  (let (((tup g-decls g-place) (lift-place-subforms place)))
    `(let (,@g-decls)
       (set ,g-place (push ,g-place ,value)))))

(ds (popf ,place)
  (let (((tup g-decls g-place) (lift-place-subforms place))
        (new-col (gensym))
        (val (gensym)))
    `(let (,@g-decls
           ((tup ,new-col ,val) (pop ,g-place)))
       (set ,g-place ,new-col)
       ,val)))

(ds (unless ,test ,@body)
  `(if (not ,test) (seq ,@body)))

(ds (when ,test ,@body)
  `(if ,test (seq ,@body)))

(ds (or ,@rest)
  (mif ((,x ,@rest) rest)
       (mif (() rest)
	    x
	    `(let ((tmp ,x))
	       (if tmp tmp (or ,@rest))))
       #f))

(ds (and ,@rest)
  (mif ((,x ,@rest) rest)
       (mif (() rest)
	    x
	    `(let ((tmp ,x))
	       (if tmp (and ,@rest) #f)))
       #t))

(ds (case ,@cases)
  (if (empty? cases)
      #f
      (mif ((,cond ,@body) (head cases))
	   `(if ,cond
		(seq ,@body)
		(case ,@(tail cases)))
	   ;; TODO: NEED SYNTAX ERROR CONDITIONS
	   (error "CASE: SYNTAX ERROR BAD CASE" (head cases)))))

(ds (select ,val ,@cases)
  (if (empty? cases)
      #f
      (mif ((,cond ,@body) (head cases))
	   (if (== cond #t)
	       `(seq ,@body)
	       (let ((bv (gensym)))
		 (mif ((,@values) cond)
		      `(let ((,bv ,val))
			 (if (or ,@(map (fun (x) `(== ,bv ,x)) values))
			     (seq ,@body)
			     (select ,bv ,@(tail cases))))
		       (error "CASE: SYNTAX ERROR BAD CASE" (head cases))))
	       (error "CASE: SYNTAX ERROR BAD CASE" (head cases))))))

(ds (assert ,cond ,message ,@args)
  `(if (not ,cond) (error ,message ,@args)))

(ds (for (,@clauses) ,@body)
  (rep grok ((clauses clauses) 
	     (exps '()) (inits '()) (preds '()) (nows '()) (nexts '()))
    (if (empty? clauses)
	(let ((loop (gensym)))
	  `(let ,exps
	     (rep ,loop ,inits
	       (unless (or ,@preds)
		 (let ,nows ,@body (,loop ,@nexts))))))
        (let ((clause (head clauses)))
	  (mif ((,var ,exp) clause)
	    (let ((state (gensym))
		  (exp-tmp (gensym)))
	      (grok (tail clauses)
		    (pair `(,exp-tmp ,exp) exps)
		    (pair `(,state (ini-state ,exp-tmp)) inits)
		    (pair `(fin-state? ,exp-tmp ,state) preds)
		    (pair (mif ((tup ,key ,val) var)
		    	       `((tup ,key ,val) 
		    		 (tup (now-key ,exp-tmp ,state)
		    		      (now-elt ,exp-tmp ,state))) 
		    	       `(,var (now-elt ,exp-tmp ,state)))
		    	  nows)
		    (pair `(nxt-state ,exp-tmp ,state) nexts))))))))

(ds (dlet ,bindings ,@body)
  (mif (() bindings)
    `(seq ,@body)
     (mif (((,var ,value) ,@rest) bindings)
       (let ((name (var-name var))
	     (old-value (gensym)))
         `(let ((,old-value ,name))
	    (fin (seq (set ,name ,value)
		      (dlet (,@rest) ,@body))
		 (set ,name ,old-value))))
       (error "DLET: SYNTAX ERROR BAD BINDINGS" bindings))))

(ds (def-fun-var ,var ,value)
  (let ((nam (var-name var))
        (typ (var-type var))
        (vnam (make-sym "*" nam "*")))
    `(seq (dv ,vnam ,value)
	  (dm ,nam (=> ,typ) ,vnam)
 	  (dm ,(make-setter-name nam) ((z ,typ)) (set ,vnam z)))))

;; This macro allows you to declare "forward" references between modules.
;; It may or may not remain part of the language in the long run, but we
;; need it to modularize the existing code base.
;; TODO - Move this macro into boot.proto along with AND, OR, WHEN, UNLESS.
(ds (need-implementation ,@names)
  (if (empty? names)
      #f
      `(seq (when #f ,(head names))
            (export ,(head names))
            (need-implementation ,@(tail names)))))


;;;;=======================================================================
;;;;  Public API
;;;;=======================================================================

;;; These bindings are defined in the runtime module.
(need-implementation
  ==
  cat
  empty?
  error
  gensym
  lst
  make-setter-name
  make-sym
  map
  match-atom
  match-empty-list
  match-sublist
  match-unquote
  pair
  tup
  var-name
  var-type
  napply)

(export
  apply
  next-method
  apply-next-method
  collecting
  collect
  collected
  inc
  dec
  pushf
  popf
  unless
  when
  or
  and
  case
  select
  assert
  for
  dlet
  def-fun-var
  need-implementation)
