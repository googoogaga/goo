;;;; Copyright (c) 2001 Jonathan Bachrach

(use runtime/boot)

;; (ct (seq (dv fab-setter-name make-setter-name) (dv cat-sym make-sym)))

;; TODO: Fix next-method to do a normal call with a next-method instead of
;;       apply, as apply is not necessary, and slow.
(ds (sup ,@args)
  `(let ((next-mets (%next-methods)))
     (if next-mets
         (napp (head next-mets) (tail next-mets) ,@args '())
         (error "No next methods"))))

(ds (app-sup ,args)
  `(let ((next-mets (%next-methods)))
     (if next-mets
         (napp (head next-mets) (tail next-mets) ,args)
         (error "No next methods"))))

(ds (app ,f ,@args)
  `(napp ,f #f ,@args))

;; TODO: GENERALIZED VERSION -- PROTOCOL + MULTIPLES

(ds (collecting () ,@body)
  (let ((name 'collector-))
    `(let ((,name '()))
       ,@body
       (collected ,name))))

(ds (collect ,value)
  (let ((name 'collector-))
    `(set ,name (pair ,value ,name))))
  
(ds (collected ,name)
  `(rev! ,name))

(ds (renew ,x ,@prop-inits)
  (let ((var  (gensym))
        (sets (rep loop ((sets '()) (inits prop-inits))
                (if (empty? inits)
                    (rev! sets)
                    (let ((val (head (tail inits))))
                      (loop (pair `(set (,(head inits) ,var) ,val) sets)
                            (tail (tail inits))))))))
    `(let ((,var ,x)) ,@sets ,var)))

(ct-also

  ;; Lift subforms out of a place form.  Return a series of gensym bindings
  ;; and a new place form which uses them instead of the original
  ;; expressions.  This can be used to prevent multiple evaluation when
  ;; expanding incf, decf, and similar macros.  For example:
  ;;   '(foo x y z) =>
  ;;       (tup '((g1 x) (g2 y) (g3 z)) '(foo g1 g2 g3))
  ;;   'bar => (tup '() 'bar)
  (df lift-place-subforms (place => (tup g-decls|<lst> g-place|<lst>))
    (loc ((munch ((subforms <lst>) => (tup g-decls|<lst> g-args|<lst>))
            (if (empty? subforms)
                (tup '() '())
                (let (((tup g-decls g-args) (munch (tail subforms)))
                      (g (gensym)))
                  (tup (pair `(,g ,(head subforms)) g-decls)
                       (pair g g-args))))))
      (if (isa? place <sym>)
          (tup '() place)
          (let (((tup g-decls g-args) (munch (tail place))))
            (tup g-decls (pair (head place) g-args))))))

  )
           
(ds (incf ,place ,@amount)
  (let (((tup g-decls g-place) (lift-place-subforms place))
        (amount (mif ((,amount) amount) amount 1)))
    `(let (,@g-decls)
       (set ,g-place (+ ,g-place ,amount)))))

(ds (decf ,place ,@amount)
  (let (((tup g-decls g-place) (lift-place-subforms place))
        (amount (mif ((,amount) amount) amount 1)))
    `(let (,@g-decls)
       (set ,g-place (- ,g-place ,amount)))))

(ds (pushf ,place ,value)
  (let (((tup g-decls g-place) (lift-place-subforms place)))
    `(let (,@g-decls)
       (set ,g-place (push ,g-place ,value)))))

(ds (swapf ,x ,y)
  (let (((tup xg-decls xg-place) (lift-place-subforms x))
        ((tup yg-decls yg-place) (lift-place-subforms y))
        (tmp (gensym)))
    `(let (,@xg-decls ,@yg-decls (,tmp ,xg-place))
       (set ,xg-place ,yg-place)
       (set ,yg-place ,tmp))))

(ds (popf ,place)
  (let (((tup g-decls g-place) (lift-place-subforms place))
        (new-col (gensym))
        (val (gensym)))
    `(let (,@g-decls
           ((tup ,new-col ,val) (pop ,g-place)))
       (set ,g-place ,new-col)
       ,val)))

(ds (opf ,place ,call)
  (let (((tup g-decls g-place) (lift-place-subforms place)))
    `(let (,@g-decls (_ ,g-place))
       (set ,g-place ,call))))

(ds (unless ,test ,@body)
  `(if (not ,test) (seq ,@body)))

(ds (when ,test ,@body)
  `(if ,test (seq ,@body)))

(ds (or ,@rest)
  (mif ((,x ,@rest) rest)
       (mif (() rest)
	    x
	    `(let ((tmp ,x))
	       (if tmp tmp (or ,@rest))))
       #f))

(ds (and ,@rest)
  (mif ((,x ,@rest) rest)
       (mif (() rest)
	    x
	    `(let ((tmp ,x))
	       (if tmp (and ,@rest) #f)))
       #t))

(ds (cond ,@cases)
  (if (empty? cases)
      #f
      (mif ((,cond ,@body) (head cases))
	   `(if ,cond
		(seq ,@body)
		(cond ,@(tail cases)))
	   ;; TODO: NEED SYNTAX ERROR CONDITIONS
	   (error "COND: SYNTAX ERROR BAD CASE" (head cases)))))

(ct-also
  (df do-case-by (val tst cases)
    (if (empty? cases)
        #f
        (mif ((,cond ,@body) (head cases))
             (if (== cond #t)
                 `(seq ,@body)
                 (mif ((,@values) cond)
                      `(if (or ,@(map (fun (x) `(,tst ,val ,x)) values))
                           (seq ,@body)
                           ,(do-case-by val tst (tail cases)))
                      (error "CASE: SYNTAX ERROR BAD CASE" (head cases))))
             (error "CASE: SYNTAX ERROR BAD CASE" (head cases))))))

(ds (case-by ,val ,tst ,@cases)
  (let ((val-var (gensym)) (tst-var (gensym)))
    `(let ((,val-var ,val) (,tst-var ,tst))
       ,(do-case-by val-var tst-var cases))))

(ds (case ,val ,@cases)
  `(case-by ,val == ,@cases))

(ds (match ,exp ,@cases)
  (mif (() cases)
       `(error "Failed to match.")
       (mif (((,pat ,@then) ,@rest) cases)
            (if (== pat #t)
                `(seq ,@then)
                (let ((var (gensym)))
                  `(let ((,var ,exp))
                     (mif (,pat ,var) 
                          (seq ,@then)
                          (match ,var ,@rest)))))
            (error "Invalid match syntax."))))

(ds (assert ,cond ,message ,@args)
  `(if (not ,cond) (error ,message ,@args)))

(ds (for (,@clauses) ,@body)
  (rep grok ((clauses clauses) (inits '()) (preds '()) (nows '()) (nexts '()))
    (if (empty? clauses)
	(let ((loop (gensym)))
	  `(rep ,loop ,inits
	     (unless (or ,@preds)
               (let ,nows ,@body (,loop ,@nexts)))))
        (let ((clause (head clauses)))
	  (mif ((,var ,exp) clause)
	    (let ((state (gensym)))
	      (grok (tail clauses)
		    (pair `(,state (enum ,exp)) inits)
		    (pair `(fin? ,state) preds)
		    (pair (mif ((tup ,key ,val) var)
		    	       `((tup ,key ,val) 
		    		 (tup (now-key ,state) (now ,state))) 
		    	       `(,var (now ,state)))
		    	  nows)
		    (pair `(nxt ,state) nexts))))))))

(ds (while ,test ,@body)
  `(rep _loop ()
     (when ,test ,@body (_loop))))

(ds (until ,test ,@body)
  `(rep _loop ()
     (unless ,test ,@body (_loop))))

(ds (ddv ,binding ,exp)
  `(dv ,binding ,exp))

(ds (dlet ,bindings ,@body)
  (mif (() bindings)
    `(seq ,@body)
     (mif (((,var ,value) ,@rest) bindings)
       (let ((name (var-name var))
	     (old-value (gensym)))
         `(let ((,old-value ,name))
	    (fin (seq (set ,name ,value)
		      (dlet (,@rest) ,@body))
		 (set ,name ,old-value))))
       (error "DLET: SYNTAX ERROR BAD BINDINGS" bindings))))

(ds (def-fun-var ,var ,value)
  (let ((nam (var-name var))
        (typ (var-type var))
        (vnam (cat-sym "*" nam "*")))
    `(seq (dv ,vnam ,value)
	  (dm ,nam (=> ,typ) ,vnam)
 	  (dm ,(fab-setter-name nam) ((z ,typ)) (set ,vnam z)))))

(ds (without-prop-unbound-errors ,@body)
  `(dlet ((*report-prop-unbound-errors?* #f))
     ,@body))

;; This macro allows you to declare "forward" references between modules.
;; It may or may not remain part of the language in the long run, but we
;; need it to modularize the existing code base.
;; TODO - Move this macro into boot.goo along with AND, OR, WHEN, UNLESS.
(ds (need-implementation ,@names)
  (if (empty? names)
      #f
      `(seq (and #f ,(head names))
            (export ,(head names))
            (need-implementation ,@(tail names)))))

(ds (exported ,@defs)
  (pair
   'seq 
   (collecting ()
     (do (fun (d)
       (cond ((isa? d <sym>)
              (seq (collect d) (collect `(export ,d))))
             ((mif ((df ,name ,@rest) d) 
                   (seq (collect name) (collect `(export ,name)))) #f)
             ((mif ((dg ,name ,@rest) d)
                   (seq (collect d) (collect `(export ,name)))) #f)
             ((mif ((dc ,name ,@rest) d)
                   (seq (collect d) (collect `(export ,name)))) #f)
             ((mif ((dv ,name ,@rest) d)
                   (seq (collect d) (collect `(export ,name)))) #f)
             ((mif ((dp ,name (,@params) ,@default) d)
                   (seq
                     (collect d)
                     (collect `(export ,name))
                     (collect `(export ,(fab-setter-name name))))) #f)
             (#t   5)))
         defs))))


;;;;=======================================================================
;;;;  Public API
;;;;=======================================================================

;;; These bindings are defined in the runtime module.
(need-implementation
  ==
  do
  rev!
  cat
  elt
  empty?
  error
  gensym
  lst
  fab-setter-name
  cat-sym
  map
  match-atom
  match-empty-list
  match-sublist
  match-unquote
  pair
  tup
  var-name
  var-type
  napp)

(export
  app
  sup
  app-sup
  collecting
  collect
  collected
  renew
  incf
  decf
  pushf
  popf
  opf
  swapf
  unless
  when
  or
  and
  cond
  case case-by
  match
  assert
  for
  while until
  ddv
  dlet
  def-fun-var
  need-implementation
  exported
  without-prop-unbound-errors
  *report-prop-unbound-errors?*)
