;;;; Copyright (c) 2001 Jonathan Bachrach

;;; PORTS

(dv <port> (isa <any>))
  (slot <port> port-handle)

(dv <input-port> (isa <port>))

(dv <output-port> (isa <port>))

;;; FILE PORTS

(dv <file-port> (isa <port>))

(dv <file-input-port> (isa (<file-port> <input-port>)))

(dv <file-output-port> (isa (<file-port> <output-port>)))

(dm open-input-file ((filename <str>) => <file-input-port>)
  (isa <file-input-port>
       (set port-handle (%open-input-file (%su filename)))))

(dm file-opening-error ((filename <str>))
  (error "Cannot open file named %=" filename))

(dm open-output-file ((filename <str>) => <file-output-port>)
  (isa <file-output-port>
       (set port-handle (%open-output-file (%su filename)))))

(dm close-input-port ((port <file-input-port>))
  (%close-input-port (port-handle port)))

(dm close-output-port ((port <file-output-port>))
  (%close-output-port (port-handle port)))

(dm call-with-input-file ((string <str>) (proc <fun>))
  (let ((port #f))
    (fin (seq (set port (open-input-file string))
	      (proc port))
	 (and port (close-input-port port)))))
       

(dm call-with-output-file ((string <str>) (proc <fun>))
  (let ((port #f))
    (fin (seq (set port (open-output-file string))
	      (proc port))
	 (and port (close-output-port port)))))

(dv in (isa <file-input-port> (set port-handle (%current-input-port))))

(dv out (isa <file-output-port> (set port-handle (%current-output-port))))

(dm eof-object? (x => <log>) 
  #f)

(dm eof-object? ((x <chr>) => <log>)
  (%bb (%eq? (%cu x) (%eof-object))))

(dm eof-object (=> <chr>)
  (%cb (%eof-object)))

(dm read-char ((port <file-input-port>) => <chr>)
  (%cb (%read-char (port-handle port))))

(dm peek-char ((port <file-input-port>) => <chr>)
  (%cb (%peek-char (port-handle port))))

(dm char-ready? ((port <file-input-port>) => <log>)
  (%char-ready? (port-handle port)))

(dm newline ((port <output-port>)) 
  (write-char port #\newline))

(dm force-output ((port <file-output-port>))
  (%force-output (port-handle port)))

(dm write-char ((port <file-output-port>) (c <chr>))
  (%write-char (port-handle port) (%cu c)))

(dm write-string ((port <file-output-port>) (s <str>))
  (%write-string (port-handle port) (%su s)))

;;; STRING-PORT IMPLEMENTATION

(dv <string-port> (isa <port>))
  (slot <string-port> (port-guts <seq>) "")

(dm port-contents ((port <string-port>) => <str>)
  (as <str> (port-guts port)))

(dv <string-input-port> (isa (<string-port> <input-port>)))
  (slot <string-input-port> (port-index <int>) 0)

(dv <string-output-port> (isa (<string-port> <output-port>)))

(dm call-with-string-input-port ((string <str>) (proc <fun>))
  (proc (isa <string-input-port> (set port-guts string))))

;; VERY INEFFICIENT

(dm call-with-string-output-port ((proc <fun>))
  (proc (isa <string-output-port>)))

;; TODO: EOF OBJECT MUST BE A CHR

(dm peek-char ((port <string-input-port>) => <chr>)
  (if (>= (port-index port) (len (port-guts port)))
      (eof-object)
      (elt (port-guts port) (port-index port))))

(dm read-char ((port <string-input-port>) => <chr>)
  (if (>= (port-index port) (len (port-guts port)))
      (eof-object)
      (let ((res (elt (port-guts port) (port-index port))))
	(inc (port-index port))
	res)))

(dm char-ready? ((port <string-input-port>) => <log>)
  #t)

(dm write-char ((port <string-output-port>) (c <chr>))
  (set (port-guts port) (add (port-guts port) c)))

(dm write-string ((port <string-output-port>) (s <str>))
  (set (port-guts port) (cat (port-guts port) s)))

