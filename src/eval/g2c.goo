;;;; p2c.proto - Proto-to-C compiler
;;;; Copyright (c) 2001 Jonathan Bachrach
;;;; BASED ON Lisp In Small Pieces by Christian Queinnec
;;;;
;;;; General notes on this file:
;;;;
;;;; It is unlikely that the any format specifier other than %s should ever
;;;; be used to output C code. There is no guarantee that the proto formatted
;;;; output is equivalent to C formatted output.
;;;;
;;;; All mentions of %= have been excised, %d seems relatively harmless and
;;;; remains at the moment.

(use boot)
(use macros)
(use runtime)
(use write)
(use ast)
(use top)
(use ast-linearize)

;;;;=======================================================================
;;;;  String Hacking
;;;;=======================================================================
;;;;  TODO - Refactor this code into a strings module as soon as we
;;;;  switch to a new top-level compilation driver.

;;; Build a string containing the specified number of spaces.
(df string-repeat (str n)
  (if (<= n 0)
      ""
      (cat str (string-repeat str (- n 1)))))

;;; Split 'str' apart on occurrences of 'sep' (similar to Perl).
(df string-split ((str <str>) (sep <chr>) => <lst>)
  (let ((match (pos str sep)))
    (if (== nul match)
	(lst str)
	(pair (sub str 0 match)
	      (string-split (sub str (+ match 1) (len str)) sep)))))

;;; Join each string in 'strs' with 'sep' (similar to Perl).
(df string-join ((strs <lst>) (sep <str>) => <str>)
  (case
    ((empty? strs) "")
    ((empty? (tail strs)) (head strs))
    (#t (cat (head strs) sep (string-join (tail strs) sep)))))

;;; Map a function over each element of a string.
;;; TODO - Fix regular 'map' to work on strings.
(df map-str ((f <fun>) (s <str>) => <str>)
  (as <str> (map f (as <lst> s))))


;;;;=======================================================================
;;;;  Module Loading
;;;;=======================================================================
;;;;  We subclass the module loader and add our own code for locating and
;;;;  processing modules.

;;; Convert a module name to a relative path name.
;;;   foo/bar => "foo/bar" or "foo\\bar", etc.
;;; TODO - Where should this live?  Merge with proto-filename?
(df module-name-to-relpath ((name <sym>) => <str>)
  (let ((namestr (map-str as-lowercase (sym-name name))))
    (string-join (string-split namestr #\/) *path-separator*)))	 

(dv <p2c-module-loader> (isa <module-loader>))
  (slot <p2c-module-loader> (collected-ast <lst>) '())
  (slot <p2c-module-loader> (load-depth <int>) 0)

;;; TODO - Refactor into <module-loader>.
(df module-loader-begin-module ((loader <p2c-module-loader>) (name <sym>))
  (format out "%s[Loading module %s...\n"
          (string-repeat "  " (load-depth loader))
          name)
  (inc (load-depth loader)))

(df module-loader-end-module ((loader <p2c-module-loader>) (name <sym>))
  (dec (load-depth loader))
  (format out "%s]\n" (string-repeat "  " (load-depth loader))))

(dm load-module ((loader <p2c-module-loader>) (name <sym>) => <module>)
  (module-loader-begin-module loader name)
  (let ((mod  (fab-p2c-module loader name))
        (env  (module-target-environment mod))
        (file (module-name-to-relpath name))
        (ast  (compute-ast file env)))
    (module-loader-end-module loader name)
    (set (collected-ast loader)
         (pair ast (collected-ast loader)))
    mod))


;;;;=======================================================================
;;;;  Compiler Drivers
;;;;=======================================================================
;;;;  The new module-based compiler drivers.

;;; The basename to use for our output C file.
(dv *c-out-name* "proto")

;;; Given a file name and an environment, compute an ast in that
;;; environment.
(dm compute-ast (filename ct-env)
  (let ((in-name (proto-filename filename))
	(x       (read-file in-name)))
    (objectify x ct-env #f)))

;;; Compile a module to C, along with any supporting modules.
(df p2c-module (name)
  (let ((loader (isa <p2c-module-loader>)))
    (find-module loader name)
    (let ((out-name (c-filename *c-out-name*))) ;; filename
      (call-with-output-file
       out-name
       (fun (out-port)
         (let ((ast (sequentialize (rev (collected-ast loader)))))
           (compile->c-in ast loader out-port))))))
  #f)

;;; Backwards compatibility for users: Build p2c itself.
(dm p2c-top () (p2c-module 'main))

;;; Given an ast 'e', prepare it for compilation to C.  Store any
;;; new global bindings into the environment 'scratch-env'.
(dm compute-program (e scratch-env)
  (let ((obj (sexp->object e scratch-env))
	;; (format out "OBJ %=\n" obj)
	(dyn (analyze-dynamic-extent obj))
	;; (format out "DYN %=\n" dyn)
	(cal (analyze-calls dyn))
	;; (format out "CAL %=\n" cal)
	(lft (lift! cal))
	;; (format out "LFT %=\n" lft)
        (prg (extract-things! lft)))
    ;; (format out "EXT %=\n" prg)
    (let ((flt (closurize-main! prg scratch-env 64)))
    ;; (format out "FLT %=\n" flt)
    (gather-temporaries! flt)
    ;; (format out "TMP %=\n" flt)
    (register-allocate! flt)
    ;; (format out "REG %=\n" flt)
    ;; (format out "\n\n%=\n\n" prg)
    prg)))

(dv *definitions* #f) ;; TODO: thread variable

(dm compile->c-in (e loader code-out)
  (format out "Analyzing program.\n")
  (let ((scratch-mod (fab-p2c-module loader (as <sym> "---main---")))
        (scratch-env (module-target-environment scratch-mod))
        (prg (compute-program e scratch-env)))
    (format out "Searching for undefined bindings.\n")
    (do-module-loader-modules report-undefined-global-bindings loader)
    (format out "Generating C code.\n")
    (dlet ((*definitions* (program-definitions prg))) 
      (generate-c-program code-out e prg loader))))

(dm generate-c-program (out e prg loader)
  (generate-header out e)
  (generate-global-environment out loader)
  (generate-quotation-forwards out (program-quotations prg))
  (generate-function-forwards out (program-definitions prg))
  (generate-function-bodies out (program-definitions prg))
  (generate-main out (program-form prg)) 
  (generate-trailer out)
  prg)

;;;ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
;;;              generation

;;; file header and trailer are simple.

(dm pp (e out)
  ;; (print e out pretty?: #t) ;; TODO: PRETTY?
  (write out e)) 

(dm generate-header (out e)
  (format out "/* PROTO 2 C $REVISION: 0.2 $ \n")
  ;; (pp e out)
  (format out "  */\n\n#include \"prt.h\"\n"))

(dm generate-trailer (out)
  (format out "\n/* END OF GENERATED CODE. */\n"))

;;;ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
;;; generate global environment. for all global-bindings allocate a
;;; location to hold it. we also give the real name to the macro so
;;; that some reflective capabilities can be added to c.

;;; gb* is a list of instances of global-binding.

(dm generate-global-environment (out loader)
  (do-module-loader-modules
   (fun (mod)
     (format out "\n/* MODULE ENVIRONMENT: %s */\n\n" (module-name mod))
     (do-static-global-bindings
      (fun (binding)
        (when (binding-native-to? binding mod)
          (generate-global-binding out #f binding)))
      (module-target-environment mod)))
   loader))

(dm generate-global-binding (out imported? gb)
  (let ((name (binding-name gb)))
    (format out "%s(%s,\"%s\",\"%s\");\n" 
	    (if imported? "EXT" "DEF")
	    (mangle-module-binding gb)
            (mangle-string-literal (as <str> (binding-module-name gb)))
	    (mangle-string-literal (as <str> name)))))

(dm generate-global-binding (out imported? (gb <predefined-binding>)))
(dm generate-global-binding (out imported? (gb <magic-binding>)))
(dm generate-global-binding (out imported? (gb <macro-binding>)))

;;;; NAME MANGLING

(dv $module-separator               "Y")
(dv $local-suffix                   "_")
(dv $hygiene-marker	            "F")
(dv $escape-separator               "Z")
(dv $iep-suffix 	            "I")
(dv $method-mangled-marker-string   "M")

;; Note that the following must be characters rather than strings since
;; the initialization of mangles tables assumes that.

(dv $module-marker             (elt $module-separator 0))
(dv $local-marker              (elt $local-suffix 0))
(dv $hygiene-char              (elt $hygiene-marker 0))
(dv $escape-marker             (elt $escape-separator 0))
(dv $iep-marker                (elt $iep-suffix 0))
(dv $method-mangled-marker     (elt $method-mangled-marker-string 0))

(dv $min-character-code 0)
(dv $max-character-code 255) ;; We allow 8 bit ascii.

;;; MANGLING

(dv $mangles-data
  (vec #(#\- #\_) #(#\! #\X) #(#\$ #\D) #(#\% #\P) #(#\* #\T) 
       #(#\/ #\S) #(#\< #\L) #(#\> #\G) #(#\? #\Q) #(#\+ #\A)
       #(#\& #\B) #(#\^ #\C) #(#\_ #\U) #(#\@ #\O) #(#\= #\E)
       #(#\~ #\N)))

(dv <abstract-mangler> (isa <any>))
  (slot <abstract-mangler> mangler-buffer (isa <buf>))
  (slot <abstract-mangler> mangler-table  (fab <vec> (+ $max-character-code 1)))

(dv <mangler> (isa <abstract-mangler>))

(dv <simple-mangler> (isa <mangler>))

;; Guarantee instantiability of the <MANGLER> class.

(dm mangler-position ((mangler <mangler>) => <int>)
  (len (mangler-buffer mangler)))

(dm initialize-mangler-table ((mangler <mangler>) => <mangler>)
  (let ((table (mangler-table mangler)))
    ;; fill with default manglings
    (for ((i (from-to $min-character-code $max-character-code)))
      (set (elt table i)
	   (cat $escape-separator (mangle-integer i) $escape-separator)))
    ;; fill in special cases
    (for ((mangle $mangles-data))
      (set (elt table (as <int> (elt mangle 0))) (elt mangle 1)))
    ;; fill C allowable versions
    (for ((i (from-to (as <int> #\a) (as <int> #\z))))
      (set (elt table i) (as <chr> i)))
    (for ((i (from-to (as <int> #\0) (as <int> #\9))))
      (set (elt table i) (as <chr> i))))
  mangler)

(dv $c-escapes
  (let ((vec (fill (fab <vec> ascii-limit) #f)))
    (set (elt vec (as <int> #\tab)) "\\t")
    (set (elt vec (as <int> #\page)) "\\f")
    (set (elt vec (as <int> #\return)) "\\r")
    (set (elt vec (as <int> #\newline)) "\\n")
    (set (elt vec (as <int> #\")) "\\\"")
    (set (elt vec (as <int> #\\)) "\\\\")
    vec))

(dm mangle-string-literal ((str <str>) => <str>)
  (let ((len (len str)))
    (rep loop ((out "") (i 0))
	 (if (= i len)
	     out
	     (let ((c (elt str i))
		   (enc (elt $c-escapes (as <int> c))))
		 (if (= enc #f)
		     (loop (cat out (to-str c)) (+ i 1))
		     (loop (cat out enc) (+ i 1))))))))

(dv ($number-characters <str>) "0123456789")

(dm mangle-integer ((number <int>) => <str>)
  (rep process-integer (((number <int>) number) ((index <int>) 1))
    (let ((qr ;; (tup (quotient <int>) (remainder <int>)) ;; TODO: TUP'S 
	   (truncate/ number 10))
	  ((quotient <int>) (elt qr 0))
	  ((remainder <int>) (elt qr 1))
	  ((digit <chr>) (elt $number-characters remainder)))
      (if (= quotient 0)
	  (let (((result <str>) (fab <str> index)))
	    (set (elt result 0) digit)
	    result)
	  (let (((result <str>) (process-integer quotient (+ index 1))))
	    (set (elt result (- (len result) index)) digit)
	    result)))))

(dm mangler-as-string-from
    ((mangler <abstract-mangler>) (start <int>) => <str>)
  ;; (if (= start 0)
  ;;     (as <str> (mangler-buffer mangler))
  ;;     (as <str> (sub-from (mangler-buffer mangler) start)))
  (let (((buffer <buf>)
	(mangler-buffer mangler))
	((buffer-size <int>)
	 (len buffer))
	((string <str>)
	 (fab <str> (- buffer-size start))))
    ;; without-bounds-checks
    (for (((i <int>) (from-below start buffer-size))
	  ((j <int>) (from 0)))
      (set (elt string j) (elt buffer i)))
    ;; end without-bounds-checks
    string))

(dm mangler-as-string ((mangler <abstract-mangler>) => <str>)
  (mangler-as-string-from mangler 0))

;; The method for <mangler-with-options> is responsible for
;; installing the prefixes and suffixes in the final string.
;; (Is this the most efficient way? It certainly seems to be
;; the cleanest).

(dm mangler-reset
    ((mangler <abstract-mangler>) => <abstract-mangler>)
  (set (len (mangler-buffer mangler))  0)
  mangler)

(dm mangle-raw-into ((mangler <abstract-mangler>) (name <chr>))
  (add! (mangler-buffer mangler) name))

(dm mangle-raw-into ((mangler <abstract-mangler>) (name <str>))
  (cat! (mangler-buffer mangler) name))

(dm mangle-raw-into ((mangler <abstract-mangler>) (name <sym>))
  (cat! (mangler-buffer mangler) (as-lowercase (as <str> name))))

(dm mangle-name-into ((mangler <mangler>) (name <str>))
  (for ((c name))
    (mangle-raw-into mangler (elt (mangler-table mangler) (as <int> c)))))

(dm mangle-name-into ((mangler <mangler>) name)
  (mangle-name-into mangler (as-lowercase (as <str> name))))

(dm mangle-name-raw ((mangler <mangler>) name => <str>)
  (mangler-reset mangler)
  (mangle-name-into mangler name)
  (mangler-as-string mangler))

(dm mangle-name-locally ((mangler <mangler>) name => <str>)
  (mangler-reset mangler)
  (mangle-name-into mangler name)
  (mangle-raw-into mangler $local-suffix)
  (mangler-as-string mangler))
 
(dm mangle-name-globally ((mangler <mangler>) (modname <sym>) name
			  => <str>)
  (mangler-reset mangler)
  ;; Keep internal names as short as possible.
  (unless (== modname $proto-boot-module-name)
    (mangle-raw-into mangler $module-marker)
    (mangle-name-into mangler (as <str> modname)))
  (mangle-raw-into mangler $module-marker)
  (mangle-name-into mangler name)
  (mangler-as-string mangler))
 
(dm mangle-name-hygienically ((mangler <mangler>) name (marker <int>) => <str>)
  (mangler-reset mangler)
  (mangle-name-into mangler name)
  (cat (mangler-as-string mangler) $hygiene-marker (mangle-integer marker)))

;; TODO: would like initialization to happen more invisibly
(dv *mangler* (initialize-mangler-table (isa <simple-mangler>)))

(dm mangle-global-name ((modname <sym>) (name <str>) => <str>)
  (mangle-name-globally *mangler* modname name))

(dm mangle-global-name ((modname <sym>) (name <sym>) => <str>)
  (mangle-global-name modname (as <str> name)))

;; Mangle a name which is defined in boot.proto.
(dm mangle-boot-name (name => <str>)
  (mangle-global-name $proto-boot-module-name name))

;; Mangle a name which is defined in boot.proto.
(dm mangle-runtime-name (name => <str>)
  (mangle-global-name $proto-runtime-module-name name))

(dm mangle-module-binding ((binding <module-binding>) => <str>)
  (mangle-global-name (binding-module-name binding)
		      (binding-name binding)))

(dm mangle-local-name ((name <str>) => <str>)
  (mangle-name-locally *mangler* name))

(dm mangle-local-name ((name <sym>) => <str>)
  (mangle-local-name (as <str> name)))

(dm mangle-raw-name ((name <str>) => <str>)
  (mangle-name-raw *mangler* name))

(dm mangle-raw-name ((name <sym>) => <str>)
  (mangle-raw-name (as <str> name)))

(dm mangle-local-marked-name ((name <str>) (marker <int>) => <str>)
  (mangle-name-hygienically *mangler* name marker))

(dm mangle-local-marked-name ((name <sym>) (marker <int>) => <str>)
  (mangle-local-marked-name (as <str> name) marker))

;;; EMISSION

(ds (for-commas ,out-val (,@clauses) ,@body)
  (let ((out-var (gensym)))
    `(let ((,out-var ,out-val))
       (for (,@clauses (first? (first-then #t #f)))
         (unless first? (write-char ,out-var #\,))
         ,@body))))

(ds (between-parentheses (,out-val) ,@body)
  (let ((out-var (gensym)))
    `(let ((,out-var ,out-val))
       (write-char ,out-var #\() ,@body (write-char ,out-var #\)))))

(ds (between-parentheses-comma-separated (,out-val) ,@body)
  (let ((out-var (gensym)))
    `(let ((,out-var ,out-val))
       (write-char ,out-var #\() 
       ,@(rep loop ((forms '()) (body body) (first? #t))
           (if (empty? body)
               (rev! forms)
               (loop (pair (head body)
                           (pair (or first? `(write-char ,out-var #\,)) forms))
                     (tail body) 
                     #f)))
       (write-char ,out-var #\)))))

(dm gen-result ((e <program>) d out => <log>)
  (let ((reg (program-register e)))
    (and reg (format out "T%d = " reg) #t)))

(dm gen-depth ((d <int>) out)
  (for ((i (from-below 0 d)))
    (write-string out "  ")))

(ds (with-statement (,d ,out) ,@body)
  `(seq (gen-depth ,d ,out)
	,@body
	(format out ";\n")))

(ds (with-expression (,e ,d ,out) ,@body)
  `(with-statement (,d ,out)
     (gen-result ,e ,d ,out)
     ,@body))

(ds (with-used-expression (,e ,d ,out) ,@body)
  `(when (program-register ,e)
     (with-expression (,e ,d ,out) ,@body)))

;;; QUOTATION EMISSION

(dm generate-quotation-forwards (out (qb* <lst>))
  (format out "\n/* FORWARD QUOTATIONS: */\n\n")
  (for ((qb qb*))
    (format out "DEFLIT(lit_%s);\n" (binding-name qb))))

(dm generate-quotations (out (qb* <lst>))
  (for ((qb (rev qb*))) ;; TODO: BIP
    (with-statement (1 out)
      (format out "lit_%s = " (binding-name qb))
      (generate-quotation out (binding-value qb)))))

(dm false-name ()
  (mangle-boot-name "%false"))

(dm generate-quotation (out (qb <log>))
  (format out "%s" (mangle-boot-name (if qb "%true" "%false"))))

(dm generate-quotation (out (qb '()))
  (format out (mangle-boot-name "nil")))

(dm generate-quotation (out (qb <lst>))
  (format out "%s(" (mangle-boot-name "%pair"))
  (generate-quotation out (head qb))
  (format out ", ")
  (generate-quotation out (tail qb))
  (format out ")"))

(dm generate-quotation (out (x <int>))
  (format out "%s((P)%d)" (mangle-boot-name "%int") x))

(dm generate-quotation (out (x <chr>))
  (format out "%s((P)%d)" (mangle-boot-name "%chr") (as <int> x)))

(dm float-to-c-string ((o <flo>) => <str>)
  (let ((s (num-to-str o)))
  ;;---*** Is there a better way to do this???
  (lab done
    (rep loop ((i (- (len s) 1)))
      (if (> i (neg 1)) ;; TODO: -1
	  (select (elt s i)
	    ;;---*** Should be #\f but GCC complains!
	    ((#\s) (set (elt s i) #\e) (done #f)) 
	    ((#\d) (set (elt s i) #\e) (done #f)) 
	    ;;---*** Should be #\l but GCC complains!
	    ((#\x) (set (elt s i) #\e) (done #f)) 
	    (#t    (loop (- i 1))))
	  s)))))

(dm generate-quotation (out (x <flo>))
  (format out "%s(FLOINT(%s))" 
	  (mangle-boot-name "%flo") (float-to-c-string x)))

(dm generate-quotation (out (x <str>))
  (format out "%s((P)\"%s\")"
	  (mangle-boot-name "%sb")
	  (mangle-string-literal x)))

(dm generate-quotation (out (x <vec>))
  ;; TODO: TIE TOGETHER
  (format out "CALLN(%s, %s" (mangle-runtime-name "vec") (len x))
  (for ((e x))
    (format out ", ")
    (generate-quotation out e))
  (format out ")"))

(dm generate-quotation (out (x <sym>))
  (format out "%s((P)\"%s\")"
	  (mangle-boot-name "%%sym")
	  (mangle-string-literal (as <str> x))))

;;;
;;; CONVERT AN EXPRESSION TO C

;;; GENERATE THE NAME USED IN C FOR A BINDING.

(dg binding->c (binding out))

(dm binding->c ((binding <module-binding>) out)
  (write-string out (mangle-module-binding binding)))

(dm binding->c ((binding <local-binding>) out)
  (write-string out (mangle-local-name (binding-name binding))))

;; TODO: USE MANGLER FOR THIS
(dm binding->c ((binding <renamed-local-binding>) out)
  (write-string out
    (mangle-local-marked-name 
     (binding-name binding) (binding-index binding))))

(dm binding->c ((binding <quotation-binding>) out)
  (format out "lit_%s" (binding-name binding)))

;;; WORKS FOR LOCAL- GLOBAL- PREDEFINED- REFERENCES EXCEPT FOR FREE-REFERENCES.

(dg reference->c ((v <binding>) out))

(dm reference->c ((v <binding>) out)
  (binding->c v out))

(dm reference->c ((v <global-binding>) out)
  (format out "CHKREF")
  (between-parentheses (out)
    (binding->c v out)))

(dg to-c ((e <program>) f d out))

(dm to-c ((e <top-level-form>) f d out)
  (generate-quotations out (form-quotations e))
  (generate-functions (form-definitions e) f d out)
  (to-c (form-program e) f d out)
  (with-used-expression (e d out) (gen-ref (form-program e) out)))

(dm to-c ((e <passive-program>) f d out))

(dm gen-ref ((e <reference>) out)
  (reference->c (reference-binding e) out))

(dm gen-ref ((e <free-reference>) out)
  (format out "FREEREF")
  (between-parentheses (out)
    (format out "%d" (reference-offset e))))

(dm gen-ref ((e <program>) out)
  (let ((reg (program-register e)))
    (if reg (format out "T%d" reg) (write-string out "T_1"))))

(dm gen-ref ((e <raw-constant>) out)
  (format out "(P)%s" (constant-value e)))

(dm gen-ref ((e <constant>) out)
  (generate-quotation out (constant-value e)))

(dm gen-ref ((e <sequential>) out)
  (gen-ref (last e) out))

(dm to-c ((e <global-assignment>) f d out)
  (to-c (assignment-form e) f d out)
  (with-expression (e d out)
    (binding->c (assignment-binding e) out)
    (write-string out " = ") (gen-ref (assignment-form e) out)))

(dm to-c ((e <definition>) f d out)
  (next-method e f d out)
  (with-statement (d out)
    (let ((binding (assignment-binding e))
          (modstr  (as <str> (binding-module-name binding)))
          (namestr (as <str> (binding-name binding))))
      (format out "regsym(&")
      (binding->c binding out)
      (format out ",\"%s\",\"%s\")"
              (mangle-string-literal modstr)
              (mangle-string-literal namestr)))))

(dm to-c ((e <bound?>) f d out)
  (with-used-expression (e d out)
    (format out "BOUNDP")
    (between-parentheses (out)
      (binding->c (reference-binding (bound?-reference e)) out))))

;; TODO: DOES REF NEED TO BE TO-C'D

(dm to-c ((e <box-read>) f d out)
  (to-c (box-reference e) f d out)
  (with-used-expression (e d out)
    (write-string out "BOXVAL")
    (between-parentheses (out) 
      (gen-ref (box-reference e) out))))

(dm to-c ((e <box-write>) f d out)
  (to-c (box-form e) f d out)
  (with-expression (e d out)
    (format out "BOXVAL")
    (between-parentheses (out) 
      (gen-ref (box-reference e) out))
    (write-string out " = ") (gen-ref (box-form e) out)))

(dm to-c ((e <box-creation>) f d out)
  (with-expression (e d out)
    (let ((binding (reference-binding (box-reference (box-reference e)))))
      (binding->c binding out)
      (format out " = BOXFAB")
      (between-parentheses (out) (binding->c binding out)))))

(dm to-c ((e <alternative>) f d out)
  (to-c (alternative-condition e) f d out)
  (gen-depth d out)
  (write-string out "if (") (gen-ref (alternative-condition e) out)
  (format out " != %s) {\n" (false-name))
  (to-c (alternative-consequent e) f (+ d 1) out)
  (with-used-expression (e (+ d 1) out)
    (gen-ref (alternative-consequent e) out))
  (gen-depth d out) (format out "} else {\n")
  (to-c (alternative-alternant e) f (+ d 1) out)
  (with-used-expression (e (+ d 1) out)
    (gen-ref (alternative-alternant e) out))
  (gen-depth d out) (format out "}\n"))
    
(dm to-c ((e <sequential>) f d out)
  (do (fun (x) (to-c x f d out)) e))

(dm generate-self-recursive-call ((e <application>) f d out)
  (for ((arg (application-arguments e)))
    (to-c arg f d out))
  (for ((arg (application-arguments e)) (i (from 1)))
    (with-statement (d out)
      (format out "a%d = " i)
      (gen-ref arg out)))
  (for ((binding (function-bindings f)) (i (from 1)))
    (with-statement (d out)
      (binding->c binding out)
      (format out " = a%d" i)))
  (with-statement (d out)
    (write-string out "goto loop")))

(dv $number-call-templates 3)

(dm to-c ((e <regular-application>) f d out)
  (let ((function (application-function e)))
    (if (and (application-tail? e) 
	     (isa? f <flat-function>)
	     (not (function-nary? f))
	     (isa? function <free-reference>)
	     (reference-self? function))
	(generate-self-recursive-call e f d out)
	(let ((n (len (application-arguments e))))
          (to-c (application-function e) f d out)
          (for ((arg (application-arguments e)))
            (to-c arg f d out))
          (with-expression (e d out)
            (format out "%sCALL%s" 
                    (if (application-known? e) "K" "") 
                    (if (> n $number-call-templates) "N" n))
            (between-parentheses (out)
              (gen-ref (application-function e) out)
              (when (> n $number-call-templates) (format out ",%s" n))
              (for ((arg (application-arguments e)))
                (write-char out #\,) (gen-ref arg out))))))))

(dm to-c ((e <arguments>) f d out)
  (for-commas out ((x e))
    (gen-ref x out)))

(dm to-c ((e <fix-let>) f d out)
  (for-commas out ((binding (fix-let-bindings e)) (type (fix-let-types e))
                   (init (fix-let-arguments e)))
    (to-c init #f d out)
    (unless (unconstrained-type? type)
      (to-c type #f d out)
      (with-statement (d out)
        (format out "check_type")
        (between-parentheses-comma-separated (out)
          (gen-ref init out) (gen-ref type out))))
    (with-statement (d out)
      (binding->c binding out)
      (write-string out " = ") (gen-ref init out)))
  (to-c (fix-let-body e) f d out)
  (with-used-expression (e d out) (gen-ref (fix-let-body e) out)))

(dm to-c ((e <locals>) f d out)
  (for ((binding (locals-bindings e)) (init (locals-functions e)))
    (funshell-to-c binding init #f d out)
    (with-statement (d out)
      (binding->c binding out)
      (write-string out " = ") (gen-ref init out)))
  (do2 (rcurry funinit-to-c f d out) (locals-bindings e) (locals-functions e))
  (to-c (locals-body e) f d out)
  (with-used-expression (e d out) (gen-ref (locals-body e) out)))

(dm to-c ((e <bind-exit>) f d out)
  (to-c (bind-exit-main-fun e) f d out)
  (with-expression (e d out)
    (write-string out "with_exit")
    (between-parentheses (out) (gen-ref (bind-exit-main-fun e) out))))

(dm to-c ((e <unwind-protect>) f d out)
  (to-c (unwind-protect-protected-thunk e) f d out)
  (to-c (unwind-protect-cleanup-thunk e) f d out)
  (with-expression (e d out)
    (write-string out "with_cleanup")
    (between-parentheses-comma-separated (out)
      (gen-ref (unwind-protect-protected-thunk e) out)  
      (gen-ref (unwind-protect-cleanup-thunk e) out))))

(dm to-c ((e <monitor>) f d out)
  (to-c (monitor-handler e) f d out)
  (to-c (monitor-main-thunk e) f d out)
  (with-expression (e d out)
    (format out (mangle-runtime-name "%with-monitor"))
    (between-parentheses-comma-separated (out)
      (gen-ref (monitor-handler e) out)
      (gen-ref (monitor-main-thunk e) out))))

(dm to-c ((e <predefined-application>) f d out)
  (let ((binding (application-binding e)))
    (if (and (application-tail? e) 
	     (isa? f <primitive-definition>)
	     (== binding (function-name f)))
	(generate-self-recursive-call e f d out)
        (seq 
          (for ((arg (application-arguments e)))
            (to-c arg f d out)) ;; DODO: COERCE TO (P)
          (with-expression (e d out)
            (format out "(P)%s" 
                    (mangle-module-binding (application-binding e)))
            (between-parentheses (out)
              (for-commas out ((arg (application-arguments e)))
                (gen-ref arg out))))))))

(dm to-c ((e <closure-creation>) f d out)
  (let ((n (len (closure-creation-free e)))
        (f (elt *definitions* (closure-creation-index e))))
    (if (== n 0)
        (with-used-expression (e d out)
          (generate-function-name out f))
        ;; (format out "fun_%d" (closure-creation-index e))
        (seq (do (fun (x) (to-c x f d out)) (closure-creation-free e))
             (with-expression (e d out)
               (format out "FUNFAB")
               (between-parentheses (out)
                 (generate-function-name out f)
                 (format out ",%d" n)
                 (for ((x (closure-creation-free e)))
                   (write-char out #\,) (gen-ref x out))))))))

(dm funshell-to-c ((b <binding>) (e <closure-creation>) f d out)
  (let ((n (len (closure-creation-free e)))
	(f (elt *definitions* (closure-creation-index e))))
    (with-expression (e d out)
      (if (== n 0)
          (generate-function-name out f)
          ;; (format out "fun_%s" (closure-creation-index e))
	  (seq (format out "FUNSHELL")
	       (between-parentheses-comma-separated (out)
		 (format out "%d" (if (binding-dynamic-extent? b) 1 0))
		 (generate-function-name out f)
		 (format out "%d" n)))))))

(dm funinit-to-c ((b <binding>) (e <closure-creation>) f d out)
  (let ((n (len (closure-creation-free e))))
    (unless (== n 0)
      (do (fun (x) (to-c x f d out)) (closure-creation-free e))
      (with-statement (d out)
      	(format out "FUNINIT")
	(between-parentheses (out)
	  (binding->c b out)
	  (format out ", %s" n)
          (for ((x (closure-creation-free e)))
            (write-char out #\,) (gen-ref x out)))))))

(dm signature-arity ((e <ast-signature>))
  (let ((specs (signature-specs e)))
    (if (signature-nary? e) (- (len specs) 1) (len specs))))

(dm to-c ((e <ast-macro-definition>) f d out)
  (to-c (assignment-form e) #f d out)
  (with-expression (e d out)
    (format out "%s" (mangle-boot-name "%macro"))
    (between-parentheses-comma-separated (out)
      (generate-quotation out (binding-name (assignment-binding e)))
      (gen-ref (assignment-form e) out))))

(dm out-list-builder ((f <fun>) out (elts <lst>))
  (if (empty? elts)
      (format out "%s" (mangle-boot-name "nil"))
      (seq (format out "%s" (mangle-boot-name "%pair"))
	   (between-parentheses-comma-separated (out)
	     (f (head elts))
	     (out-list-builder f out (tail elts))))))

(dm generate-function-specs (out sig)
  ;; TODO: HACK -- THIS SHOULD BE CORRECTED EARLIER
  (let ((types (signature-specs sig))
        (specs (if (signature-nary? sig)
		   (sub types 0 (- (len types) 1))
		   types)))
    (out-list-builder (fun (x) (gen-ref x out)) out specs)))

(dm generate-function-names (out sig)
  (out-list-builder (fun (b) (generate-quotation out (binding-name b))) 
		    out (signature-names sig)))

(dm to-c ((e <ast-signature>) f d out)
  (do (fun (x) (to-c x f d out)) (signature-specs e))
  (to-c (signature-value e) f d out)
  (with-expression (e d out)
    (format out "%s" (mangle-boot-name "%sig"))
    (between-parentheses-comma-separated (out)
      (generate-function-names out e)
      (generate-function-specs out e)
      (generate-quotation out (signature-nary? e))
      (generate-quotation out (signature-arity e))
      (gen-ref (signature-value e) out))))

(dm generate-debug-name (out name)
  (generate-quotation out name))

(dm generate-debug-name (out (name <binding>))
  (generate-debug-name out (binding-name name)))

;; TODO: USE THIS WHEN CAN DIFF BETWEEN DM's AND DF's
;; (dm generate-debug-name (out (name <global-binding>))
;;   (binding->c name out))

(dm to-c ((e <ast-generic>) f d out)
  (to-c (function-signature e) f d out)
  (with-expression (e d out)
    (format out "%s" (mangle-boot-name "%gen"))
    (between-parentheses-comma-separated (out)
      (format out "(P)YPgen_code((P)CHKREF(YPdispatch))") ;; TODO: HACK!!!
      (generate-debug-name out (function-name e))
      (gen-ref (function-signature e) out)
      (format out (mangle-boot-name "nil"))
      (format out (mangle-boot-name "%false")))))

;;;
;;; FUNCTION DEFINITIONS

(dm generate-function-forwards (out definitions)
  (format out "\n/* FUNCTIONS: */\n\n")
  (for ((def definitions))
    (generate-function-forward out def)))

(dm generate-function-forward (out (defn <primitive-definition>))
  (format out "extern P %s (" 
	  (mangle-module-binding (function-name defn)))
  (for-commas out ((i (from-below 0 (len (function-bindings defn)))))
    (format out "P"))
  (format out ");\n"))

(dm generate-function-name (out defn)
  (let ((name (function-name defn)))
    (if (or (isa? name <global-binding>) (isa? name <runtime-binding>))
	(format out "%s" (mangle-module-binding name))
	;; (format-out "UNNAMED %=\n" defn)
	(if (== name #f)
	    (format out "fun_%s" (function-index defn))
	    (let ((name 
		   (if (isa? name <local-binding>) (binding-name name) name)))
	      (format out "fun_%s_%s"
		      (mangle-raw-name name) (function-index defn)))))))

(dm generate-function-forward (out defn)
  (let ((bound? (isa? (function-name defn) <global-binding>)))
    (format out (if bound?  "FUNFOR(" "LOCFOR("))
    (generate-function-name out defn)
    (format out ");\n")))

(dm generate-function-bodies (out definitions)
  (format out "\n/* FUNCTION CODES: */\n")
  (do (fun (def) 
	(generate-function-code out def))
      definitions))

(dm generate-functions (definitions f d out)
  (do (fun (def) 
	(unless (isa? def <primitive-definition>)
	  (generate-closure-structure def f d out)))
      (rev definitions)))

(dm generate-closure-structure (definition f d out)
  (to-c (function-signature definition) f d out)
  (with-expression (definition d out)
    (generate-function-name out definition)
    (format out " = %s" (mangle-boot-name "%met"))
    (between-parentheses-comma-separated (out)
      (generate-function-body-reference out definition)
      (generate-debug-name out (function-name definition))
      (gen-ref (function-signature definition) out)
      (format out "ENVNUL"))))

(dm generate-function-body-reference (out definition)
  (format out "FUNCODEREF(")
  (generate-function-name out definition)
  (format out ")"))

;; TODO: RIP THIS OUT AND USE REAL PARAMETERS
;; MAKE CALL SMART AND RESTIFY IF NEC
;; WOULD LIKE TO AVOID XEP APPROACH FIRST GO ROUND

(dm generate-shadow-args (bindings out)
  (unless (empty? bindings)
    (with-statement (1 out)
      (write-string out "P ")
      (for-commas out ((b bindings) (i (from 1)))
        (format out "a%d" i))))
  (write-string out "loop:\n"))

(dm generate-return ((defn <primitive-definition>) d out)
  (with-statement (d out)
    (write-string out "return ") (gen-ref (function-body defn) out)))

(dm generate-return (defn d out)
  (with-statement (d out)
    (when (unconstrained-type? (function-value defn))
      (write-char out #\Q))
    (write-string out "RET")
    (between-parentheses (out) (gen-ref (function-body defn) out))))

(dm primitive-inlinable? ((e <primitive-definition>))
  (let ((binding (function-name e)))
    ;; TODO: ADD FUNCTION ADJECTIVES
    (mem? '(%tag-bits %tag %untag %traits-of
	    %int %ib %iu
	    %chr %cb %cu
	    %loc %lb %lu
	    @== @@== not
	    %empty? %head %tail
	    @= @+ @<
            %gen-cache-arg-pos %gen-cache-singletons %gen-cache-classes
	    @head @tail
	    %isa? %object-parents
	    slot-value-at slot-value-at-setter
	    gen-lookup gen-lookup-1-using
	    )
 	   (binding-name binding))))

(dm generate-function-code (out (e <primitive-definition>))
  (format out "\n%sP " (if (primitive-inlinable? e) "INLINE " ""))
  (binding->c (function-name e) out)
  (between-parentheses (out)
    (for-commas out ((binding (function-bindings e)))
      (format out "P ") (binding->c binding out)))
  (format out " {\n")
  (generate-local-temporaries (function-temporaries e) out)
  (generate-registers (function-registers e) out)
  (generate-shadow-args (function-bindings e) out)
  (to-c (function-body e) e 1 out)
  (generate-return e 1 out)
  (format out "}\n"))

(dm generate-function-code (out definition)
  (format out "\nFUNCODEDEF(")
  (generate-function-name out definition)
  (format out ") {\n")
  (let ((offset 0)
	(bindings (function-bindings definition)))
    (do (fun (b)
	  (when (isa? b <binding>)
            (with-statement (1 out)
	      (write-string out "ARG(")
	      (binding->c b out)
	      (format out ", %d)" offset))
	    (set offset (+ offset 1))))
	(rev bindings))
    (generate-local-temporaries (function-temporaries definition) out)
    (generate-registers (function-registers definition) out)
    (generate-shadow-args (function-bindings definition) out)
    (to-c (function-body definition) definition 1 out)
    (generate-return definition 1 out)
    (format out "}\n")))

(dm generate-local-temporaries (temps out)
  (for ((temp temps))
    (with-statement (1 out)
      (write-string out "P ") (binding->c temp out))))

(dv *trace-registers?* #f)

(dv *registers-per-line* 16)

(dm generate-registers (regs out)
  (rep next-line ((regs regs))
    (unless (empty? regs)
      (gen-depth 1 out) (write-string out "P ")
      (rep next-reg ((regs regs) (i 0))
        (if (or (= i *registers-per-line*) (empty? regs))
            (seq (write-string out ";\n") (next-line regs))
            (seq (unless (= i 0) (write-char out #\,))
                 (gen-ref (head regs) out)
                 (next-reg (tail regs) (+ i 1))))))))

(dm generate-main (out form)
  (format out "\n/* EXPRESSION: */\nint main(int argc, char* argv[]) {\n")
  (format out "  %s(argc, argv);\n" (mangle-boot-name "%init-world"))
  ;; (format out "  %s" (mangle-boot-name "print-out"))
  (to-c form #f 1 out)
  (format out "  return(0);\n")
  (format out "}\n"))

(export
  p2c-module
  p2c-top)
