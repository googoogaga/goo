;;;; g2c - Goo-to-C compiler
;;;; Copyright (c) 2001 Jonathan Bachrach
;;;; BASED ON Lisp In Small Pieces by Christian Queinnec
;;;;
;;;; General notes on this file:
;;;;
;;;; It is unlikely that the any format specifier other than %s should ever
;;;; be used to output C code. There is no guarantee that the goo formatted
;;;; output is equivalent to C formatted output.
;;;;
;;;; All mentions of %= have been excised, %d seems relatively harmless and
;;;; remains at the moment.

(use runtime/boot)
(use goo/macros)
(use runtime/runtime)
(use goo/io/write)
(use compiler/ast)
(use compiler/top)
(use compiler/ast-linearize)
(use goo/collections/strings)
(use goo/system)
(use goo/types)
(use goo/math)
(use goo/collections)
(use goo/io/port)

(ddv *definitions*      #f)
(ddv *dynamic-linking?* #f)


;;;;=======================================================================
;;;;  Module Loading
;;;;=======================================================================
;;;;  We subclass the module loader and add our own code for locating and
;;;;  processing modules.

(dc <g2c-module-loader> (<module-loader>))
  (dp module-loader-appname (x|<g2c-module-loader> => <str>))
  (dp module-loader-app-modname (x|<g2c-module-loader> => <sym>))

(dc <g2c-module> (<module>))
  (dp module-src-file (x|<g2c-module> => <str>))
  (dp module-mtime (x|<g2c-module> => <flo>))

(dm module-loader-module-type (loader|<g2c-module-loader> => <type>)
  <g2c-module>)

(dm load-module (loader|<g2c-module-loader> name|<sym> => <module>)
  (def mod      (fab-g2c-module loader name))
  (def keepmod? #f)
  (def env      (module-target-environment mod))
  (def file     (module-name-to-relpath name))
  (def src-file (add-src-path (goo-filename file)))
  (def out-file (add-build-path (module-loader-appname loader)
                                (c-filename file)))
  (set (module-src-file mod) src-file)
  (set (module-mtime mod) (file-mtime src-file))
  ;; (format out "Computing ast for %s.\n" name)
  (def ast      (compute-ast src-file env))
  ;; (format out "Computing program for %s.\n" name)
  (def prg    (compute-program ast env))
  ;; (format out "Generating C code for %s.\n" name)
  (probe-directory (parent-directory out-file))
  (with-port (out-port (open <file-out-port> out-file))
             (dlet ((*definitions* (program-definitions prg))) 
               (generate-c-module out-port ast prg mod)))
  ;;; No need to call roll-back-transaction here--we can
  ;;; rely on the compilation subtransaction to do all
  ;;; the work.
  mod)

(df module-up-to-date? (mod|<g2c-module> => <log>)
  (>= (module-mtime mod) (file-mtime (module-src-file mod))))

(df purge-outdated-modules (loader|<module-loader>)
  (def changed '())

  ;; Figure out which modules have changed...
  (do-module-loader-modules
   (fun (mod)
     (when (not (module-up-to-date? mod))
       (pushf changed (module-name mod))))
   loader)

  ;; ...notify the user, and dump them.
  (do (fun (name) (format out "%s has changed.\n" name)) changed)
  (remove-modules-by-name! loader changed))


;;;;=======================================================================
;;;;  Compiler Drivers
;;;;=======================================================================
;;;;  The new module-based compiler drivers.

;;; Create a module loader for the specified application.  'appname'
;;; will be used as the executable name.  'modname' will be used to
;;; recursively load all the modules which make up the application.
;;; TODO - Hide module loader inside wrapper object?
(df g2c-def-app (appname|<str> modname|<sym> => <g2c-module-loader>)
  (new <g2c-module-loader>
    module-loader-appname     appname
    module-loader-app-modname modname))

;;; Given a module loader, generate an up-to-date C program.
(df g2c-build-app (loader|<g2c-module-loader> => #f)
  (purge-outdated-modules loader)
  (def mod (probe-module loader (module-loader-app-modname loader)))
  (puts out "Searching for undefined global bindings.\n")
  (do-module-loader-modules report-undefined-global-bindings loader)
  (generate-c-application loader mod)
  (generate-makefile loader)
  #f)

(df g2c-test (x)
  (set *g2c-app* (g2c-def-app (cat "g2c-" (to-str x)) 'compiler/main)))

(dv *tmp-file-counter* -1)

(dm g2c-ast (ast env)
  (def mod      (environment-module env))
  (def name     (format-to-string 
                 "exp-%d-%d" (process-id) (incf *tmp-file-counter*)))
  (def file     (add-tmp-path name))
  (def out-file (c-filename file))
  (def prg      (compute-program ast env))
  (with-port (out-port (open <file-out-port> out-file))
    (dlet ((*dynamic-linking?* #t)
           (*definitions*      (program-definitions prg))) 
      (generate-c-module out-port ast prg mod)))
  file)

(dm g2c-exp (exp env)
  (g2c-ast (objectify-with-subtransaction exp env #f) env))

(dl %compile)
(dl %load)

(dm compile-load (name)
  (%compile (%su name))
  (%load (%su name)))

(dm so-load (name)
  (%load (%su name)))  

(dm g2c-eval (exp env)
  (def name (g2c-exp exp env))
  (compile-load name))

(dm g2c-eval (ast|<program> env)
  (def name (g2c-ast ast env))
  (compile-load name))

;;; Backwards compatibility for users: Build g2c itself.
(dv *g2c-app* (g2c-def-app "g2c" 'compiler/main))
(dm g2c-top () (g2c-build-app *g2c-app*))
(dm g2c-clean ()
  (set *g2c-app* (g2c-def-app "g2c" 'compiler/main))
  #f)

;;; Given a file name and an environment, compute an ast in that
;;; environment.
(dm compute-ast (filename ct-env)
  (objectify-with-subtransaction (read-file filename) ct-env #f))

;;; Given an ast 'e', prepare it for compilation to C.  Store any
;;; new global bindings into the environment 'scratch-env'.
(dm compute-program (e env)
  (def box (insert-box! e))
  ;; (format out "BOX %=\n" box)
  (def dyn (analyze-dynamic-extent box))
  ;; (format out "DYN %=\n" dyn)
  (def cal (analyze-calls dyn))
  ;; (format out "CAL %=\n" cal)
  (def lft (lift! cal))
  ;; (format out "LFT %=\n" lft)
  (def prg (extract-things! lft))
  ;; (format out "EXT %=\n" prg)
  (def flt (closurize-main! prg env 64))
  ;; (format out "FLT %=\n" flt)
  (gather-temporaries! flt)
  ;; (format out "TMP %=\n" flt)
  (register-allocate! flt #f)
  ;; (format out "REG %=\n" flt)
  ;; (format out "\n\n%=\n\n" prg)
  prg)

(dm generate-c-module (code-out e prg mod)
  (generate-header code-out e)
  (generate-global-environment code-out mod)
  (generate-quotation-forwards code-out (program-quotations prg))
  (generate-function-forwards code-out (program-definitions prg))
  (generate-function-bodies code-out (program-definitions prg))
  (unless *dynamic-linking?*
    (generate-module-info code-out mod))
  (generate-module-init code-out mod (program-form prg)) 
  (generate-trailer code-out)
  prg)

(dm generate-c-application (loader|<module-loader> mod|<module>)
  (def appname   (module-loader-appname loader))
  (def init-name (cat appname "-init"))
  (def out-name (add-build-path appname (c-filename init-name)))
  (with-port (out-port (open <file-out-port> out-name))
    (generate-header out-port #f)
    (generate-main out-port mod)
    (generate-trailer out-port))
  #f)

(dm generate-makefile (loader|<module-loader>)
  (def appname   (module-loader-appname loader))
  (def init-name (cat appname "-init"))
  (def exe-name  (exe-filename appname))
  (def sep       *path-separator*)
  (def out-name  (add-build-path appname "Makefile"))
  (with-port (code-out (open <file-out-port> out-name))
    (format code-out "include ..%sMake.inc\n" sep)
    (format code-out "C_OBJS_DD = $(patsubst %%,..%s%%,$(C_OBJS))\n" sep)
    (format code-out "%s%s: ..%sgrt.h\n" *c-extension* *obj-extension* sep)
    (format code-out "\t$(CC) -I.. -c -g -O -o $@ $<\n\n")
    (format code-out "OBJS = \\\n")
    (do-module-loader-modules
     (fun (mod)
       (format code-out "\t%s \\\n"
               (obj-filename (module-name-to-relpath (module-name mod)))))
     loader)
    (format code-out "\t%s\n\n" (obj-filename init-name))
    (format code-out "%s: $(C_OBJS_DD) $(OBJS)\n" exe-name)
    (format code-out "\t$(CC) -Wl,--export-dynamic -o %s $(C_OBJS_DD) $(LIBS) $(OBJS)\n\n"
            exe-name sep sep)
    (format code-out "clean:\n\trm -f %s $(OBJS)\n"
            exe-name sep)))


;;;ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
;;;              generation

;;; file header and trailer are simple.

(dm pp (e code-out)
  ;; (print e out pretty?: #t) ;; TODO: PRETTY?
  (write code-out e)) 

(dm generate-header (code-out e)
  (format code-out "/* GOO 2 C $REVISION: 0.111 $ \n")
  ;; (when pp (pp e code-out))
  (format code-out "  */\n\n#include \"grt.h\"\n")
  (when *dynamic-linking?*
    (format code-out "#include \"dlgrt.h\"\n")))

(dm generate-trailer (code-out)
  (format code-out "\n/* END OF GENERATED CODE. */\n"))

;;;ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
;;; generate global environment. for all global-bindings allocate a
;;; location to hold it. we also give the real name to the macro so
;;; that some reflective capabilities can be added to c.

;;; gb* is a list of instances of global-binding.

(dm generate-global-environment (code-out mod)
  (format code-out "\n/* MODULE ENVIRONMENT: %s */\n\n" (module-name mod))
  (do-static-global-bindings
   (fun (binding)
     (generate-global-binding code-out
                              (not (binding-native-to? binding mod))
                              binding))
   (module-target-environment mod)))

(dm generate-global-binding (code-out imported? gb)
  (def kind (binding-kind gb))
  (when (or (== kind 'global) (== kind 'runtime))
    (def name (binding-name gb))
    (format code-out "%s(%s,\"%s\",\"%s\");\n" 
            (if imported? "EXT" "DEF")
            (mangle-module-binding gb)
            (mangle-string-literal (binding-module-name gb))
            (mangle-string-literal name))))

;;;; NAME MANGLING

(dv $module-separator               "Y")
(dv $local-suffix                   "_")
(dv $hygiene-marker	            "F")
(dv $escape-separator               "Z")
(dv $iep-suffix 	            "I")
(dv $method-mangled-marker-string   "M")

;; Note that the following must be characters rather than strings since
;; the initialization of mangles tables assumes that.

(dv $module-marker             (elt $module-separator 0))
(dv $local-marker              (elt $local-suffix 0))
(dv $hygiene-char              (elt $hygiene-marker 0))
(dv $escape-marker             (elt $escape-separator 0))
(dv $iep-marker                (elt $iep-suffix 0))
(dv $method-mangled-marker     (elt $method-mangled-marker-string 0))

(dv $min-character-code 0)
(dv $max-character-code 255) ;; We allow 8 bit ascii.

;;; MANGLING

(dv *mangle-buffer* (new <buf>))

(dv $mangles-data
  (vec #(#\- #\_) #(#\! #\X) #(#\$ #\D) #(#\% #\P) #(#\* #\T) 
       #(#\/ #\S) #(#\< #\L) #(#\> #\G) #(#\? #\Q) #(#\+ #\A)
       #(#\& #\B) #(#\^ #\C) #(#\_ #\U) #(#\@ #\O) #(#\= #\E)
       #(#\~ #\N) #(#\| #\K)))

(df char-buffer-as-string (buffer|<buf> => <str>)
  (def buffer-size|<int> (len buffer))
  (def string|<str>      (fab <str> buffer-size))
  ;; without-bounds-checks
  (for (((i <int>) (below buffer-size)))
    (set (elt string i) (elt buffer i)))
  ;; end without-bounds-checks
  string)

(dv $c-escapes
  (let ((vec (fill (fab <vec> ascii-limit) #f)))
    (set (elt vec (as <int> #\tab)) "\\t")
    (set (elt vec (as <int> #\page)) "\\f")
    (set (elt vec (as <int> #\return)) "\\r")
    (set (elt vec (as <int> #\newline)) "\\n")
    (set (elt vec (as <int> #\")) "\\\"")
    (set (elt vec (as <int> #\\)) "\\\\")
    vec))

(dm mangle-string-literal (str|<str> => <str>)
  (set (len *mangle-buffer*) 0)
  (def len (len str))
  (rep loop ((i 0))
    (if (= i len)
        (char-buffer-as-string *mangle-buffer*)
        (let ((c (elt str i))
              (enc (elt $c-escapes (as <int> c))))
          (if (= enc #f)
              (add! *mangle-buffer* c)
              (cat! *mangle-buffer* enc))
          (loop (+ i 1))))))

(dm mangle-string-literal (sym|<sym> => <str>)
  (mangle-string-literal (sym-name sym)))

(dv ($number-characters <str>) "0123456789")

(dm mangle-integer (number|<int> => <str>)
  (rep process-integer (((number <int>) number) ((index <int>) 1))
    (def (tup quotient|<int> remainder|<int>) (trunc/ number 10))
    (def digit|<chr> (elt $number-characters remainder))
    (if (= quotient 0)
        (let ((result|<str> (fab <str> index)))
          (set (elt result 0) digit)
          result)
        (let ((result|<str> (process-integer quotient (+ index 1))))
          (set (elt result (- (len result) index)) digit)
          result))))

(dv $name-mangler-table
  (let ((table (fab <vec> (+ $max-character-code 1))))
    ;; fill with default manglings
    (for ((i (range $min-character-code <= $max-character-code)))
      (set (elt table i)
           (cat $escape-separator (mangle-integer i) $escape-separator)))
    ;; fill in special cases
    (for ((mangle $mangles-data))
      (set (elt table (as <int> (elt mangle 0))) (elt mangle 1)))
    ;; fill C allowable versions
    (for ((i (range (as <int> #\a) <= (as <int> #\z))))
      (set (elt table i) (as <chr> i)))
    (for ((i (range (as <int> #\0) <= (as <int> #\9))))
      (set (elt table i) (as <chr> i)))
    table))

;;; Name mangler

(df mangler-reset (buffer|<buf>)
  (set (len buffer) 0))

(df mangle-name-into (buf|<buf> name|<str>)
  (for ((c name))
    (add! buf (elt $name-mangler-table (as <int> (to-lower c))))))

(dm mangle-raw-name (name|<str> => <str>)
  (mangler-reset *mangle-buffer*)
  (mangle-name-into *mangle-buffer* name)
  (char-buffer-as-string *mangle-buffer*))

(dm mangle-raw-name (name|<sym> => <str>)
  (mangle-raw-name (as <str> name)))

(dm mangle-local-name (name|<str> => <str>)
  (mangler-reset *mangle-buffer*)
  (mangle-name-into *mangle-buffer* name)
  (add! *mangle-buffer* $local-marker)
  (char-buffer-as-string *mangle-buffer*))

(dm mangle-local-name (name|<sym> => <str>)
  (mangle-local-name (as <str> name)))


(dm mangle-global-name (modname|<sym> name|<str> => <str>)
  (mangler-reset *mangle-buffer*)
  ;; Keep internal names as short as possible.
  (unless (== modname $goo-boot-module-name)
    (add! *mangle-buffer* $module-marker)
    (mangle-name-into *mangle-buffer* (as <str> modname)))
  (add! *mangle-buffer* $module-marker)
  (mangle-name-into *mangle-buffer* name)
  (char-buffer-as-string *mangle-buffer*))

(dm mangle-global-name (modname|<sym> name|<sym> => <str>)
  (mangle-global-name modname (as <str> name)))

;; Mangle a name which is defined in boot.goo.
;; Be sure to provide a matching EXT declaration in grt.h.
(dm mangle-boot-name (name => <str>)
  (mangle-global-name $goo-boot-module-name name))

(dm mangle-module-binding (binding|<module-binding> => <str>)
  (mangle-global-name (binding-module-name binding)
		      (binding-name binding)))

(dm mangle-local-marked-name (name|<str> marker|<int> => <str>)
  (mangler-reset *mangle-buffer*)
  (mangle-name-into *mangle-buffer* name)
  (add! *mangle-buffer* $hygiene-char)
  (cat! *mangle-buffer* (mangle-integer marker))
  (char-buffer-as-string *mangle-buffer*))

(dm mangle-local-marked-name (name|<sym> marker|<int> => <str>)
  (mangle-local-marked-name (as <str> name) marker))

;;; EMISSION

(ds (for-commas ,out-val (,@clauses) ,@body)
  (let ((out-var (gensym)))
    `(let ((,out-var ,out-val))
       (for (,@clauses (first? (first-then #t #f)))
         (unless first? (put ,out-var #\,))
         ,@body))))

(ds (between-parentheses (,out-val) ,@body)
  (let ((out-var (gensym)))
    `(let ((,out-var ,out-val))
       (put ,out-var #\() ,@body (put ,out-var #\)))))

(ds (between-parentheses-comma-separated (,out-val) ,@body)
  (let ((out-var (gensym)))
    `(let ((,out-var ,out-val))
       (put ,out-var #\() 
       ,@(rep loop ((forms '()) (body body) (first? #t))
           (if (empty? body)
               (rev! forms)
               (loop (pair (head body)
                           (pair (or first? `(put ,out-var #\,)) forms))
                     (tail body) 
                     #f)))
       (put ,out-var #\)))))

(dm gen-result (e|<program> d code-out => <log>)
  (def reg (program-register e))
  (and reg (format code-out "T%d = " reg) #t))

(dm gen-depth (d|<int> code-out)
  (for ((i (below d)))
    (puts code-out "  ")))

(ds (with-statement (,d ,code-out) ,@body)
  `(seq (gen-depth ,d ,code-out)
	,@body
	(puts ,code-out ";\n")))

(ds (with-expression (,e ,d ,code-out) ,@body)
  `(with-statement (,d ,code-out)
     (gen-result ,e ,d ,code-out)
     ,@body))

(ds (with-used-expression (,e ,d ,code-out) ,@body)
  `(when (program-register ,e)
     (with-expression (,e ,d ,code-out) ,@body)))

;;; QUOTATION EMISSION

(dm generate-quotation-forwards (code-out (qb* <col>))
  (format code-out "\n/* FORWARD QUOTATIONS: */\n\n")
  (for ((qb qb*))
    (format code-out "DEFLIT(lit_%s);\n" (binding-name qb))))

(dm generate-quotations (code-out qb*|<lst>)
  (for ((qb (rev qb*))) ;; TODO: BIP
    (with-statement (1 code-out)
      (format code-out "lit_%s = " (binding-name qb))
      (generate-quotation code-out (binding-info qb)))))

(dm false-name ()
  (mangle-boot-name "%false"))

(dm generate-quotation (code-out qb|<log>)
  (puts code-out (mangle-boot-name (if qb "%true" "%false"))))

(dm generate-quotation (code-out (qb (t= '())))
  (puts code-out (mangle-boot-name "nil")))

(dm generate-quotation (code-out qb|<lst>)
  (out-list-builder (fun (x) (generate-quotation code-out x)) code-out qb))

(dm generate-quotation (code-out x|<int>)
  (format code-out "%s((P)%d)" (mangle-boot-name "%int") x))

(dm generate-quotation (code-out x|<chr>)
  (format code-out "%s((P)%d)" (mangle-boot-name "%chr") (as <int> x)))

(dm float-to-c-string (o|<flo> => <str>)
  (def s (num-to-str o))
  ;;---*** Is there a better way to do this???
  (esc done
    (rep loop ((i (- (len s) 1)))
      (if (> i (neg 1)) ;; TODO: -1
	  (case (elt s i)
	    ;;---*** Should be #\f but GCC complains!
	    ((#\s) (set (elt s i) #\e) (done #f)) 
	    ((#\d) (set (elt s i) #\e) (done #f)) 
	    ;;---*** Should be #\l but GCC complains!
	    ((#\x) (set (elt s i) #\e) (done #f)) 
	    (#t    (loop (- i 1))))
	  s))))

(dm generate-quotation (code-out x|<flo>)
  (format code-out "%s(FLOINT(%s))" 
	  (mangle-boot-name "%flo") (float-to-c-string x)))

(dm generate-quotation (code-out x|<str>)
  (format code-out "%s((P)\"%s\")"
	  (mangle-boot-name "%sb")
	  (mangle-string-literal x)))

(dm generate-quotation (code-out x|<vec>)
  ;; TODO: TIE TOGETHER
  (format code-out "CALLN(1, %s, %s" (mangle-boot-name "vec") (len x))
  (for ((e x))
    (puts code-out ", ")
    (generate-quotation code-out e))
  (puts code-out ")"))

(dm generate-quotation (code-out x|<sym>)
  (format code-out "%s((P)\"%s\")"
	  (mangle-boot-name "%%sym")
	  (mangle-string-literal x)))

;;;
;;; CONVERT AN EXPRESSION TO C

;;; GENERATE THE NAME USED IN C FOR A BINDING.

(dg binding->c (binding code-out))

(dm binding->c (binding|<module-binding> code-out)
  (if (== (binding-kind binding) 'quotation)
      (format code-out "lit_%s" (binding-name binding))
      (puts code-out (mangle-module-binding binding))))

(dm binding->c (binding|<local-binding> code-out)
  (puts code-out (mangle-local-name (binding-name binding))))

;; TODO: USE MANGLER FOR THIS
(dm binding->c (binding|<renamed-local-binding> code-out)
  (puts code-out
    (mangle-local-marked-name 
     (binding-name binding) (binding-index binding))))

;;; WORKS FOR LOCAL- GLOBAL- PREDEFINED- REFERENCES EXCEPT FOR FREE-REFERENCES.

(dg reference->c (v|<binding> code-out))

(dm reference->c (v|<binding> code-out)
  (binding->c v code-out))

(dm reference->c (v|<module-binding> code-out)
  (puts 
   code-out (if (== (binding-kind v) 'quotation) "LITREF" "VARREF"))
  (between-parentheses (code-out)
    (binding->c v code-out)))

(dg to-c (e|<program> f d code-out))

(dm to-c (e|<top-level-form> f d code-out)
  (generate-quotations code-out (form-quotations e))
  (generate-functions (form-definitions e) f d code-out)
  (to-c (form-program e) f d code-out)
  (with-used-expression (e d code-out) (gen-ref (form-program e) code-out)))

(dm to-c (e|<passive-program> f d code-out))

(dm gen-ref (e|<reference> code-out)
  (reference->c (reference-binding e) code-out))

(dm gen-ref (e|<free-reference> code-out)
  (puts code-out "FREEREF")
  (between-parentheses (code-out)
    (format code-out "%d" (reference-offset e))))

(dm gen-ref (e|<program> code-out)
  (def reg (program-register e))
  (if reg (format code-out "T%d" reg) (puts code-out "T_1")))

(dm gen-ref (e|<raw-constant> code-out)
  (format code-out "(P)%s" (constant-value e)))

(dm gen-ref (e|<constant> code-out)
  (generate-quotation code-out (constant-value e)))

(dm gen-ref (e|<sequential> code-out)
  (gen-ref (last e) code-out))

(dm to-c (e|<global-assignment> f d code-out)
  (to-c (assignment-form e) f d code-out)
  (with-expression (e d code-out)
    (puts code-out "VARSET(")
    (binding->c (assignment-binding e) code-out)
    (puts code-out ",") 
    (gen-ref (assignment-form e) code-out)
    (puts code-out ")")))

(dm to-c (e|<bound?> f d code-out)
  (with-used-expression (e d code-out)
    (puts code-out "BOUNDP")
    (between-parentheses (code-out)
      (binding->c (reference-binding (bound?-reference e)) code-out))))

;; TODO: DOES REF NEED TO BE TO-C'D

(dm to-c (e|<box-read> f d code-out)
  (to-c (box-reference e) f d code-out)
  (with-used-expression (e d code-out)
    (puts code-out "BOXVAL")
    (between-parentheses (code-out) 
      (gen-ref (box-reference e) code-out))))

(dm to-c (e|<box-write> f d code-out)
  (to-c (box-form e) f d code-out)
  (with-expression (e d code-out)
    (puts code-out "BOXVAL")
    (between-parentheses (code-out) 
      (gen-ref (box-reference e) code-out))
    (puts code-out " = ") (gen-ref (box-form e) code-out)))

(dm to-c (e|<box-creation> f d code-out)
  (with-expression (e d code-out)
    (def binding (reference-binding (box-reference (box-reference e))))
    (binding->c binding code-out)
    (puts code-out " = BOXFAB")
    (between-parentheses (code-out) (binding->c binding code-out))))

(dm to-c (e|<alternative> f d code-out)
  (to-c (alternative-condition e) f d code-out)
  (gen-depth d code-out)
  (puts code-out "if (") (gen-ref (alternative-condition e) code-out)
  (format code-out " != %s) {\n" (false-name))
  (to-c (alternative-consequent e) f (+ d 1) code-out)
  (with-used-expression (e (+ d 1) code-out)
    (gen-ref (alternative-consequent e) code-out))
  (gen-depth d code-out) (puts code-out "} else {\n")
  (to-c (alternative-alternant e) f (+ d 1) code-out)
  (with-used-expression (e (+ d 1) code-out)
    (gen-ref (alternative-alternant e) code-out))
  (gen-depth d code-out) (puts code-out "}\n"))

(dm to-c (e|<sequential> f d code-out)
  (do (fun (x) (to-c x f d code-out)) e))

(dm generate-self-recursive-call (e|<application> f d code-out)
  (for ((arg (application-arguments e)))
    (to-c arg f d code-out))
  (for ((arg (application-arguments e)) (i (from 1)))
    (with-statement (d code-out)
      (format code-out "a%d = " i)
      (gen-ref arg code-out)))
  (for ((binding (function-bindings f)) (i (from 1)))
    (with-statement (d code-out)
      (binding->c binding code-out)
      (format code-out " = a%d" i)))
  (with-statement (d code-out)
    (puts code-out "goto loop")))

(dv $number-call-templates 3)

(dm to-c (e|<regular-application> f d code-out)
  (def function (application-function e))
  (if (and (application-tail? e) 
           (isa? f <ast-method>)
           (not (function-nary? f))
           (isa? function <free-reference>)
           (reference-self? function))
      (generate-self-recursive-call e f d code-out)
      (let ((n (len (application-arguments e))))
        (to-c (application-function e) f d code-out)
        (for ((arg (application-arguments e)))
          (to-c arg f d code-out))
        (with-expression (e d code-out)
          (format code-out "CALL%s" 
                  (if (> n $number-call-templates) "N" n))
          (between-parentheses (code-out)
            (puts code-out (if (application-known? e) "0," "1,") )
            (gen-ref (application-function e) code-out)
            (when (> n $number-call-templates) (format code-out ",%s" n))
            (for ((arg (application-arguments e)))
              (put code-out #\,) (gen-ref arg code-out)))))))

(dm to-c (e|<arguments> f d code-out)
  (for-commas code-out ((x e))
    (gen-ref x code-out)))

(dm to-c (e|<fix-let> f d code-out)
  (for ((binding (fix-let-bindings e))
        (type    (fix-let-types e))
        (init    (fix-let-arguments e)))
    (to-c init #f d code-out)
    (unless (unconstrained-type? type)
      (to-c type #f d code-out)
      (with-statement (d code-out)
        (puts code-out "check_type")
        (between-parentheses-comma-separated (code-out)
          (gen-ref init code-out) (gen-ref type code-out))))
    (with-statement (d code-out)
      (binding->c binding code-out)
      (puts code-out " = ") (gen-ref init code-out)))
  (to-c (fix-let-body e) f d code-out)
  (with-used-expression (e d code-out) (gen-ref (fix-let-body e) code-out)))

(dm to-c (e|<locals> f d code-out)
  (for ((binding (locals-bindings e)) (init (locals-functions e)))
    (funshell-to-c binding init #f d code-out)
    (with-statement (d code-out)
      (binding->c binding code-out)
      (puts code-out " = ") (gen-ref init code-out)))
  (do2 (rcurry funinit-to-c f d code-out) (locals-bindings e) (locals-functions e))
  (to-c (locals-body e) f d code-out)
  (with-used-expression (e d code-out) (gen-ref (locals-body e) code-out)))

(dm to-c (e|<bind-exit> f d code-out)
  (to-c (bind-exit-main-fun e) f d code-out)
  (with-expression (e d code-out)
    (puts code-out "with_exit")
    (between-parentheses (code-out) (gen-ref (bind-exit-main-fun e) code-out))))

(dm to-c (e|<unwind-protect> f d code-out)
  (to-c (unwind-protect-protected-thunk e) f d code-out)
  (to-c (unwind-protect-cleanup-thunk e) f d code-out)
  (with-expression (e d code-out)
    (puts code-out "with_cleanup")
    (between-parentheses-comma-separated (code-out)
      (gen-ref (unwind-protect-protected-thunk e) code-out)  
      (gen-ref (unwind-protect-cleanup-thunk e) code-out))))

(dm to-c (e|<monitor> f d code-out)
  (to-c (monitor-type e) f d code-out)
  (to-c (monitor-info e) f d code-out)
  (to-c (monitor-test e) f d code-out)
  (to-c (monitor-handler e) f d code-out)
  (to-c (monitor-main-thunk e) f d code-out)
  (with-expression (e d code-out)
    (puts code-out "CALLN")
    (between-parentheses-comma-separated (code-out)
      (puts code-out "1")
      (puts code-out (mangle-boot-name "%with-monitor"))
      (puts code-out "5")
      (gen-ref (monitor-type e) code-out)
      (gen-ref (monitor-info e) code-out)
      (gen-ref (monitor-test e) code-out)
      (gen-ref (monitor-handler e) code-out)
      (gen-ref (monitor-main-thunk e) code-out))))

(dm to-c (e|<predefined-application> f d code-out)
  (def binding (application-binding e))
  (if (and (application-tail? e) 
           (isa? f <ast-primitive>)
           (== binding (function-binding f)))
      (generate-self-recursive-call e f d code-out)
      (seq 
        (for ((arg (application-arguments e)))
          (to-c arg f d code-out))
        (with-expression (e d code-out)
          (format code-out "(P)%s" 
                  (mangle-module-binding (application-binding e)))
          (between-parentheses (code-out)
            (for-commas code-out ((arg (application-arguments e)))
              (gen-ref arg code-out)))))))

(dm to-c (e|<closure-creation> f d code-out)
  (def n (len (closure-creation-free e)))
  (def f (elt *definitions* (closure-creation-index e)))
  (if (== n 0)
      (with-used-expression (e d code-out)
        (generate-function-binding code-out f))
      (seq (do (fun (x) (to-c x f d code-out)) (closure-creation-free e))
           (with-expression (e d code-out)
             (puts code-out "FUNFAB")
             (between-parentheses (code-out)
               (generate-function-binding code-out f)
               (format code-out ",%d" n)
               (for ((x (closure-creation-free e)))
                 (put code-out #\,) (gen-ref x code-out)))))))

(dm funshell-to-c (b|<binding> e|<closure-creation> f d code-out)
  (def n (len (closure-creation-free e)))
  (def f (elt *definitions* (closure-creation-index e)))
  (with-expression (e d code-out)
    (if (== n 0)
        (generate-function-binding code-out f)
        ;; (format code-out "fun_%s" (closure-creation-index e))
        (seq (puts code-out "FUNSHELL")
             (between-parentheses-comma-separated (code-out)
               (format code-out "%d" (if (binding-dynamic-extent? b) 1 0))
               (generate-function-binding code-out f)
               (format code-out "%d" n))))))

(dm funinit-to-c (b|<binding> e|<closure-creation> f d code-out)
  (def n (len (closure-creation-free e)))
  (unless (== n 0)
    (do (fun (x) (to-c x f d code-out)) (closure-creation-free e))
    (with-statement (d code-out)
      (puts code-out "FUNINIT")
      (between-parentheses (code-out)
        (binding->c b code-out)
        (format code-out ", %s" n)
        (for ((x (closure-creation-free e)))
          (put code-out #\,) (gen-ref x code-out))))))

(dm to-c (e|<ast-macro-definition> f d code-out)
  (to-c (assignment-form e) #f d code-out)
  (with-expression (e d code-out)
    (puts code-out (mangle-boot-name "%macro"))
    (between-parentheses-comma-separated (code-out)
      (generate-quotation code-out (binding-module-name (assignment-binding e)))
      (generate-quotation code-out (binding-name (assignment-binding e)))
      (gen-ref (assignment-form e) code-out))))

(dm out-list-builder (f|<fun> code-out elts|<lst>)
  (if (empty? elts)
      (puts code-out (mangle-boot-name "nil"))
      (seq
        (puts code-out (mangle-boot-name "%%list"))
        (between-parentheses (code-out)
          (format code-out "%d" (len elts))
          (for ((e elts))
            (put code-out #\,)
            (f e))))))


(dm gen-fab-list (code-out refs|<fab-list>)
  (out-list-builder (fun (x) (gen-ref x code-out)) code-out refs))

(dm generate-function-specs (code-out sig)
  ;; TODO: HACK -- THIS SHOULD BE CORRECTED EARLIER
  (def types (signature-specs sig))
  (def specs (if (constant-value (signature-nary? sig))
                 (sub types 0 (- (len types) 1))
                 types))
  (gen-fab-list code-out specs))

(dm to-c (e|<ast-signature> f d code-out)
  (do (fun (x) (to-c x f d code-out)) (signature-specs e))
  (to-c (signature-value e) f d code-out)
  (with-expression (e d code-out)
    (puts code-out (mangle-boot-name "%sig"))
    (between-parentheses-comma-separated (code-out)
      (gen-fab-list code-out (signature-names e))
      (generate-function-specs code-out e)
      (gen-ref (signature-nary? e) code-out)
      (gen-ref (signature-arity e) code-out)
      (gen-ref (signature-value e) code-out)
      (puts code-out (mangle-boot-name "nil")))))

(dm to-c (e|<ast-generic> f d code-out)
  (to-c (function-signature e) f d code-out)
  (with-expression (e d code-out)
    (puts code-out (mangle-boot-name "%gen"))
    (between-parentheses-comma-separated (code-out)
      (puts code-out "(P)YPgen_code((P)YPdispatch)") ;; TODO: HACK!!!
      (gen-ref (function-debug-name e) code-out)
      (gen-ref (function-signature e) code-out)
      (puts code-out (mangle-boot-name "nil"))
      (puts code-out (mangle-boot-name "%false"))
      (puts code-out (mangle-boot-name "%false"))
      (puts code-out (mangle-boot-name "%false")))))

;;;
;;; FUNCTION DEFINITIONS

(dm generate-function-forwards (code-out definitions)
  (puts code-out "\n/* FUNCTIONS: */\n\n")
  (for ((def definitions))
    (generate-function-forward code-out def)))

(dm generate-function-forward (code-out defn|<ast-primitive>)
  (format code-out "%s P %s (" 
          (if *dynamic-linking?* "static" "extern")
	  (mangle-module-binding (function-binding defn)))
  (for-commas code-out ((i (below (len (function-bindings defn)))))
    (puts code-out "P"))
  (puts code-out ");\n"))

(dm generate-function-binding (code-out defn)
  (def name (function-binding defn))
  (if (and (isa? name <module-binding>) 
           (mem? '(global runtime) (binding-kind name)))
      (puts code-out (mangle-module-binding name))
      ;; (format-out "UNNAMED %=\n" defn)
      (if (== name #f)
          (format code-out "fun_%s" (function-index defn))
          (let ((name 
                  (if (isa? name <local-binding>) (binding-name name) name)))
            (format code-out "fun_%s_%s"
                    (mangle-raw-name name) (function-index defn))))))

(dm generate-function-forward (code-out defn)
  (def bound? (isa? (function-binding defn) <module-binding>))
  (puts code-out (if bound?  "FUNFOR(" "LOCFOR("))
  (generate-function-binding code-out defn)
  (puts code-out ");\n"))

(dm generate-function-bodies (code-out definitions)
  (puts code-out "\n/* FUNCTION CODES: */\n")
  (do (fun (def) 
	(generate-function-code code-out def))
      definitions))

(dm generate-functions (definitions f d code-out)
  (do (fun (def) 
	(unless (isa? def <ast-primitive>)
	  (generate-closure-structure def f d code-out)))
      (rev definitions)))

(dm generate-closure-structure (definition f d code-out)
  (to-c (function-signature definition) f d code-out)
  (with-expression (definition d code-out)
    (generate-function-binding code-out definition)
    (format code-out " = %s" (mangle-boot-name "%met"))
    (between-parentheses-comma-separated (code-out)
      (generate-function-body-reference code-out definition)
      (gen-ref (function-debug-name definition) code-out)
      (gen-ref (function-signature definition) code-out)
      (puts code-out "ENVNUL")
      (puts code-out "PNUL")
      (gen-ref (function-source definition) code-out))))

(dm generate-function-body-reference (code-out definition)
  (puts code-out "FUNCODEREF(")
  (generate-function-binding code-out definition)
  (puts code-out ")"))

;; TODO: RIP THIS OUT AND USE REAL PARAMETERS
;; MAKE CALL SMART AND RESTIFY IF NEC
;; WOULD LIKE TO AVOID XEP APPROACH FIRST GO ROUND

(dm generate-shadow-args (bindings code-out)
  (unless (empty? bindings)
    (with-statement (1 code-out)
      (puts code-out "P ")
      (for-commas code-out ((b bindings) (i (from 1)))
        (format code-out "a%d" i)))))

(dm generate-return (defn|<ast-primitive> d code-out)
  (with-statement (d code-out)
    (puts code-out "return ") (gen-ref (function-body defn) code-out)))

(dm generate-return (defn d code-out)
  (with-statement (d code-out)
    (when (unconstrained-type? (function-value defn))
      (put code-out #\Q))
    (puts code-out "RET")
    (between-parentheses (code-out) (gen-ref (function-body defn) code-out))))

(dm primitive-inlinable? (e|<ast-primitive>)
  (def binding (function-binding e))
  ;; TODO: ADD FUNCTION ADJECTIVES
  (mem? '(
          %tag-bits %tag %untag %class-of
          %int %ib %iu
          %chr %cb %cu
          %loc %lb %lu
          %empty? %head %tail
          @empty? @head @tail
          @== @= @+ @<
          %gen-cache-arg-pos %gen-cache-singletons
          %gen-cache-classes %gen-cache-missable?
          @oelt @oelt-setter @olen
        
          prop-value-at prop-value-at-setter
          gen-lookup gen-lookup-1-using
          )
        (binding-name binding)))

(dm generate-function-code (code-out e|<ast-primitive>)
  (format code-out "\n%s%sP " 
          (if *dynamic-linking?* "static " "")
          (if (primitive-inlinable? e) "INLINE " ""))
  (binding->c (function-binding e) code-out)
  (between-parentheses (code-out)
    (for-commas code-out ((binding (function-bindings e)))
      (puts code-out "P ") (binding->c binding code-out)))
  (puts code-out " {\n")
  (generate-local-temporaries (function-temporaries e) code-out)
  (generate-registers (function-registers e) code-out)
  (generate-shadow-args (function-bindings e) code-out)
  (puts code-out "loop:\n")
  (to-c (function-body e) e 1 code-out)
  (generate-return e 1 code-out)
  (puts code-out "}\n"))

(dm dispatcher? (definition)
  (def binding (function-binding definition))
  (and (isa? binding <module-binding>)
       (let ((name (as <str> (binding-name binding))))
         (or (= name "%dispatch") 
             (= (finds name "-dispatch") 
                (- (len name) (len "-dispatch"))))))) ;; suffix?

(dm generate-function-code (code-out definition)
  (def offset 0)
  (def bindings (function-bindings definition))
  (puts code-out "\nFUNCODEDEF(")
  (generate-function-binding code-out definition)
  (puts code-out ") {\n")
  (unless (empty? bindings)
    (with-statement (1 code-out)
      (puts code-out "P ")
      (for-commas code-out ((b (function-bindings definition)))
        (binding->c b code-out))))
    
  (generate-local-temporaries (function-temporaries definition) code-out)
  (generate-registers (function-registers definition) code-out)
  (generate-shadow-args (function-bindings definition) code-out)
  (puts code-out "LINK_STACK();\n")
  (do (fun (b)
        (when (isa? b <binding>)
          (with-statement (1 code-out)
            (if (binding-dotted? b)
                (puts code-out "NARGS(")
                (puts code-out "ARG("))
            (binding->c b code-out)
            (format code-out ", %d)" offset))
          (set offset (+ offset 1))))
      bindings)
  (puts code-out "loop:\n")
  (to-c (function-body definition) definition 1 code-out)
  
  ;; FIXME: This unless is a horrible hack! This should be fixed as part of
  ;; tail-calling stuff, although even then dispatch will be special as it
  ;; calls through with the same args it got.
  (unless (dispatcher? definition) 
    (puts code-out "UNLINK_STACK();\n"))
  (generate-return definition 1 code-out)
  (puts code-out "}\n"))

(dm generate-local-temporaries (temps code-out)
  (for ((temp temps))
    (with-statement (1 code-out)
      (puts code-out "P ") (binding->c temp code-out))))

(dv *trace-registers?* #f)

(dv *registers-per-line* 16)

(dm generate-registers (regs code-out)
  (rep next-line ((regs regs))
    (unless (empty? regs)
      (gen-depth 1 code-out) (puts code-out "P ")
      (rep next-reg ((regs regs) (i 0))
        (if (or (= i *registers-per-line*) (empty? regs))
            (seq (puts code-out ";\n") (next-line regs))
            (seq (unless (= i 0) (put code-out #\,))
                 (gen-ref (head regs) code-out)
                 (next-reg (tail regs) (+ i 1))))))))

(dm module-info-name (name)
  (cat "module_info_" (mangle-raw-name name)))

;;; Declare module info objects for each of the modules we use, and each
;;; of the modules which originally defines one of our bindings.  (There're
;;; occasionally small differences between these two sets.)
(df declare-imported-module-infos (code-out mod)
  (def seen (fab <tab> 50))
  (def env (module-target-environment mod))
  (loc ((maybe-declare (modname)
          (unless (elt-or seen modname #f)
            (set (elt seen modname) #t)
            (format code-out "extern MODULE_INFO %s;\n"
                    (module-info-name modname)))))
    (do maybe-declare (map module-name (environment-uses-modules env)))
    (do-static-global-bindings
     (fun (binding)
       (def home-mod (binding-module-name binding))
       (unless (binding-native-to? binding mod)
         (maybe-declare home-mod)))
     (module-target-environment mod))))

;;; Output a record describing this module and its environment.
;;; This routine is effectively serializing compiler data structures,
;;; so we keep it simple at the price of performance.
(df generate-module-info (code-out mod)
  (def name       (module-name mod))
  (def info-name  (module-info-name name))
  (def env        (module-target-environment mod))
  (def uses       (environment-uses-modules env))
  (def uses-names (map module-name uses))
  ;;(format out "Dumping module information...\n")
  (puts code-out "\n/* MODULE ENVIRONMENT INFORMATION */\n\n")
  (declare-imported-module-infos code-out mod)

  (puts code-out "\nstatic USE_INFO use_infos[] = {\n")
  (for ((n uses-names))
    (format code-out "  {&%s},\n" (module-info-name n)))
  (puts code-out "  {NULL}\n};\n")

  ;;(format out "Dumping imports...\n")
  (puts code-out "\nstatic IMPORT_INFO import_infos[] = {\n")
  (do-named-static-global-bindings
   (fun (local-name binding)
     (unless (binding-native-to? binding mod)
       (format code-out "  {\"%s\", &%s, \"%s\"},\n"
               (mangle-string-literal (binding-name binding))
               (module-info-name (binding-module-name binding))
               (mangle-string-literal local-name))))
   (module-target-environment mod))
  (puts code-out "  {NULL,NULL,NULL}\n};\n")

  ;;(format out "Dumping bindings...\n")
  (puts code-out "\nstatic BINDING_INFO binding_infos[] = {\n")
  (do-static-global-bindings
   (fun (binding)
     (when (binding-native-to? binding mod)
       (if (== (binding-kind binding) 'global)
           (format code-out "  {\"%s\", &%s},\n"
                   (mangle-string-literal (binding-name binding))
                   (mangle-module-binding binding))
           (format code-out "  {\"%s\", NULL},\n"
                   (mangle-string-literal (binding-name binding))))))
   (module-target-environment mod))
  (puts code-out "  {NULL, NULL}\n};\n")

  ;;(format out "Dumping exports...\n")
  (puts code-out "\nstatic EXPORT_INFO export_infos[] = {\n")
  (for (((tup exported-as binding) (module-exports mod)))
    (format code-out "  {\"%s\", \"%s\"},\n"
            (mangle-string-literal (binding-name binding))
            (mangle-string-literal exported-as)))
  (puts code-out "  {NULL, NULL}\n};\n")

  (format code-out "\nextern MODULE_INFO %s;\n" info-name)
  (format code-out "MODULE_INFO %s = {\n" info-name)
  (format code-out "  \"%s\",\n" (mangle-string-literal name))
  (puts code-out "  NULL,\n")
  (puts code-out "  use_infos,\n")
  (puts code-out "  import_infos,\n")
  (puts code-out "  binding_infos,\n")
  (puts code-out "  export_infos,\n")
  (puts code-out "};\n"))

(dm module-init-name (name)
  (cat "load_module_" (mangle-raw-name name)))

(dm module-init-decl (name)
  (cat "void " (module-init-name name) " (void)"))

(dm generate-module-init (code-out mod form)
  (def name       (if *dynamic-linking?* "dl" (module-name mod)))
  (def init-decl  (module-init-decl name))
  (def env        (module-target-environment mod))
  (def uses       (environment-uses-modules env))
  (def uses-names (map module-name uses))
  (unless *dynamic-linking?*
    (puts code-out "\n/* MODULES USED: */\n\n")
    (for ((n uses-names))
      (format code-out "extern %s;\n" (module-init-decl n))))
  (puts code-out "\n/* EXPRESSION: */\n\n")
  (format code-out "extern %s;\n\n" init-decl)
  (format code-out "%s {\n" init-decl)
  (puts code-out "  static int need_init = 1;\n")
  (puts code-out "  if (!need_init) return;\n\n")
  (puts code-out "  need_init = 0;\n")
  (unless *dynamic-linking?*
    (for ((n uses-names))
      (format code-out "  %s();\n" (module-init-name n)))
    (puts code-out "\n"))
  (to-c form #f 1 code-out)
  (puts code-out "\n")
  ;; (unless *dynamic-linking?*
  ;;   (puts code-out "  YPprint_cpu_usage(__FILE__);\n"))
  (puts code-out "}\n"))

(dm generate-main (code-out mod)
  (def name      (module-name mod))
  (def info-name (module-info-name name))
  (puts code-out "\n/* APPLICATION: */\n\n")
  (format code-out "extern MODULE_INFO %s;\n" info-name)
  (format code-out "extern %s;\n\n" (module-init-decl name))
  (format code-out "MODULE_INFO *goo_toplevel_module_info = &%s;\n\n" info-name)
  (puts code-out "int main(int argc, char* argv[]) {\n")
  (format code-out "  %s(argc, argv);\n" (mangle-boot-name "%init-world"))
  (format code-out "  %s();\n" (module-init-name name))
  (puts code-out "  return 0;\n")
  (puts code-out "}\n"))

(export
  g2c-def-app
  g2c-build-app
  g2c-top
  g2c-clean
  g2c-exp
  g2c-ast
  g2c-eval
  g2c-test)
