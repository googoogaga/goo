;;;; p2c.proto - Proto-to-C compiler
;;;; Copyright (c) 2001 Jonathan Bachrach
;;;; BASED ON Lisp In Small Pieces by Christian Queinnec
;;;;
;;;; General notes on this file:
;;;;
;;;; It is unlikely that the any format specifier other than %s should ever
;;;; be used to output C code. There is no guarantee that the proto formatted
;;;; output is equivalent to C formatted output.
;;;;
;;;; All mentions of %= have been excised, %d seems relatively harmless and
;;;; remains at the moment.

(use boot)
(use macros)
(use runtime)
(use write)
(use ast)
(use top)
(use ast-linearize)
(use strings)
(use proto/system)

(ddv *definitions*      #f)
(ddv *dynamic-linking?* #f)


;;;;=======================================================================
;;;;  Module Loading
;;;;=======================================================================
;;;;  We subclass the module loader and add our own code for locating and
;;;;  processing modules.

(dc <p2c-module-loader> (<module-loader>))
  (slot <p2c-module-loader> (module-loader-appname <str>))
  (slot <p2c-module-loader> (module-loader-app-modname <sym>))

(dc <p2c-module> (<module>))
  (slot <p2c-module> (module-src-file <str>))
  (slot <p2c-module> (module-mtime <flo>))

(dm module-loader-module-type ((loader <p2c-module-loader>) => <type>)
  <p2c-module>)

(dm load-module ((loader <p2c-module-loader>) (name <sym>) => <module>)
  (let ((mod      (fab-p2c-module loader name))
        (keepmod? #f)
        (env      (module-target-environment mod))
        (file     (module-name-to-relpath name))
        (src-file (add-src-path (proto-filename file)))
        (out-file (add-build-path (module-loader-appname loader)
                                  (c-filename file))))
    (set (module-src-file mod) src-file)
    (set (module-mtime mod) (file-mtime src-file))
    (fin
      (seq
      ;; (format out "Computing ast for %s.\n" name)
      (let ((ast      (compute-ast src-file env)))
        ;; (format out "Computing program for %s.\n" name)
        (let ((prg    (compute-program ast env)))
          ;; (format out "Generating C code for %s.\n" name)
          (probe-directory (parent-directory out-file))
          (call-with-output-file
           out-file
           (fun (out-port)
             (dlet ((*definitions* (program-definitions prg))) 
               (generate-c-module out-port ast prg mod))))
          (set keepmod? #t)
          mod)))
      ;;; Tricky unwind handler.  Our module may have altered the
      ;;; the state of other module's bindings, and so we need to
      ;;; back these changes out if we crash midway.  This would look
      ;;; much nicer if we had some kind of try/catch/rethrow construct.
      (unless keepmod?
        (free-implemented-foreign-bindings mod)))))

(df module-up-to-date? ((mod <p2c-module>) => <log>)
  (>= (module-mtime mod) (file-mtime (module-src-file mod))))

(df purge-outdated-modules ((loader <module-loader>))
  (let ((changed '()))

    ;; Figure out which modules have changed...
    (do-module-loader-modules
     (fun (mod)
       (when (not (module-up-to-date? mod))
         (pushf changed (module-name mod))))
     loader)

    ;; ...notify the user, and dump them.
    (do (fun (name) (format out "%s has changed.\n" name)) changed)
    (remove-modules-by-name! loader changed)))


;;;;=======================================================================
;;;;  Compiler Drivers
;;;;=======================================================================
;;;;  The new module-based compiler drivers.

;;; Create a module loader for the specified application.  'appname'
;;; will be used as the executable name.  'modname' will be used to
;;; recursively load all the modules which make up the application.
;;; TODO - Hide module loader inside wrapper object?
(df p2c-def-app ((appname <str>) (modname <sym>) => <p2c-module-loader>)
  (isa <p2c-module-loader>
    (set module-loader-appname appname)
    (set module-loader-app-modname modname)))

;;; Given a module loader, generate an up-to-date C program.
(df p2c-build-app ((loader <p2c-module-loader>) => #f)
  (purge-outdated-modules loader)
  (let ((mod (probe-module loader (module-loader-app-modname loader))))
    (write-string out "Searching for undefined global bindings.\n")
    (do-module-loader-modules report-undefined-global-bindings loader)
    (generate-c-application loader mod)
    (generate-makefile loader)
    #f))

(dv *tmp-file-counter* -1)

(dm p2c-exp (exp modnam)
  (let ((env      (runtime-environment modnam))
        (mod      (environment-module env))
        (name     (format-to-string 
                   "exp-%d-%d" (process-id) (inc *tmp-file-counter*)))
        (file     (add-tmp-path name))
        (out-file (c-filename file))
        (ast      (objectify exp env #f))
        (prg      (compute-program ast env)))
    (call-with-output-file
     out-file
     (fun (out-port)
       (dlet ((*dynamic-linking?* #t)
              (*definitions*      (program-definitions prg))) 
         (generate-c-module out-port ast prg mod))))
    file))

(dp %compile-load)

(dm compile-load (name)
  (%compile-load (%su name)))

(dm p2c-eval (exp modnam)
  (let ((name (p2c-exp exp modnam)))
    (compile-load name)))

;;; Backwards compatibility for users: Build p2c itself.
(dv *p2c-app* (p2c-def-app "p2c" 'main))
(dm p2c-top () (p2c-build-app *p2c-app*))
(dm p2c-clean ()
  (set *p2c-app* (p2c-def-app "p2c" 'main))
  #f)

;;; Given a file name and an environment, compute an ast in that
;;; environment.
(dm compute-ast (filename ct-env)
  (objectify (read-file filename) ct-env #f))

;;; Given an ast 'e', prepare it for compilation to C.  Store any
;;; new global bindings into the environment 'scratch-env'.
(dm compute-program (e env)
  (let ((box (insert-box! e))
	;; (format out "BOX %=\n" box)
	(dyn (analyze-dynamic-extent box))
	;; (format out "DYN %=\n" dyn)
	(cal (analyze-calls dyn))
	;; (format out "CAL %=\n" cal)
	(lft (lift! cal))
	;; (format out "LFT %=\n" lft)
        (prg (extract-things! lft))
        ;; (format out "EXT %=\n" prg)
        (flt (closurize-main! prg env 64)))
    ;; (format out "FLT %=\n" flt)
    (gather-temporaries! flt)
    ;; (format out "TMP %=\n" flt)
    (register-allocate! flt #f)
    ;; (format out "REG %=\n" flt)
    ;; (format out "\n\n%=\n\n" prg)
    prg)))

(dm generate-c-module (code-out e prg mod)
  (generate-header code-out e)
  (generate-global-environment code-out mod)
  (generate-quotation-forwards code-out (program-quotations prg))
  (generate-function-forwards code-out (program-definitions prg))
  (generate-function-bodies code-out (program-definitions prg))
  (unless *dynamic-linking?*
    (generate-module-info code-out mod))
  (generate-module-init code-out mod (program-form prg)) 
  (generate-trailer code-out)
  prg)

(dm generate-c-application ((loader <module-loader>) (mod <module>))
  (let ((appname   (module-loader-appname loader))
        (init-name (cat appname "-init")))
    (call-with-output-file
     (add-build-path appname (c-filename init-name))
     (fun (out-port)
       (generate-header out-port #f)
       (generate-main out-port mod)
       (generate-trailer out-port)))
    #f))

(dm generate-makefile ((loader <module-loader>))
  (let ((appname   (module-loader-appname loader))
        (init-name (cat appname "-init"))
        (exe-name  (exe-filename appname))
        (sep       *path-separator*))
    (call-with-output-file
     (add-build-path appname "Makefile")
     (fun (code-out)
       (format code-out "include ..%sMake.inc\n" sep)
       (format code-out "C_OBJS_DD = $(patsubst %%,..%s%%,$(C_OBJS))\n" sep)
       (format code-out "%s%s: ..%sprt.h\n" *c-extension* *obj-extension* sep)
       (format code-out "\t$(CC) -I.. -c -g -O -o $@ $<\n\n")
       (format code-out "OBJS = \\\n")
       (do-module-loader-modules
        (fun (mod)
          (format code-out "\t%s \\\n"
                  (obj-filename (module-name-to-relpath (module-name mod)))))
        loader)
       (format code-out "\t%s\n\n" (obj-filename init-name))
       (format code-out "%s: $(C_OBJS_DD) $(OBJS)\n" exe-name)
       (format code-out "\t$(CC) -Wl,--export-dynamic -o %s $(C_OBJS_DD) $(LIBS) $(OBJS)\n\n"
               exe-name sep sep)
       (format code-out "clean:\n\trm -f %s $(OBJS)\n"
               exe-name sep)))))


;;;ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
;;;              generation

;;; file header and trailer are simple.

(dm pp (e code-out)
  ;; (print e out pretty?: #t) ;; TODO: PRETTY?
  (write code-out e)) 

(dm generate-header (code-out e)
  (format code-out "/* PROTO 2 C $REVISION: 0.107 $ \n")
  ;; (when pp (pp e code-out))
  (format code-out "  */\n\n#include \"prt.h\"\n")
  (when *dynamic-linking?*
    (format code-out "#include \"dlprt.h\"\n")))

(dm generate-trailer (code-out)
  (format code-out "\n/* END OF GENERATED CODE. */\n"))

;;;ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
;;; generate global environment. for all global-bindings allocate a
;;; location to hold it. we also give the real name to the macro so
;;; that some reflective capabilities can be added to c.

;;; gb* is a list of instances of global-binding.

(dm generate-global-environment (code-out mod)
  (format code-out "\n/* MODULE ENVIRONMENT: %s */\n\n" (module-name mod))
  (do-static-global-bindings
   (fun (binding)
     (generate-global-binding code-out
                              (not (binding-native-to? binding mod))
                              binding))
   (module-target-environment mod)))

(dm generate-global-binding (code-out imported? gb)
  (let ((kind (binding-kind gb)))
    (when (or (== kind 'global) (== kind 'runtime))
      (let ((name (binding-name gb)))
        (format code-out "%s(%s,\"%s\",\"%s\");\n" 
                (if imported? "EXT" "DEF")
                (mangle-module-binding gb)
                (mangle-string-literal (binding-module-name gb))
                (mangle-string-literal name))))))

;;;; NAME MANGLING

(dv $module-separator               "Y")
(dv $local-suffix                   "_")
(dv $hygiene-marker	            "F")
(dv $escape-separator               "Z")
(dv $iep-suffix 	            "I")
(dv $method-mangled-marker-string   "M")

;; Note that the following must be characters rather than strings since
;; the initialization of mangles tables assumes that.

(dv $module-marker             (elt $module-separator 0))
(dv $local-marker              (elt $local-suffix 0))
(dv $hygiene-char              (elt $hygiene-marker 0))
(dv $escape-marker             (elt $escape-separator 0))
(dv $iep-marker                (elt $iep-suffix 0))
(dv $method-mangled-marker     (elt $method-mangled-marker-string 0))

(dv $min-character-code 0)
(dv $max-character-code 255) ;; We allow 8 bit ascii.

;;; MANGLING

(dv *mangle-buffer* (isa <buf>))

(dv $mangles-data
  (vec #(#\- #\_) #(#\! #\X) #(#\$ #\D) #(#\% #\P) #(#\* #\T) 
       #(#\/ #\S) #(#\< #\L) #(#\> #\G) #(#\? #\Q) #(#\+ #\A)
       #(#\& #\B) #(#\^ #\C) #(#\_ #\U) #(#\@ #\O) #(#\= #\E)
       #(#\~ #\N)))

(df char-buffer-as-string
    ((buffer <buf>) => <str>)
    (let (((buffer-size <int>)
           (len buffer))
          ((string <str>)
           (fab <str> buffer-size)))
      ;; without-bounds-checks
      (for (((i <int>) (from-below 0 buffer-size)))
        (set (elt string i) (elt buffer i)))
      ;; end without-bounds-checks
      string))

(dv $c-escapes
  (let ((vec (fill (fab <vec> ascii-limit) #f)))
    (set (elt vec (as <int> #\tab)) "\\t")
    (set (elt vec (as <int> #\page)) "\\f")
    (set (elt vec (as <int> #\return)) "\\r")
    (set (elt vec (as <int> #\newline)) "\\n")
    (set (elt vec (as <int> #\")) "\\\"")
    (set (elt vec (as <int> #\\)) "\\\\")
    vec))

(dm mangle-string-literal ((str <str>) => <str>)
  (set (len *mangle-buffer*) 0)
  (let ((len (len str)))
    (rep loop ((i 0))
	 (if (= i len)
	     (char-buffer-as-string *mangle-buffer*)
         (let ((c (elt str i))
               (enc (elt $c-escapes (as <int> c))))
           (if (= enc #f)
               (add! *mangle-buffer* c)
               (cat! *mangle-buffer* enc))
           (loop (+ i 1)))))))

(dm mangle-string-literal ((sym <sym>) => <str>)
  (mangle-string-literal (sym-name sym)))

(dv ($number-characters <str>) "0123456789")

(dm mangle-integer ((number <int>) => <str>)
  (rep process-integer (((number <int>) number) ((index <int>) 1))
    (let ((qr ;; (tup (quotient <int>) (remainder <int>)) ;; TODO: TUP'S 
	   (truncate/ number 10))
	  ((quotient <int>) (elt qr 0))
	  ((remainder <int>) (elt qr 1))
	  ((digit <chr>) (elt $number-characters remainder)))
      (if (= quotient 0)
	  (let (((result <str>) (fab <str> index)))
	    (set (elt result 0) digit)
	    result)
	  (let (((result <str>) (process-integer quotient (+ index 1))))
	    (set (elt result (- (len result) index)) digit)
	    result)))))

(dv $name-mangler-table
  (let ((table (fab <vec> (+ $max-character-code 1))))
    ;; fill with default manglings
    (for ((i (from-to $min-character-code $max-character-code)))
      (set (elt table i)
           (cat $escape-separator (mangle-integer i) $escape-separator)))
    ;; fill in special cases
    (for ((mangle $mangles-data))
      (set (elt table (as <int> (elt mangle 0))) (elt mangle 1)))
    ;; fill C allowable versions
    (for ((i (from-to (as <int> #\a) (as <int> #\z))))
      (set (elt table i) (as <chr> i)))
    (for ((i (from-to (as <int> #\0) (as <int> #\9))))
      (set (elt table i) (as <chr> i)))
    table))

;;; Name mangler

(df mangler-reset
    ((buffer <buf>))
  (set (len buffer) 0))

(df mangle-name-into ((buf <buf>) (name <str>))
  (for ((c name))
    (add! buf (elt $name-mangler-table (as <int> c)))))

(dm mangle-raw-name ((name <str>) => <str>)
  (mangler-reset *mangle-buffer*)
  (mangle-name-into *mangle-buffer* name)
  (char-buffer-as-string *mangle-buffer*))

(dm mangle-raw-name ((name <sym>) => <str>)
  (mangle-raw-name (as <str> name)))

(dm mangle-local-name ((name <str>) => <str>)
  (mangler-reset *mangle-buffer*)
  (mangle-name-into *mangle-buffer* name)
  (add! *mangle-buffer* $local-marker)
  (char-buffer-as-string *mangle-buffer*))

(dm mangle-local-name ((name <sym>) => <str>)
  (mangle-local-name (as <str> name)))


(dm mangle-global-name ((modname <sym>) (name <str>) => <str>)
  (mangler-reset *mangle-buffer*)
  ;; Keep internal names as short as possible.
  (unless (== modname $proto-boot-module-name)
    (add! *mangle-buffer* $module-marker)
    (mangle-name-into *mangle-buffer* (as <str> modname)))
  (add! *mangle-buffer* $module-marker)
  (mangle-name-into *mangle-buffer* name)
  (char-buffer-as-string *mangle-buffer*))

(dm mangle-global-name ((modname <sym>) (name <sym>) => <str>)
  (mangle-global-name modname (as <str> name)))

;; Mangle a name which is defined in boot.proto.
;; Be sure to provide a matching EXT declaration in prt.h.
(dm mangle-boot-name (name => <str>)
  (mangle-global-name $proto-boot-module-name name))

;; Mangle a name which is defined in runtime.proto.
;; Be sure to provide a matching EXT declaration in prt.h.
(dm mangle-runtime-name (name => <str>)
  (mangle-global-name $proto-runtime-module-name name))

(dm mangle-module-binding ((binding <module-binding>) => <str>)
  (mangle-global-name (binding-module-name binding)
		      (binding-name binding)))

(dm mangle-local-marked-name ((name <str>) (marker <int>) => <str>)
  (mangler-reset *mangle-buffer*)
  (mangle-name-into *mangle-buffer* name)
  (add! *mangle-buffer* $hygiene-char)
  (cat! *mangle-buffer* (mangle-integer marker))
  (char-buffer-as-string *mangle-buffer*))

(dm mangle-local-marked-name ((name <sym>) (marker <int>) => <str>)
  (mangle-local-marked-name (as <str> name) marker))

;;; EMISSION

(ds (for-commas ,out-val (,@clauses) ,@body)
  (let ((out-var (gensym)))
    `(let ((,out-var ,out-val))
       (for (,@clauses (first? (first-then #t #f)))
         (unless first? (write-char ,out-var #\,))
         ,@body))))

(ds (between-parentheses (,out-val) ,@body)
  (let ((out-var (gensym)))
    `(let ((,out-var ,out-val))
       (write-char ,out-var #\() ,@body (write-char ,out-var #\)))))

(ds (between-parentheses-comma-separated (,out-val) ,@body)
  (let ((out-var (gensym)))
    `(let ((,out-var ,out-val))
       (write-char ,out-var #\() 
       ,@(rep loop ((forms '()) (body body) (first? #t))
           (if (empty? body)
               (rev! forms)
               (loop (pair (head body)
                           (pair (or first? `(write-char ,out-var #\,)) forms))
                     (tail body) 
                     #f)))
       (write-char ,out-var #\)))))

(dm gen-result ((e <program>) d code-out => <log>)
  (let ((reg (program-register e)))
    (and reg (format code-out "T%d = " reg) #t)))

(dm gen-depth ((d <int>) code-out)
  (for ((i (from-below 0 d)))
    (write-string code-out "  ")))

(ds (with-statement (,d ,code-out) ,@body)
  `(seq (gen-depth ,d ,code-out)
	,@body
	(write-string ,code-out ";\n")))

(ds (with-expression (,e ,d ,code-out) ,@body)
  `(with-statement (,d ,code-out)
     (gen-result ,e ,d ,code-out)
     ,@body))

(ds (with-used-expression (,e ,d ,code-out) ,@body)
  `(when (program-register ,e)
     (with-expression (,e ,d ,code-out) ,@body)))

;;; QUOTATION EMISSION

(dm generate-quotation-forwards (code-out (qb* <col>))
  (format code-out "\n/* FORWARD QUOTATIONS: */\n\n")
  (for ((qb qb*))
    (format code-out "DEFLIT(lit_%s);\n" (binding-name qb))))

(dm generate-quotations (code-out (qb* <lst>))
  (for ((qb (rev qb*))) ;; TODO: BIP
    (with-statement (1 code-out)
      (format code-out "lit_%s = " (binding-name qb))
      (generate-quotation code-out (binding-info qb)))))

(dm false-name ()
  (mangle-boot-name "%false"))

(dm generate-quotation (code-out (qb <log>))
  (write-string code-out (mangle-boot-name (if qb "%true" "%false"))))

(dm generate-quotation (code-out (qb (t= '())))
  (write-string code-out (mangle-boot-name "nil")))

(dm generate-quotation (code-out (qb <lst>))
  (out-list-builder (fun (x) (generate-quotation code-out x)) code-out qb))

(dm generate-quotation (code-out (x <int>))
  (format code-out "%s((P)%d)" (mangle-boot-name "%int") x))

(dm generate-quotation (code-out (x <chr>))
  (format code-out "%s((P)%d)" (mangle-boot-name "%chr") (as <int> x)))

(dm float-to-c-string ((o <flo>) => <str>)
  (let ((s (num-to-str o)))
  ;;---*** Is there a better way to do this???
  (lab done
    (rep loop ((i (- (len s) 1)))
      (if (> i (neg 1)) ;; TODO: -1
	  (select (elt s i)
	    ;;---*** Should be #\f but GCC complains!
	    ((#\s) (set (elt s i) #\e) (done #f)) 
	    ((#\d) (set (elt s i) #\e) (done #f)) 
	    ;;---*** Should be #\l but GCC complains!
	    ((#\x) (set (elt s i) #\e) (done #f)) 
	    (#t    (loop (- i 1))))
	  s)))))

(dm generate-quotation (code-out (x <flo>))
  (format code-out "%s(FLOINT(%s))" 
	  (mangle-boot-name "%flo") (float-to-c-string x)))

(dm generate-quotation (code-out (x <str>))
  (format code-out "%s((P)\"%s\")"
	  (mangle-boot-name "%sb")
	  (mangle-string-literal x)))

(dm generate-quotation (code-out (x <vec>))
  ;; TODO: TIE TOGETHER
  (format code-out "CALLN(1, %s, %s" (mangle-runtime-name "vec") (len x))
  (for ((e x))
    (write-string code-out ", ")
    (generate-quotation code-out e))
  (write-string code-out ")"))

(dm generate-quotation (code-out (x <sym>))
  (format code-out "%s((P)\"%s\")"
	  (mangle-boot-name "%%sym")
	  (mangle-string-literal x)))

;;;
;;; CONVERT AN EXPRESSION TO C

;;; GENERATE THE NAME USED IN C FOR A BINDING.

(dg binding->c (binding code-out))

(dm binding->c ((binding <module-binding>) code-out)
  (if (== (binding-kind binding) 'quotation)
      (format code-out "lit_%s" (binding-name binding))
      (write-string code-out (mangle-module-binding binding))))

(dm binding->c ((binding <local-binding>) code-out)
  (write-string code-out (mangle-local-name (binding-name binding))))

;; TODO: USE MANGLER FOR THIS
(dm binding->c ((binding <renamed-local-binding>) code-out)
  (write-string code-out
    (mangle-local-marked-name 
     (binding-name binding) (binding-index binding))))

;;; WORKS FOR LOCAL- GLOBAL- PREDEFINED- REFERENCES EXCEPT FOR FREE-REFERENCES.

(dg reference->c ((v <binding>) code-out))

(dm reference->c ((v <binding>) code-out)
  (binding->c v code-out))

(dm reference->c ((v <module-binding>) code-out)
  (write-string 
   code-out (if (== (binding-kind v) 'quotation) "LITREF" "VARREF"))
  (between-parentheses (code-out)
    (binding->c v code-out)))

(dg to-c ((e <program>) f d code-out))

(dm to-c ((e <top-level-form>) f d code-out)
  (generate-quotations code-out (form-quotations e))
  (generate-functions (form-definitions e) f d code-out)
  (to-c (form-program e) f d code-out)
  (with-used-expression (e d code-out) (gen-ref (form-program e) code-out)))

(dm to-c ((e <passive-program>) f d code-out))

(dm gen-ref ((e <reference>) code-out)
  (reference->c (reference-binding e) code-out))

(dm gen-ref ((e <free-reference>) code-out)
  (write-string code-out "FREEREF")
  (between-parentheses (code-out)
    (format code-out "%d" (reference-offset e))))

(dm gen-ref ((e <program>) code-out)
  (let ((reg (program-register e)))
    (if reg (format code-out "T%d" reg) (write-string code-out "T_1"))))

(dm gen-ref ((e <raw-constant>) code-out)
  (format code-out "(P)%s" (constant-value e)))

(dm gen-ref ((e <constant>) code-out)
  (generate-quotation code-out (constant-value e)))

(dm gen-ref ((e <sequential>) code-out)
  (gen-ref (last e) code-out))

(dm to-c ((e <global-assignment>) f d code-out)
  (to-c (assignment-form e) f d code-out)
  (with-expression (e d code-out)
    (write-string code-out "VARSET(")
    (binding->c (assignment-binding e) code-out)
    (write-string code-out ",") 
    (gen-ref (assignment-form e) code-out)
    (write-string code-out ")")))

(dm to-c ((e <bound?>) f d code-out)
  (with-used-expression (e d code-out)
    (write-string code-out "BOUNDP")
    (between-parentheses (code-out)
      (binding->c (reference-binding (bound?-reference e)) code-out))))

;; TODO: DOES REF NEED TO BE TO-C'D

(dm to-c ((e <box-read>) f d code-out)
  (to-c (box-reference e) f d code-out)
  (with-used-expression (e d code-out)
    (write-string code-out "BOXVAL")
    (between-parentheses (code-out) 
      (gen-ref (box-reference e) code-out))))

(dm to-c ((e <box-write>) f d code-out)
  (to-c (box-form e) f d code-out)
  (with-expression (e d code-out)
    (write-string code-out "BOXVAL")
    (between-parentheses (code-out) 
      (gen-ref (box-reference e) code-out))
    (write-string code-out " = ") (gen-ref (box-form e) code-out)))

(dm to-c ((e <box-creation>) f d code-out)
  (with-expression (e d code-out)
    (let ((binding (reference-binding (box-reference (box-reference e)))))
      (binding->c binding code-out)
      (write-string code-out " = BOXFAB")
      (between-parentheses (code-out) (binding->c binding code-out)))))

(dm to-c ((e <alternative>) f d code-out)
  (to-c (alternative-condition e) f d code-out)
  (gen-depth d code-out)
  (write-string code-out "if (") (gen-ref (alternative-condition e) code-out)
  (format code-out " != %s) {\n" (false-name))
  (to-c (alternative-consequent e) f (+ d 1) code-out)
  (with-used-expression (e (+ d 1) code-out)
    (gen-ref (alternative-consequent e) code-out))
  (gen-depth d code-out) (write-string code-out "} else {\n")
  (to-c (alternative-alternant e) f (+ d 1) code-out)
  (with-used-expression (e (+ d 1) code-out)
    (gen-ref (alternative-alternant e) code-out))
  (gen-depth d code-out) (write-string code-out "}\n"))

(dm to-c ((e <sequential>) f d code-out)
  (do (fun (x) (to-c x f d code-out)) e))

(dm generate-self-recursive-call ((e <application>) f d code-out)
  (for ((arg (application-arguments e)))
    (to-c arg f d code-out))
  (for ((arg (application-arguments e)) (i (from 1)))
    (with-statement (d code-out)
      (format code-out "a%d = " i)
      (gen-ref arg code-out)))
  (for ((binding (function-bindings f)) (i (from 1)))
    (with-statement (d code-out)
      (binding->c binding code-out)
      (format code-out " = a%d" i)))
  (with-statement (d code-out)
    (write-string code-out "goto loop")))

(dv $number-call-templates 3)

(dm to-c ((e <regular-application>) f d code-out)
  (let ((function (application-function e)))
    (if (and (application-tail? e) 
	     (isa? f <ast-method>)
	     (not (function-nary? f))
	     (isa? function <free-reference>)
	     (reference-self? function))
	(generate-self-recursive-call e f d code-out)
	(let ((n (len (application-arguments e))))
          (to-c (application-function e) f d code-out)
          (for ((arg (application-arguments e)))
            (to-c arg f d code-out))
          (with-expression (e d code-out)
            (format code-out "CALL%s" 
                    (if (> n $number-call-templates) "N" n))
            (between-parentheses (code-out)
              (write-string code-out (if (application-known? e) "0," "1,") )
              (gen-ref (application-function e) code-out)
              (when (> n $number-call-templates) (format code-out ",%s" n))
              (for ((arg (application-arguments e)))
                (write-char code-out #\,) (gen-ref arg code-out))))))))

(dm to-c ((e <arguments>) f d code-out)
  (for-commas code-out ((x e))
    (gen-ref x code-out)))

(dm to-c ((e <fix-let>) f d code-out)
  (for-commas code-out ((binding (fix-let-bindings e)) (type (fix-let-types e))
                   (init (fix-let-arguments e)))
    (to-c init #f d code-out)
    (unless (unconstrained-type? type)
      (to-c type #f d code-out)
      (with-statement (d code-out)
        (write-string code-out "check_type")
        (between-parentheses-comma-separated (code-out)
          (gen-ref init code-out) (gen-ref type code-out))))
    (with-statement (d code-out)
      (binding->c binding code-out)
      (write-string code-out " = ") (gen-ref init code-out)))
  (to-c (fix-let-body e) f d code-out)
  (with-used-expression (e d code-out) (gen-ref (fix-let-body e) code-out)))

(dm to-c ((e <locals>) f d code-out)
  (for ((binding (locals-bindings e)) (init (locals-functions e)))
    (funshell-to-c binding init #f d code-out)
    (with-statement (d code-out)
      (binding->c binding code-out)
      (write-string code-out " = ") (gen-ref init code-out)))
  (do2 (rcurry funinit-to-c f d code-out) (locals-bindings e) (locals-functions e))
  (to-c (locals-body e) f d code-out)
  (with-used-expression (e d code-out) (gen-ref (locals-body e) code-out)))

(dm to-c ((e <bind-exit>) f d code-out)
  (to-c (bind-exit-main-fun e) f d code-out)
  (with-expression (e d code-out)
    (write-string code-out "with_exit")
    (between-parentheses (code-out) (gen-ref (bind-exit-main-fun e) code-out))))

(dm to-c ((e <unwind-protect>) f d code-out)
  (to-c (unwind-protect-protected-thunk e) f d code-out)
  (to-c (unwind-protect-cleanup-thunk e) f d code-out)
  (with-expression (e d code-out)
    (write-string code-out "with_cleanup")
    (between-parentheses-comma-separated (code-out)
      (gen-ref (unwind-protect-protected-thunk e) code-out)  
      (gen-ref (unwind-protect-cleanup-thunk e) code-out))))

(dm to-c ((e <monitor>) f d code-out)
  (to-c (monitor-type e) f d code-out)
  (to-c (monitor-info e) f d code-out)
  (to-c (monitor-test e) f d code-out)
  (to-c (monitor-handler e) f d code-out)
  (to-c (monitor-main-thunk e) f d code-out)
  (with-expression (e d code-out)
    (write-string code-out "CALLN")
    (between-parentheses-comma-separated (code-out)
      (write-string code-out "1")
      (write-string code-out (mangle-runtime-name "%with-monitor"))
      (write-string code-out "5")
      (gen-ref (monitor-type e) code-out)
      (gen-ref (monitor-info e) code-out)
      (gen-ref (monitor-test e) code-out)
      (gen-ref (monitor-handler e) code-out)
      (gen-ref (monitor-main-thunk e) code-out))))

(dm to-c ((e <predefined-application>) f d code-out)
  (let ((binding (application-binding e)))
    (if (and (application-tail? e) 
	     (isa? f <ast-primitive>)
	     (== binding (function-binding f)))
	(generate-self-recursive-call e f d code-out)
        (seq 
          (for ((arg (application-arguments e)))
            (to-c arg f d code-out))
          (with-expression (e d code-out)
            (format code-out "(P)%s" 
                    (mangle-module-binding (application-binding e)))
            (between-parentheses (code-out)
              (for-commas code-out ((arg (application-arguments e)))
                (gen-ref arg code-out))))))))

(dm to-c ((e <closure-creation>) f d code-out)
  (let ((n (len (closure-creation-free e)))
        (f (elt *definitions* (closure-creation-index e))))
    (if (== n 0)
        (with-used-expression (e d code-out)
          (generate-function-binding code-out f))
        (seq (do (fun (x) (to-c x f d code-out)) (closure-creation-free e))
             (with-expression (e d code-out)
               (write-string code-out "FUNFAB")
               (between-parentheses (code-out)
                 (generate-function-binding code-out f)
                 (format code-out ",%d" n)
                 (for ((x (closure-creation-free e)))
                   (write-char code-out #\,) (gen-ref x code-out))))))))

(dm funshell-to-c ((b <binding>) (e <closure-creation>) f d code-out)
  (let ((n (len (closure-creation-free e)))
	(f (elt *definitions* (closure-creation-index e))))
    (with-expression (e d code-out)
      (if (== n 0)
          (generate-function-binding code-out f)
          ;; (format code-out "fun_%s" (closure-creation-index e))
	  (seq (write-string code-out "FUNSHELL")
	       (between-parentheses-comma-separated (code-out)
		 (format code-out "%d" (if (binding-dynamic-extent? b) 1 0))
		 (generate-function-binding code-out f)
		 (format code-out "%d" n)))))))

(dm funinit-to-c ((b <binding>) (e <closure-creation>) f d code-out)
  (let ((n (len (closure-creation-free e))))
    (unless (== n 0)
      (do (fun (x) (to-c x f d code-out)) (closure-creation-free e))
      (with-statement (d code-out)
      	(write-string code-out "FUNINIT")
	(between-parentheses (code-out)
	  (binding->c b code-out)
	  (format code-out ", %s" n)
          (for ((x (closure-creation-free e)))
            (write-char code-out #\,) (gen-ref x code-out)))))))

(dm to-c ((e <ast-macro-definition>) f d code-out)
  (to-c (assignment-form e) #f d code-out)
  (with-expression (e d code-out)
    (write-string code-out (mangle-boot-name "%macro"))
    (between-parentheses-comma-separated (code-out)
      (generate-quotation code-out (binding-module-name (assignment-binding e)))
      (generate-quotation code-out (binding-name (assignment-binding e)))
      (gen-ref (assignment-form e) code-out))))

(dm out-list-builder ((f <fun>) code-out (elts <lst>))
  (if (empty? elts)
      (write-string code-out (mangle-boot-name "nil"))
      (seq
        (write-string code-out (mangle-boot-name "%%list"))
        (between-parentheses (code-out)
          (format code-out "%d" (len elts))
          (for ((e elts))
            (write-char code-out #\,)
            (f e))))))


(dm gen-fab-list (code-out (refs <fab-list>))
  (out-list-builder (fun (x) (gen-ref x code-out)) code-out refs))

(dm generate-function-specs (code-out sig)
  ;; TODO: HACK -- THIS SHOULD BE CORRECTED EARLIER
  (let ((types (signature-specs sig))
        (specs (if (constant-value (signature-nary? sig))
		   (sub types 0 (- (len types) 1))
		   types)))
    (gen-fab-list code-out specs)))

(dm to-c ((e <ast-signature>) f d code-out)
  (do (fun (x) (to-c x f d code-out)) (signature-specs e))
  (to-c (signature-value e) f d code-out)
  (with-expression (e d code-out)
    (write-string code-out (mangle-boot-name "%sig"))
    (between-parentheses-comma-separated (code-out)
      (gen-fab-list code-out (signature-names e))
      (generate-function-specs code-out e)
      (gen-ref (signature-nary? e) code-out)
      (gen-ref (signature-arity e) code-out)
      (gen-ref (signature-value e) code-out)
      (write-string code-out (mangle-boot-name "nil")))))

(dm to-c ((e <ast-generic>) f d code-out)
  (to-c (function-signature e) f d code-out)
  (with-expression (e d code-out)
    (write-string code-out (mangle-boot-name "%gen"))
    (between-parentheses-comma-separated (code-out)
      (write-string code-out "(P)YPgen_code((P)CHKREF(YPdispatch))") ;; TODO: HACK!!!
      (gen-ref (function-debug-name e) code-out)
      (gen-ref (function-signature e) code-out)
      (write-string code-out (mangle-boot-name "nil"))
      (write-string code-out (mangle-boot-name "%false")))))

;;;
;;; FUNCTION DEFINITIONS

(dm generate-function-forwards (code-out definitions)
  (write-string code-out "\n/* FUNCTIONS: */\n\n")
  (for ((def definitions))
    (generate-function-forward code-out def)))

(dm generate-function-forward (code-out (defn <ast-primitive>))
  (format code-out "%s P %s (" 
          (if *dynamic-linking?* "static" "extern")
	  (mangle-module-binding (function-binding defn)))
  (for-commas code-out ((i (from-below 0 (len (function-bindings defn)))))
    (write-string code-out "P"))
  (write-string code-out ");\n"))

(dm generate-function-binding (code-out defn)
  (let ((name (function-binding defn)))
    (if (and (isa? name <module-binding>) 
             (mem? '(global runtime) (binding-kind name)))
	(write-string code-out (mangle-module-binding name))
	;; (format-out "UNNAMED %=\n" defn)
	(if (== name #f)
	    (format code-out "fun_%s" (function-index defn))
	    (let ((name 
		   (if (isa? name <local-binding>) (binding-name name) name)))
	      (format code-out "fun_%s_%s"
		      (mangle-raw-name name) (function-index defn)))))))

(dm generate-function-forward (code-out defn)
  (let ((bound? (isa? (function-binding defn) <module-binding>)))
    (write-string code-out (if bound?  "FUNFOR(" "LOCFOR("))
    (generate-function-binding code-out defn)
    (write-string code-out ");\n")))

(dm generate-function-bodies (code-out definitions)
  (write-string code-out "\n/* FUNCTION CODES: */\n")
  (do (fun (def) 
	(generate-function-code code-out def))
      definitions))

(dm generate-functions (definitions f d code-out)
  (do (fun (def) 
	(unless (isa? def <ast-primitive>)
	  (generate-closure-structure def f d code-out)))
      (rev definitions)))

(dm generate-closure-structure (definition f d code-out)
  (to-c (function-signature definition) f d code-out)
  (with-expression (definition d code-out)
    (generate-function-binding code-out definition)
    (format code-out " = %s" (mangle-boot-name "%met"))
    (between-parentheses-comma-separated (code-out)
      (generate-function-body-reference code-out definition)
      (gen-ref (function-debug-name definition) code-out)
      (gen-ref (function-signature definition) code-out)
      (write-string code-out "ENVNUL")
      (write-string code-out "PNUL")
      (gen-ref (function-source definition) code-out))))

(dm generate-function-body-reference (code-out definition)
  (write-string code-out "FUNCODEREF(")
  (generate-function-binding code-out definition)
  (write-string code-out ")"))

;; TODO: RIP THIS OUT AND USE REAL PARAMETERS
;; MAKE CALL SMART AND RESTIFY IF NEC
;; WOULD LIKE TO AVOID XEP APPROACH FIRST GO ROUND

(dm generate-shadow-args (bindings code-out)
  (unless (empty? bindings)
    (with-statement (1 code-out)
      (write-string code-out "P ")
      (for-commas code-out ((b bindings) (i (from 1)))
        (format code-out "a%d" i)))))

(dm generate-return ((defn <ast-primitive>) d code-out)
  (with-statement (d code-out)
    (write-string code-out "return ") (gen-ref (function-body defn) code-out)))

(dm generate-return (defn d code-out)
  (with-statement (d code-out)
    (when (unconstrained-type? (function-value defn))
      (write-char code-out #\Q))
    (write-string code-out "RET")
    (between-parentheses (code-out) (gen-ref (function-body defn) code-out))))

(dm primitive-inlinable? ((e <ast-primitive>))
  (let ((binding (function-binding e)))
    ;; TODO: ADD FUNCTION ADJECTIVES
    (mem? '(
        %tag-bits %tag %untag %class-of
	    %int %ib %iu
	    %chr %cb %cu
	    %loc %lb %lu
	    %empty? %head %tail
        @empty? @head @tail
	    @== @= @+ @<
        %gen-cache-arg-pos %gen-cache-singletons
        %gen-cache-classes %gen-cache-missable?
        @oelt @oelt-setter @olen
        
	    slot-value-at slot-value-at-setter
	    gen-lookup gen-lookup-1-using
	    )
 	   (binding-name binding))))

(dm generate-function-code (code-out (e <ast-primitive>))
  (format code-out "\n%s%sP " 
          (if *dynamic-linking?* "static " "")
          (if (primitive-inlinable? e) "INLINE " ""))
  (binding->c (function-binding e) code-out)
  (between-parentheses (code-out)
    (for-commas code-out ((binding (function-bindings e)))
      (write-string code-out "P ") (binding->c binding code-out)))
  (write-string code-out " {\n")
  (generate-local-temporaries (function-temporaries e) code-out)
  (generate-registers (function-registers e) code-out)
  (generate-shadow-args (function-bindings e) code-out)
  (write-string code-out "loop:\n")
  (to-c (function-body e) e 1 code-out)
  (generate-return e 1 code-out)
  (write-string code-out "}\n"))

(dm generate-function-code (code-out definition)
  (let ((offset 0)
        (bindings (function-bindings definition)))
    (write-string code-out "\nFUNCODEDEF(")
    (generate-function-binding code-out definition)
    (write-string code-out ") {\n")
    (unless (empty? bindings)
      (with-statement (1 code-out)
        (write-string code-out "P ")
        (for-commas code-out ((b (function-bindings definition)))
          (binding->c b code-out))))
    
    (generate-local-temporaries (function-temporaries definition) code-out)
    (generate-registers (function-registers definition) code-out)
    (generate-shadow-args (function-bindings definition) code-out)
    (write-string code-out "LINK_STACK();\n")
    (do (fun (b)
          (when (isa? b <binding>)
            (with-statement (1 code-out)
              (if (binding-dotted? b)
                  (write-string code-out "NARGS(")
                  (write-string code-out "ARG("))
              (binding->c b code-out)
              (format code-out ", %d)" offset))
            (set offset (+ offset 1))))
        bindings))
  (write-string code-out "loop:\n")
  (to-c (function-body definition) definition 1 code-out)
  
  ;; FIXME: This unless is a horrible hack! This should be fixed as part of
  ;; tail-calling stuff, although even then dispatch will be special as it
  ;; calls through with the same args it got.
  (unless (and (isa? (function-binding definition) <module-binding>)
               (== (binding-name (function-binding definition)) '%dispatch))
    (write-string code-out "UNLINK_STACK();\n"))
  (generate-return definition 1 code-out)
  (write-string code-out "}\n"))

(dm generate-local-temporaries (temps code-out)
  (for ((temp temps))
    (with-statement (1 code-out)
      (write-string code-out "P ") (binding->c temp code-out))))

(dv *trace-registers?* #f)

(dv *registers-per-line* 16)

(dm generate-registers (regs code-out)
  (rep next-line ((regs regs))
    (unless (empty? regs)
      (gen-depth 1 code-out) (write-string code-out "P ")
      (rep next-reg ((regs regs) (i 0))
        (if (or (= i *registers-per-line*) (empty? regs))
            (seq (write-string code-out ";\n") (next-line regs))
            (seq (unless (= i 0) (write-char code-out #\,))
                 (gen-ref (head regs) code-out)
                 (next-reg (tail regs) (+ i 1))))))))

(dm module-info-name (name)
  (cat "module_info_" (mangle-raw-name name)))

;;; Declare module info objects for each of the modules we use, and each
;;; of the modules which originally defines one of our bindings.  (There're
;;; occasionally small differences between these two sets.)
(df declare-imported-module-infos (code-out mod)
  (let ((seen (fab <tab> 50))
        (env (module-target-environment mod)))
    (loc ((maybe-declare (modname)
            (when (nul? (elt seen modname))
              (set (elt seen modname) #t)
              (format code-out "extern MODULE_INFO %s;\n"
                      (module-info-name modname)))))
      (do maybe-declare (map module-name (environment-uses-modules env)))
      (do-static-global-bindings
       (fun (binding)
         (let ((home-mod (binding-module-name binding)))
           (unless (binding-native-to? binding mod)
             (maybe-declare home-mod))))
       (module-target-environment mod)))))

;;; Output a record describing this module and its environment.
;;; This routine is effectively serializing compiler data structures,
;;; so we keep it simple at the price of performance.
(df generate-module-info (code-out mod)
  (let ((name       (module-name mod))
        (info-name  (module-info-name name))
        (env        (module-target-environment mod))
        (uses       (environment-uses-modules env))
        (uses-names (map module-name uses)))
    ;;(format out "Dumping module information...\n")
    (write-string code-out "\n/* MODULE ENVIRONMENT INFORMATION */\n\n")
    (declare-imported-module-infos code-out mod)

    (write-string code-out "\nstatic USE_INFO use_infos[] = {\n")
    (for ((n uses-names))
      (format code-out "  {&%s},\n" (module-info-name n)))
    (write-string code-out "  {NULL}\n};\n")

    ;;(format out "Dumping imports...\n")
    (write-string code-out "\nstatic IMPORT_INFO import_infos[] = {\n")
    (do-named-static-global-bindings
     (fun (local-name binding)
       (unless (binding-native-to? binding mod)
         (format code-out "  {\"%s\", &%s, \"%s\"},\n"
                 (mangle-string-literal (binding-name binding))
                 (module-info-name (binding-module-name binding))
                 (mangle-string-literal local-name))))
     (module-target-environment mod))
    (write-string code-out "  {NULL,NULL,NULL}\n};\n")

    ;;(format out "Dumping bindings...\n")
    (write-string code-out "\nstatic BINDING_INFO binding_infos[] = {\n")
    (do-static-global-bindings
     (fun (binding)
       (when (binding-native-to? binding mod)
         (if (== (binding-kind binding) 'global)
             (format code-out "  {\"%s\", &%s},\n"
                     (mangle-string-literal (binding-name binding))
                     (mangle-module-binding binding))
             (format code-out "  {\"%s\", NULL},\n"
                     (mangle-string-literal (binding-name binding))))))
     (module-target-environment mod))
    (write-string code-out "  {NULL, NULL}\n};\n")

    ;;(format out "Dumping exports...\n")
    (write-string code-out "\nstatic EXPORT_INFO export_infos[] = {\n")
    (for (((tup exported-as binding) (module-exports mod)))
      (format code-out "  {\"%s\", \"%s\"},\n"
              (mangle-string-literal (binding-name binding))
              (mangle-string-literal exported-as)))
    (write-string code-out "  {NULL, NULL}\n};\n")

    (format code-out "\nextern MODULE_INFO %s;\n" info-name)
    (format code-out "MODULE_INFO %s = {\n" info-name)
    (format code-out "  \"%s\",\n" (mangle-string-literal name))
    (write-string code-out "  NULL,\n")
    (write-string code-out "  use_infos,\n")
    (write-string code-out "  import_infos,\n")
    (write-string code-out "  binding_infos,\n")
    (write-string code-out "  export_infos,\n")
    (write-string code-out "};\n")))

(dm module-init-name (name)
  (cat "load_module_" (mangle-raw-name name)))

(dm module-init-decl (name)
  (cat "void " (module-init-name name) " (void)"))

(dm generate-module-init (code-out mod form)
  (let ((name       (if *dynamic-linking?* "dl" (module-name mod)))
        (init-decl  (module-init-decl name))
        (env        (module-target-environment mod))
        (uses       (environment-uses-modules env))
        (uses-names (map module-name uses)))
    (unless *dynamic-linking?*
      (write-string code-out "\n/* MODULES USED: */\n\n")
      (for ((n uses-names))
        (format code-out "extern %s;\n" (module-init-decl n))))
    (write-string code-out "\n/* EXPRESSION: */\n\n")
    (format code-out "extern %s;\n\n" init-decl)
    (format code-out "%s {\n" init-decl)
    (write-string code-out "  static int need_init = 1;\n")
    (write-string code-out "  if (!need_init) return;\n\n")
    (write-string code-out "  need_init = 0;\n")
    (unless *dynamic-linking?*
      (for ((n uses-names))
        (format code-out "  %s();\n" (module-init-name n)))
      (write-string code-out "\n"))
    (to-c form #f 1 code-out)
    (write-string code-out "\n")
    (unless *dynamic-linking?*
      (write-string code-out "  YPprint_cpu_usage(__FILE__);\n"))
    (write-string code-out "}\n")))

(dm generate-main (code-out mod)
  (let ((name (module-name mod))
        (info-name (module-info-name name)))
    (write-string code-out "\n/* APPLICATION: */\n\n")
    (format code-out "extern MODULE_INFO %s;\n" info-name)
    (format code-out "extern %s;\n\n" (module-init-decl name))
    (format code-out "MODULE_INFO *proto_toplevel_module_info = &%s;\n\n" info-name)
    (write-string code-out "int main(int argc, char* argv[]) {\n")
    (format code-out "  %s(argc, argv);\n" (mangle-boot-name "%init-world"))
    (format code-out "  %s();\n" (module-init-name name))
    (write-string code-out "  return 0;\n")
    (write-string code-out "}\n")
    ))

(export
  p2c-def-app
  p2c-build-app
  p2c-top
  p2c-clean
  p2c-exp
  p2c-eval)
