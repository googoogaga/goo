;;;; Copyright (c) 2001 Jonathan Bachrach
;;;; BASED ON Lisp In Small Pieces by Christian Queinnec
;;;; with many many changes

(use goo/boot)
(use goo/macros)
(use goo/packer)
(use goo/runtime)
(use goo/io/write)
(use eval/syntax)
(use goo/cols/str)
(use goo/system) ; Needed by runtime module loader.
(use goo/io/write)
(use goo/types)
(use goo/math)
(use goo/cols)
(use goo/io/port)
(use eval/dependency)

;;; TODO: MOVE TYPE OUT OF SIGNATURE

;;; The name of the module which contains all of goo's primitives,
;;; magic bindings, and core code.
(dv $goo-boot-module-name    'goo/boot)

;;; The <dependent> object we're currently compiling.  Any dependencies we
;;; encounter will automatically be assumed to be the resposibility of this
;;; object.
(dv *current-dependent* #f)
(ds (with-dependent ,dependent ,@body)
  (let ((saved-dependent (gensym)))
    `(let ((,saved-dependent *current-dependent*))
       (set *current-dependent* ,dependent)
       (fin
         (seq ,@body)
         (set *current-dependent* ,saved-dependent)))))

(dm objectify-error (message|<str> arguments|...)
  (app error message arguments))

;;; programs

(dv ast-<bot> (lst 'bot))

(dc <program> (<any>))
  (dp program-type (x|<program> => <any>))
  (dp program-register (x|<program> => <any>) #f) ;; TODO: T? INT

(dc <computed-program> (<program>))
  (dp program-register (x|<computed-program> => <any>) #f) ;; TODO: T? INT

(dc <passive-program> (<program>))

;;; bindings are not programs! they represent bindings.

(dv <binding-name> <any>) ;; (type-union <sym> <int>)

(dc <binding> (<any>))
  (dp binding-name (x|<binding> => <binding-name>))
  (dp binding-type (x|<binding> => <program>))
  (dp binding-inferred-type (x|<binding> => <any>) ast-<bot>)

;; Global boxes are used by the interpreter to store the values of
;; global variables.
(dc <global-box> (<any>))
  (dp global-box-value (x|<global-box> => <any>) nul)

(dc <module-binding> (<binding> <dependable>))
  ;; The name of the module in which this binding is defined.
  (dp binding-kind (x|<module-binding> => <any>) 'global)
  (dp binding-module-name (x|<module-binding> => <sym>))
  (dp binding-free? (x|<module-binding> => <log>) #f)
  (dp binding-info (x|<module-binding> => <any>)  #f)

;; TODO: GET RID OF ALIASES OR MAKE SEPARATE INFO OBJECT

(dv binding-global-box        binding-info)
(dv binding-global-box-setter binding-info-setter)
(dv binding-locative          binding-info)
(dv binding-locative-setter   binding-info-setter)
(dv binding-handler           binding-info)
(dv binding-handler-setter    binding-info-setter)

(df maybe-log-dependency (dependable|<dependable> dtype|<dependency-type>)
  (when *current-dependent*
    (log-dependency dependable *current-dependent* dtype)
    (transaction-register-dependent *current-dependent*)))

(df macro-expander (macro-binding|<module-binding> => <fun>)
  (maybe-log-dependency macro-binding $expansion-parse-dependency)
  (binding-handler macro-binding))

(dc <local-binding> (<binding>))
  (dp binding-value (x|<local-binding> => <any>)           #f)
  (dp binding-mutable? (x|<local-binding> => <any>)        #f)
  (dp binding-dynamic-extent? (x|<local-binding> => <any>) #t)
  (dp binding-dotted? (x|<local-binding> => <any>)         #f)
  (dp binding-index (x|<local-binding> => <any>)           #f)

;; (dc <next-methods-binding> (<binding>))

;;; compile-time

(dc <compile-time> (<computed-program>))
  (dp compile-time-program (x|<compile-time> => <any>))

;;; references are programs.

(dc <reference> (<passive-program>))

;;; special category of bindings

;; DEAL WITH INITIALIZE

(dc <real-reference> (<reference>))
  (dp reference-binding (x|<real-reference> => <any>))

(dc <local-reference> (<real-reference>))
  (dp reference-called-function? (x|<local-reference> => <any>) #f)
  (dp reference-frame-number (x|<local-reference> => <int>))
  (dp reference-frame-offset (x|<local-reference> => <int>))

;; (dc <next-methods-reference> (<real-reference>))

(dc <module-binding-reference> (<real-reference>))

(dc <global-reference> (<module-binding-reference>))

(dc <runtime-reference> (<module-binding-reference>))

(dc <predefined-reference> (<real-reference>))

(dc <bound?> (<computed-program>))
  (dp bound?-reference (x|<bound?> => <any>))

(dc <assignment> (<computed-program>))
  (dp assignment-form (x|<assignment> => <any>))

(dc <local-assignment> (<assignment>))
  (dp assignment-reference (x|<local-assignment> => <any>))

(dc <global-assignment> (<assignment>))
  (dp assignment-binding (x|<global-assignment> => <any>))

(dc <runtime-assignment> (<global-assignment>))

(dc <definition> (<global-assignment>))

;;; TODO: THE FOLLOWING DEFS AREN'T REALLY USED -- PERHAPS ZAP

(dc <variable-definition> (<definition>))

(dc <ast-generic-definition> (<definition>))

(dc <ast-function-definition> (<definition>))

(dc <ast-method-definition> (<definition>))

(dc <ast-primitive-definition> (<definition>))

(dc <ast-macro-definition> (<definition>))

(dc <ast-signature> (<computed-program>))
  (dp signature-bindings (x|<ast-signature> => <any>) '())
  (dp signature-names (x|<ast-signature> => <any>)    '())
  (dp signature-specs (x|<ast-signature> => <any>)    '())
  (dp signature-nary? (x|<ast-signature> => <any>)    #f)
  (dp signature-arity (x|<ast-signature> => <any>)    #f)
  (dp signature-value (x|<ast-signature> => <any>)    #f)

(dc <ast-function> (<computed-program> <dependent>))
  (dp function-binding (x|<ast-function> => <any>)    #f)
  (dp function-debug-name (x|<ast-function> => <any>) #f)
  ;;  (dp function-next-methods-binding (x|<ast-function> => <any>))
  (dp function-signature (x|<ast-function> => <any>))

(df function-bindings (x|<ast-function>) 
  (signature-bindings (function-signature x)))
(df function-specs (x|<ast-function>) 
  (signature-specs (function-signature x)))
(df function-nary? (x|<ast-function>)
  (constant-value (signature-nary? (function-signature x))))
(df function-value (x|<ast-function>)
  (signature-value (function-signature x)))

(dm function-kind (x|<ast-function>) "FUN")

(df function-display-name (f|<ast-function>)
  (def b (function-binding f))
  (if b
      (msg-to-str "%s:%s" (binding-module-name b) (binding-name b))
      "anonymous function"))

(dm invalidate-dependent (dependent|<ast-function>
                          dependable|<dependable>
                          dtype|<dependency-type>)
  ;; Aggressively detach ourselves.  We'll eventually want
  ;; to selectively detach ourselves.
  (detach-dependent dependent)
  (def name (function-display-name dependent))
  (cond
    ((dependency-includes-any? dtype $parse-dependencies)
     (msg out "warning: %s needs to be reparsed\n" name))
    ((dependency-includes-any? dtype $optimizaton-dependencies)
     (msg out "warning: %s needs to be re-optimized\n" name))
    (#t
     (msg out "warning: unknown dependency of %s clobbered\n" name))))

(dc <programs> (<passive-program>))

(dm as-lst (e|<programs> => <lst>)
  (rep loop ((res '()) (e e))
    (if (empty? e) (rev! res) (loop (pair (head e) res) (tail e)))))

;; (ct (dv cat-sym make-sym))
(ds (def-list ,name (,@supers))
  (let ((class  (cat-sym "<" name ">"))
        ($empty (cat-sym "$" name "-empty")))
    `(seq (dc ,class (<lst> ,@supers))
          (dv ,$empty (new ,class))
          (dm as ((p (t= ,class)) (x ,class) => <lst>) x)
          (dm as ((p (t= <lst>))  (x ,class) => <lst>) (as-lst x))
          (dm as ((p (t= ,class)) x|<lst> => <lst>)
            (app fabs ,class x))
          (df ,name (h t) (new ,class head h tail t))
          (dm empty ((e (t= ,class)) => ,class) ,$empty))))

(ds (def-programs ,name) `(def-list ,name (<programs>)))

(dc <ast-embodied-function> (<ast-function>))
  (dp function-body (x|<ast-embodied-function> => <any>)            #f)
  (dp function-index (x|<ast-embodied-function> => <any>)           0)
  (dp function-temporaries (x|<ast-embodied-function> => <any>)     '())
  (dp function-registers (x|<ast-embodied-function> => <any>)       '())
  (dp function-data-refs (x|<ast-embodied-function> => <any>)       '())
  (dp function-self-recursive? (x|<ast-embodied-function> => <any>) #f)
  (dp function-source (x|<ast-embodied-function> => <any>)          #f)

(def-programs free-environment)

(dc <ast-method> (<ast-embodied-function>))
  (dp function-free (x|<ast-method> => <free-environment>)
    (empty <free-environment>))

(dm function-kind (x|<ast-method>) "MET")

(dc <ast-primitive> (<ast-embodied-function>))

(dm function-kind (x|<ast-primitive>) "PRM")

(dc <ast-generic> (<ast-function>))

(dm function-kind (x|<ast-generic>) "GEN")

(dc <alternative> (<computed-program>))
  (dp alternative-condition (x|<alternative> => <any>))
  (dp alternative-consequent (x|<alternative> => <any>))
  (dp alternative-alternant (x|<alternative> => <any>))

(def-programs sequential)

(dc <constant> (<passive-program>))
  (dp constant-value (x|<constant> => <any>))
  (dp constant-index (x|<constant> => <any>))

(dc <raw-constant> (<constant>))

(dc <immediate-constant> (<constant>))

(dc <application> (<computed-program>))
  (dp application-arguments (x|<application> => <any>))
  (dp application-tail? (x|<application> => <any>) #f)

(dc <regular-application> (<application>))
  (dp application-function (x|<regular-application> => <any>))
  (dp application-known? (x|<regular-application> => <any>) #f)

(dc <method-application> (<regular-application>))
  (dp application-next-methods (x|<method-application> => <any>))

(dc <predefined-application> (<application>))
  (dp application-binding (x|<predefined-application> => <any>))

(dc <fix-let> (<computed-program>))
  (dp fix-let-bindings (x|<fix-let> => <any>))
  (dp fix-let-types (x|<fix-let> => <any>))
  (dp fix-let-arguments (x|<fix-let> => <any>))
  (dp fix-let-body (x|<fix-let> => <any>))

(def-programs fab-list)

(def-programs arguments)

(dc <locals> (<computed-program>))
  (dp locals-bindings (x|<locals> => <any>))
  (dp locals-functions (x|<locals> => <any>))
  (dp locals-body (x|<locals> => <any>))

(dc <bind-exit> (<computed-program>))
  (dp bind-exit-main-fun (x|<bind-exit> => <any>))

(dc <unwind-protect> (<computed-program>))
  (dp unwind-protect-protected-thunk (x|<unwind-protect> => <any>))
  (dp unwind-protect-cleanup-thunk (x|<unwind-protect> => <any>))

(dc <monitor> (<computed-program>))
  (dp monitor-type (x|<monitor> => <any>))
  (dp monitor-info (x|<monitor> => <any>))
  (dp monitor-test (x|<monitor> => <any>))
  (dp monitor-handler (x|<monitor> => <any>))
  (dp monitor-main-thunk (x|<monitor> => <any>))

;;; ENVIRONMENT

(dc <static-environment> (<any>))
  (dp environment-next (x|<static-environment> => <any>) #f)
  (dp environment-bindings (x|<static-environment> => <col>))

(dc <static-global-environment> (<static-environment>))
  ;; The module associated with this environment.
  (dp environment-module (x|<static-global-environment> => <any>)) ;<module>
  ;; The module-loader which should be used to load new modules for
  ;; use by this environment.
  (dp environment-module-loader (x|<static-global-environment> => <any>)) ;<module-loader>
  ;; The modules used by this environment.
  (dp environment-uses-modules (x|<static-global-environment> => <vec>)
        (fab <vec> 0))
  ;; Does this environment allow cross-module resolution of symbols
  ;; of the form 'foo::bar'?
  (dp environment-allows-foreign-names? (x|<static-global-environment> => <log>)
        #f)

(dc <static-empty-environment> (<static-environment>))

(dv $empty-static-environment (new <static-empty-environment>))

(dc <static-local-environment> (<static-environment>))

;; Given an object, try to find a global binding which contains it.
;; Used by the writer.
;; TODO - This will only work in the runtime environment, not any of the
;; various syntax environments.
;; XXX - This is now horrendously broken.
(dm env-object-name (x => <any>)
  (esc return
    (do-static-global-bindings
     (fun (binding)
       (when (and (== (binding-kind binding) 'global)
                  (binding-global-box binding)
                  (== x (global-box-value (binding-global-box binding))))
         (return (binding-name binding))))
     (runtime-environment 'goo/boot))
    #f))


;;;; CONVERT TO AST FORM

(dm objectify (e|<lst> r|<static-environment> tail? => <any>)
  (if (isa? e <program>) ;; TODO: HACK FOR <PROGRAMS>
      e
      (objectify-list (objectify (head e) r #f) e r tail?)))

(dm objectify-list
    (f|<any> e|<lst> r|<static-environment> tail? => <any>)
  (objectify-application f (tail e) r tail?))

(dm objectify-list
    (f|<module-binding> e|<lst> r|<static-environment> tail? => <any>)
  (case (binding-kind f)
    (('magic) ((binding-handler f) e r tail?))
    (('macro) (objectify ((macro-expander f) e r tail?) r tail?))
    (#t       (error "Magic or Macro binding expected %=" f))))

(dm objectify (e|<sym> r|<static-environment> tail? => <any>)
  (objectify-symbol e r))

(dm objectify (e|<module-binding> r|<static-environment> tail? => <any>)
  e)

(dm objectify (e|<program> r|<static-environment> tail? => <any>)
  e)

(dm objectify ((e (t= '())) r|<static-environment> tail? => <any>)
  (objectify-quotation e r))

(dm objectify (e r|<static-environment> tail? => <any>)
  (objectify-quotation e r))

(dm objectify-quotation (value r => <constant>)
  (new <constant> constant-value value))

(dm objectify-quotation (value|<int> r => <immediate-constant>)
  (new <immediate-constant> constant-value value))

(dm objectify-quotation (value|<chr> r => <immediate-constant>)
  (new <immediate-constant> constant-value value))

(dm objectify-raw (value r => <raw-constant>)
  (new <raw-constant> constant-value value))

(dm objectify-bound? (e|<sym> r|<static-environment> tail? => <any>)
  (def ref (objectify-symbol e r))
  (new <bound?> bound?-reference ref))

;;; This routine always produces a version of 'program' which is accessible
;;; in the syntax environment.  If 'rt?' is true, it will make sure that
;;; there is also a version in the runtime environment.
(dm objectify-compile-time (program r tail? rt? => <program>)
  (def mod (find-environment-module r))
  (def syntax-env (module-syntax-environment mod))
  (def target-env (module-target-environment mod))
  (def ast (objectify program syntax-env tail?))
  ;; Process the program immediately.
  (ast-evaluate ast)
  ;; If we have been asked to create a runtime copy of this code--and we
  ;; are compiling--create a second copy of this code which can be
  ;; accessed in the runtime.  This parallels they way
  ;; <ast-macro-definition> works.  Otherwise, objectify #f.
  ;; The value of a CT-ALSO form is currently undefined.
  (if (and rt? (~== syntax-env target-env))
      (objectify program r tail?)
      (new <constant> constant-value #f)))

(dm objectify-alternative (t c a r tail? => <alternative>)
  (new <alternative> 
    alternative-condition  (objectify t r #f)
    alternative-consequent (objectify c r tail?)
    alternative-alternant  (objectify a r tail?)))

(dm sequentialize (e*|<lst> => <program>)
  (if (empty? e*)
      (new <constant> constant-value #f)
      (if (empty? (tail e*))
          (head e*)
          (rep loop ((e* e*))
            (if (empty? e*)
                (empty <sequential>)
                (sequential (head e*) (loop (tail e*))))))))

(dm transform-defs (e*|<lst> => <lst>)
  (if (empty? e*)
      '()
      (let ((e (head e*)))
        (if (sexpr-def? e)
            `((let ((,(sexpr-def-variable e) ,(sexpr-def-value e))) 
                ,@(transform-defs (tail e*))))
            `(,e ,@(transform-defs (tail e*)))))))

(dm objectify-sequential (e*|<lst> r tail? => <program>)
  (def asts 
    (rep loop ((res '()) (e* (transform-defs e*)))
      (if (empty? e*)
          (rev! res)
          (let ((tail? (if (empty? (tail e*)) tail? #f))
                (head  (objectify (head e*) r tail?)))
            (loop (pair head res) (tail e*))))))
  (sequentialize asts))

(dm objectify-application (ff|<ast-method> e* r tail? => <program>)
  (def ee* (convert2arguments (map (fun (e) (objectify e r #f)) e*)))
  (process-closed-application ff ee* r tail?))

;; TODO: USE THIS FOR PRIMITIVES

(dm objectify-application (ff|<predefined-reference> e* r tail? => <program>)
  (def ee*  (convert2arguments (map (fun (e) (objectify e r #f)) e*)))
  (def fvf  (reference-binding ff))
  (new <predefined-application> 
    application-binding   fvf
    application-arguments ee*
    application-tail?     tail?))

(dm objectify-application (ff e* r tail? => <program>)
  (def ee* (convert2arguments (map (fun (e) (objectify e r #f)) e*)))
  (new <regular-application> 
    application-function  ff
    application-arguments ee*
    application-tail?     tail?))

(dm process-closed-application (f|<ast-method> e* r tail? => <fix-let>)
  (def v* (function-bindings f))
  (def b  (function-body f))
  (if (function-nary? f)
      (process-nary-closed-application f e* r tail?)
      (if (= (len e*) (len (function-bindings f)))
          (new <fix-let> 
            fix-let-bindings  (function-bindings f)
            fix-let-types     (function-specs f)
            fix-let-arguments e*
            fix-let-body      (function-body f))
          (objectify-error "incorrect regular arity" f e*))))

(dm process-nary-closed-application (f e* r tail? => <fix-let>)
  (loc ((pack-nary-args (e*) ;; TODO: COULD BE SHARED WITH PAIRIZE
           (if (empty? e*)
               (lst 'quote '())
               (lst '%pair (head e*) (pack-nary-args (tail e*)))))
        (gather-arguments (e* v*)
          (if (binding-dotted? (head v*))
              (arguments (objectify (pack-nary-args e*) r #f) 
                         (empty <arguments>))
              (if (empty? e*)
                  (objectify-error "incorrect dotted arity" f e*)
                  (arguments 
                   (head e*) (gather-arguments (tail e*) (tail v*)))))))
   (def v* (function-bindings f))
   (def o  (new <fix-let> 
             fix-let-bindings  v*
             fix-let-types     (function-specs f)
             fix-let-arguments (gather-arguments e* v*)
             fix-let-body      (function-body f)))
   (set (binding-dotted? (last v*)) #f)
   o))
 
(dm convert2arguments (e*|<lst> => <any>)
  (if (empty? e*)
      (empty <arguments>)
      (arguments (head e*) (convert2arguments (tail e*)))))

;;; assignment on mutable local bindings are immediately
;;; processed. references to local mutable bindings must wait the
;;; second pass.

(dm objectify-assignment (binding|<lst> e r tail? => <program>)
  (def op (sexpr-operator binding))
  (if (sexpr-variable? op)
      (objectify
       (sexpr-make-application
        (objectify (sexpr-fab-setter-name op) r #f) 
        (pair e (sexpr-operands binding)))
       r tail?)
      (objectify-error "Unsupported Set!: %=" e)))

(dm objectify-assignment (binding|<sym> e r tail? => <assignment>)
  (def ref (objectify binding r #f))
  (def val (objectify e r #f))
  (objectify-assignment-using ref val))

(dm objectify-assignment-using 
    (ref|<local-reference> val|<program> => <local-assignment>)
 (set (binding-mutable? (reference-binding ref)) #t)
 (new <local-assignment> 
   assignment-reference ref
   assignment-form      val))

(dm objectify-assignment-using 
    (ref|<global-reference> val|<program> => <global-assignment>)
 (new <global-assignment> 
   assignment-binding (reference-binding ref)
   assignment-form    val))

(dm objectify-assignment-using 
    (ref|<runtime-reference> val|<program> => <runtime-assignment>)
 (new <runtime-assignment> 
   assignment-binding (reference-binding ref)
   assignment-form    val))

;;; TODO - Attempt to change the binding kind on the fly.  This
;;; only works up to a point.  To fix this, make 'runtime and 'global
;;; bindings a single binding type, and parameterize the storage
;;; used by that type at runtime.
;;; Rationale: calling ast-define-binding one or more times with
;;; various combinations of binding-kinds must never be able to
;;; transform a 'runtime binding into a 'global binding, and thereby
;;; confuse the compiler about where binding values are stored.
(df update-binding-kind (binding new-kind)
  (if (or (~== (binding-kind binding) 'runtime) (== new-kind 'magic))
      (set (binding-kind binding) new-kind)
      (cond
        ((== new-kind 'runtime) #t) ; We're already the correct type.
        ((== new-kind 'global) #t)  ; We're an acceptably close type.
        (#t (error "Cannot set type of runtime binding %s to %s.\n"
                   (binding-name binding) new-kind)))))

(dm ast-define-binding (r name defining-method? kind => <any>)
  (def existing-binding (find-binding name r))
  (def gr (find-static-global-environment r))
  (def mod (environment-module gr))
  (def binding
    (if existing-binding
        (let ((foreign?
                (not (or (binding-native-to? existing-binding mod)
                         defining-method?))))
          (if (binding-free? existing-binding)
              ;; If the binding is free, define it.
              (seq
                (set (binding-free? existing-binding) #f)
                (when foreign?
                  (transaction-register-implemented-binding
                   existing-binding)))
              ;; Otherwise, redefine the existing binding.
              ;; TODO - We should do more useful redefinition here.
              (when foreign?
                (msg out
                     "%s: warning: '%s' clobbers binding from %s.\n"
                     (module-name mod)
                     name
                     (binding-module-name existing-binding))))
          ;; Aggressively invalidate all dependents.  We might want to
          ;; make this more selective someday.
          (invalidate-dependents existing-binding $all-dependency-types)
          (update-binding-kind existing-binding kind)
          existing-binding)
        (let ((mod-name (module-name (find-environment-module r)))
              (binding 
               (new <module-binding> 
                 binding-kind        kind
                 binding-name        name
                 binding-free?       #f
                 binding-module-name mod-name)))
          (insert-global! binding gr)
          binding)))
    binding)

(dv *macro-tracing?* #f)

(dm objectify-definition (var e r => <any>)
  (def name
    (sexpr-variable-name var))
  (def binding 
    (ast-define-binding r name #f 'global))
  (def defn
    (new <definition> 
      assignment-binding binding
      assignment-form (objectify e r #f)))
  defn)

(df %%macro (modname name expander env-or-false => <module-binding>)
    ;; (msg out "DEFMACRO ") (writeln out sep-expander)
    (loc ((expand (x r tail?)
                  (when *macro-tracing?*
                    (msg out "MACRO ") (write out x) (msg out "\n"))
                  (def exp (app expander (lst x)))
                  (when *macro-tracing?*
                    (msg out "  => ") (write out exp) (msg out "\n"))
                  exp))
      ;; (msg out "DEFMAC %=\n" name)
      (def env     (or env-or-false (unchecked-runtime-environment modname)))
      (def binding (ast-define-binding env name #f 'macro))
      (set (binding-handler binding) expand)
      binding))

;; Process a macro definition.  This is somewhat ugly, because a single
;; macro definition may need to appear in as many as three places:
;;  1) The target environment, so it may be used by the program itself.
;;  2) The syntax environment, so it can be used to write other macros.
;;  3) The runtime environment *of the image we're building*.  This
;;     means that once our program has been compiled and run, macros
;;     should remain available in the listener.  This requires some magic,
;;     which is handled by <ast-macro-definition>.
;; XXX - This function has very ugly semantics, and I don't like it.
(dm objectify-syntax-definition (name e r rt? => <any>)
  (def sep-expander (sexpr-make-macro-function e))
  ;; Build a version of the macro for use in the target and syntax
  ;; environments.
  (def syntax-env   (find-syntax-environment r))
  (def ast-expander (objectify sep-expander syntax-env #f))
  (def expander     (ast-evaluate ast-expander))
  ;; Install it into the target environment.
  (def modname (module-name (find-environment-module r)))
  (def binding (%%macro modname name expander
                        (find-static-global-environment r)))

  ;; If the syntax and current environments are different (i.e., we're
  ;; compiling code), then install it in the syntax environment, too.
  (when (~== syntax-env (find-static-global-environment r))
    (insert-global! binding syntax-env))

  ;; If the macro should be available in the runtime of the image we're
  ;; building, work some magic.  Otherwise, just return false.
  (if rt?
      (new <ast-macro-definition> 
        assignment-binding binding
        assignment-form
          ;; Re-objectify the expander, this time using bindings from
          ;; the target environment.  This should allow it to be run
          ;; in the image (if we're reasonably lucky).
          (objectify sep-expander r #f))
      (objectify-quotation #f r)))
  
(dm objectify-function-definition (name e r => <ast-function-definition>)
  (def binding (ast-define-binding r name #f 'global))
  (def f       (objectify e r #f))
  (set (function-binding f)    binding)
  (set (function-debug-name f) (objectify-quotation name r))
  (def defn (new <ast-function-definition>
              assignment-binding binding assignment-form f))
  defn)

(df module-binding (kind|<sym> => <module-binding>)
  (new <module-binding> binding-kind kind))

(dm objectify-primitive-definition 
    (name sig body r => <ast-primitive-definition>)
  (def binding   (ast-define-binding r name #f 'predefined))
  (def signature (objectify-signature sig r))
  (def new-r     (r-extend* r (signature-bindings signature)))
  (def body      (objectify-sequential body new-r #t))
  (def form      (new <ast-primitive> 
                   function-binding    binding
                   function-debug-name (objectify-quotation name r)
                   function-signature  signature
                   function-body       body))
  (def defn      (new <ast-primitive-definition>
                   assignment-binding binding
                   assignment-form form))
  defn)

(dm objectify-generic-definition (name sig r => <ast-generic-definition>)
  (def binding   (ast-define-binding r name #f 'global))
  (def signature (objectify-signature sig r))
  (def form      (new <ast-generic>
                   function-binding    binding
                   function-debug-name (objectify-quotation name r)
                   function-signature  signature))
  (def defn      (new <ast-generic-definition>
                   assignment-binding binding
                   assignment-form    form))
  defn)

(dm objectify-method-definition (name e r => <ast-method-definition>)
  (def binding (ast-define-binding r name #t 'global))
  (def gen     (lst 'if (lst 'bound? name) name #f))
  (def met     (objectify e r #f))
  ;; TODO: NAME AND MARK AS GENERIC METHOD
  (def call    (lst '%define-method gen met))
  (def form    (objectify call r #f))
  (def defn    (new <ast-method-definition>
                 assignment-binding binding
                 assignment-form    form))
  (set (function-binding met)    name)
  (set (function-debug-name met) (objectify-quotation name r))
  defn)

;;; it is important that the body is objectified first so mutability
;;; of local bindings is known and they can be appropriately handled
;;; in objectify-bindings-list. 
;;; all bindings are considered immutable at the beginning.
;;; XXX - The dependency registration code here should be refactored and
;;; redesigned into something more reasonable.

(ddv *record-source?* #f)

(dm objectify-function-source (sig body r => <constant>)
  (dlet ((*max-print-depth*  $max-int)
         (*max-print-length* $max-int))
    (objectify-quotation
     (and *record-source?*
          (msg-to-str 
           "(fun %s %s)" sig (if (isa? body <lst>) (pair 'seq body) body)))
     r)))

(dm objectify-function (sig body r tail? => <ast-method>)
  ;; Allocate the method up front so we can log dependencies against it.
  (def method (new <ast-method>))
  (with-dependent method
    (def signature (objectify-signature sig r))
    (def new-r     (r-extend* r (signature-bindings signature)))
    (def b         (objectify-sequential body new-r #t))
    (set (function-debug-name method) (objectify-quotation #f r))
    (set (function-signature method)  signature)
    (set (function-body method)       b)
    (set (function-source method)
         (objectify-function-source sig body r))
    method))
    
(dv $sexpr-optionals-tag       '...)
(dv $sexpr-optionals-type-name '<opts>)

(dm objectify-signature (sig r => <ast-signature>)
  (def sexpr-params (sexpr-signature-parameters sig))
  (rep col ((params sexpr-params) (nary? #f) (bindings '()) 
            (names (empty <fab-list>)) (types (empty <fab-list>)))
    (if (empty? params)
        (let ((sexpr-value (sexpr-signature-value sig))
              (value (objectify (or sexpr-value (default-type r)) r #f))
              (arity (- (len names) (if nary? 1 0))))
          (new <ast-signature>
            signature-bindings (rev! bindings)
            signature-names    (rev! names)
            signature-specs    (rev! types)
            signature-nary?    (objectify nary? r #f)
            signature-arity    (objectify arity r #f)
            signature-value    value))
        (let ((param   (head params))
              (sname   (sexpr-variable-name param))
              (stype   (sexpr-variable-type param))
              (dotted? (== stype $sexpr-optionals-tag))
              (stype   (if dotted? $sexpr-optionals-type-name stype))
              (type    (objectify stype r #f))
              (name    (objectify-quotation sname r))
              (binding
               (new <local-binding>
                 binding-name sname
                 binding-type type
                 binding-dotted? dotted?)))
          (col (tail params) dotted? 
               (pair binding bindings)
               (new <fab-list> head name tail names)
               (new <fab-list> head type tail types))))))

(dm compute-local-reference-offsets 
    (binding|<local-binding> r|<static-local-environment> 
     => (tup frame-number|<int> frame-offset|<int>))
 (rep loop ((i 0) (r r))
   (if (isa? r <static-local-environment>)
       (rep find ((j 0) (bindings (environment-bindings r)))
         (if (empty? bindings)
             (loop (+ i 1) (environment-next r))
             (if (== (head bindings) binding)
                 (tup i j)
                 (find (+ j 1) (tail bindings)))))
       (error "DIDN'T FIND LOCAL BINDING %= IN %=" (binding-name binding) r))))

(dm objectify-binding (n b|<local-binding> r => <local-reference>)
  (def (tup i j) (compute-local-reference-offsets b r))
  (new <local-reference>
    reference-binding      b
    reference-frame-number i
    reference-frame-offset j))

;; (dm objectify-binding 
;;     (n b|<next-methods-binding> r => <next-methods-reference>)
;;   (new <next-methods-reference> reference-binding b))

(dm binding-reference-class (b|<module-binding> => <type>)
  ;; TODO: => (T< <REFERENCE>)
  (case (binding-kind b)
    (('global)     <global-reference>)
    (('predefined) <predefined-reference>)
    (('runtime)    <runtime-reference>)
    (#t            (error "Unknown binding-kind %=" (binding-kind b)))))

(dm objectify-binding (n b|<module-binding> r => <any>)
  (case (binding-kind b)
    (('magic 'macro) b)
    (#t              (def <ref> (binding-reference-class b))
                     (new <ref> reference-binding b))))

(dm objectify-binding (n b r => <reference>)
  (objectify-free-global-reference n r))

;;; a free binding is defined to be a global binding defined on the fly.

(dm default-type (r) 
  (objectify '<Any> r #f))

;;; Handle variables which get used before we define them.
;;; TODO - Decide if this is the best place to handle foreign names.
(dm objectify-free-global-reference (name r => <reference>)
  (def gr (find-static-global-environment r))
  (if (and (environment-allows-foreign-names? gr)
           (foreign-name? name))
      (objectify-foreign-reference name r)
      (let ((b (new <module-binding>
                  binding-free? #t
                  binding-kind  'global
                  binding-name  name
                  binding-module-name
                  (module-name (find-environment-module r)))))
        (insert-global! b gr)
        (new <global-reference> reference-binding b))))

;;; Does this name have the form 'foo:bar'?
(df foreign-name? (name|<sym> => <log>)
  (~== (pos (as <str> name) #\:) #f))

;;; Turn 'foo:bar' into a reference to 'bar' in the 'foo' module.
(dm objectify-foreign-reference (name r => <reference>)
  (def namestr (as <str> name))
  (def break   (pos namestr #\:))
  (def modname (sub namestr 0 break))
  (def varname (sub namestr (+ 1 break) (len namestr)))
  (unless (and (> (len modname) 0) (> (len varname) 0))
    (error "Malformed foreign name %s.\n" name))
  (def gr      (find-static-global-environment r))
  (def loader  (environment-module-loader gr))
  (def mod     (probe-module loader (as <sym> modname)))
  (def binding (find-binding (as <sym> varname)
                             (module-target-environment mod)))
  ;; TODO: THIS MIGHT BE SUSPECT BUT IT MAKES DYN-CMP HAPPY
  (insert-global! binding gr)
  (unless binding
    (error "No binding %s in %s.\n" varname modname))
  (objectify-binding name binding r))

(dm objectify-symbol (name r => <any>)
  (objectify-binding name (find-binding name r) r))

(dm ftype (r)
  (objectify '<fun> r #f))

(def-programs functions)

(dm objectify-locals (names sigs bodies body r tail? => <locals>)
  (def bindings       (map (fun (n) (new <local-binding> 
                                      binding-name n binding-type (ftype r)))
                           names))
  (def new-r          (r-extend* r bindings))
  (def function-forms (map2 sexpr-make-anonymous-method sigs bodies))
  (def functions      (map (rcurry objectify new-r #f) function-forms))
  ;; TODO: CIRCULARITIES IN AST
  (do2 (fun (f b) 
         (set (function-binding f) b)
         (set (function-debug-name f) 
              (objectify-quotation (binding-name b) r))
         (set (binding-value b) f)) 
       functions bindings)
  (new <locals>
    locals-bindings  bindings
    locals-functions (app fabs <functions> functions)
    locals-body      (objectify-sequential body new-r #t)))

(dm objectify-bind-exit (name body r tail? => <bind-exit>)
  (new <bind-exit>
       bind-exit-main-fun 
        (objectify (sexpr-make-anonymous-method (lst name) body) r #f)))

(dm objectify-unwind-protect
    (protected-form cleanup-forms r tail? => <unwind-protect>)
  (new <unwind-protect>
       unwind-protect-protected-thunk
         (objectify
          (sexpr-make-anonymous-method '() (lst protected-form))
          r #f)
       unwind-protect-cleanup-thunk
         (objectify
          (sexpr-make-anonymous-method '() cleanup-forms)
          r #f)))

(dm objectify-monitor (type info test handler body r tail? => <monitor>)
  (new <monitor>
    monitor-type       (objectify type r #f)
    monitor-info       (objectify info r #f)
    monitor-test       (objectify test r #f)
    monitor-handler    (objectify handler r #f)
    monitor-main-thunk (objectify body r #f)))

(dm objectify-export (names r tail? => <program>)
  (def env (find-static-global-environment r))
  (def module (find-environment-module r))
  (unless (== env (module-target-environment module))
    ;; The user tried to export bindings from a syntax environment.
    ;; (This shouldn't happen, because we don't provide 'export'.)
    (error "Can only export bindings from target environment.\n"))
  (do (fun (name)
        (def binding (find-binding name env))
        (if (== binding #f)
            (esc exit
              (try ((type <restart>)
                    (description "Continue without exporting %s" name))
                (fun (c r) (exit #f))
                (error "Can't export undefined binding %s.\n" name)))
            (export-binding! module name binding)))
      names)
  (new <constant> constant-value #f))

;;; This works like 'insert-global!', but it's more careful about clobbering.
(df import-global! (b|<module-binding> env|<static-global-environment>)
  (def existing (find-binding (binding-name b) env))
  (unless (or (== existing #f) (== existing b))
    (msg out "warning: '%s' from %s clobbers local binding.\n"
         (binding-name b) (binding-module-name b)))
  (insert-global! b env)
  #f)

(dm objectify-use/export-module (name r tail? => <program>)
  (def env (find-static-global-environment r))
  (def module (find-environment-module r))
  (def loader (environment-module-loader env))
  (def used-module (probe-module loader name))
  (push! (environment-uses-modules env) used-module)
  (do (fun (b)
        (import-global! b env)
        (export-binding! module (binding-name b) b))
      (module-exports used-module))
  (new <constant> constant-value #f))

(dm objectify-use-module (name r tail? => <program>)
  (def env (find-static-global-environment r))
  (def loader (environment-module-loader env))
  (def used-module (probe-module loader name))
  (push! (environment-uses-modules env) used-module)
  (do (fun (b) (import-global! b env)) (module-exports used-module))
  (new <constant> constant-value #f))

(dm expand-bind-list (pat var fail => <any>)
  (error "Expected Pattern List %=\n" pat))

(dm expand-bind-list ((pat (t= '())) var fail => <lst>)
  `(match-empty-list ,var ,fail))

(dm expand-bind-list (pat|<lst> var fail => <lst>)
  (cond
    ((sexpr-unquote? pat)
      (error "Unquote Unexpected Here %=\n" pat))
    ((sexpr-unquote-splicing? pat)
     (error "Unquote Splicing Unexpected Here %=\n" pat))
    (#t
     (expand-bind-list* pat var fail))))

(dm expand-bind-list* ((pat (t= '())) var fail => <any>)
  `(match-empty-list ,var ,fail))

(dm expand-bind-list* (pat|<lst> var fail => <any>)
  `(let ((,var ,(expand-bind-element (head pat) var fail)))
     ,(expand-bind-list* (tail pat) var fail)))

(dm expand-bind-element (pat var fail => <any>)
  `(match-atom ,var ',pat ,fail))

(dm expand-bind-element (pat|<lst> var fail => <any>)
  (cond
    ((sexpr-unquote? pat)
     `(seq (set ,(2nd pat) (match-unquote ,var ,fail)) (tail ,var)))
    ((sexpr-unquote-splicing? pat)
     `(seq (set ,(2nd pat) ,var) '()))
    (#t
     `(seq (let ((,var (match-sublist ,var ,fail)))
             ,(expand-bind-list pat var fail))
           (tail ,var)))))

(dm expand-pattern (pat|<lst> var fail => <any>)
  `(if (isa? ,var <lst>)
       ,(expand-bind-list pat var fail)
       (,fail "Match Pattern Failure" ,var)))

(dm expand-syntax-if (x|<lst> => <lst>)
  (def pat   (sexpr-syntax-if-pattern x))
  (def vars  (sexpr-bind-pattern-variables pat))
  (def value (sexpr-syntax-if-value x))
  (def then  (sexpr-syntax-if-then x))
  (def else  (sexpr-syntax-if-else x))
  (def var   (gensym))
  (def fail  (gensym))
  (def epat  (expand-pattern pat var fail))
  `(esc return
     (loc ((,fail ((msg <str>) (args ...)) (return ,else)))
       (let ((,var ,value))
         (let ,(map (fun (x) `(,x #f)) vars)
           ,epat
           ,then)))))

;;; AST ENVIRONMENT

;;; these functions deal with the environment.  r is a sequential of
;;; full-environment objects containing local bindings followed by an
;;; instance of environment followed by a sequential of full-environment
;;; containing the global mutable bindings mixed with the global
;;; macros followed by the predefined bindings.

(dm r-extend* (r bindings|<lst> => <static-environment>)
  (new <static-local-environment> 
    environment-next r environment-bindings bindings))

(dm insert-global! (binding r)
  (def r|<static-global-environment> (find-static-global-environment r))
  (set (elt (environment-bindings r) (binding-name binding)) binding))

(dm insert-globals! (bindings|<lst> r) 
  (do (fun (b) (insert-global! b r)) bindings))

(dm find-static-global-environment 
    (r|<static-local-environment> => <static-global-environment>)
  (find-static-global-environment (environment-next r)))

(dm find-static-global-environment
    (r|<static-global-environment> => <static-global-environment>)
  r)

(dm find-syntax-environment (r|<static-environment>
                             => <static-global-environment>)
  (module-syntax-environment (find-environment-module r)))

(dm find-environment-module (r|<static-environment>) ; => <module>
  (environment-module (find-static-global-environment r)))

(dm find-binding (name r|<static-local-environment> => <any>)
  (rep loop ((bindings (environment-bindings r))) ;; TODO: => (or <binding> #f)
    (if (empty? bindings)
        (find-binding name (environment-next r))
        (if (== name (binding-name (head bindings)))
            (head bindings)
            (loop (tail bindings))))))

;; TODO: => T? <BINDING>

(dm find-binding (name r|<static-empty-environment> => <any>)
  #f)

(dm find-binding (name r|<static-global-environment> => <any>) 
  (or (elt-or (environment-bindings r) name #f)
      (find-binding name (environment-next r))))

;; TODO: CLEANUP

(dm frame-bindings (env|<static-environment> => <col>)
  ;; (as <lst> (map identity (environment-bindings env)))
  (environment-bindings env))

;;;; SPECIAL FORMS

(dv *magic-bindings* '())

(dm register-magic-binding (name value)
  (set *magic-bindings* (add *magic-bindings* value)))

(dm magic-bindings ()
  *magic-bindings*)

(ds (define-magic-binding ,name (,@params) ,@body)
  (let ((special-name (cat-sym "special-" name))
        (sexpr-name   (cat-sym "$sexpr-" name "-tag")))
    `(seq (dv ,special-name
            (new <module-binding>
              binding-kind        'magic
              binding-name        ,sexpr-name
              binding-module-name $goo-boot-module-name
              binding-handler     (fun (,@params) ,@body)
              binding-free?       #f))
          (register-magic-binding ',name ,special-name))))

(define-magic-binding if (x r tail?)
  (objectify-alternative
    (sexpr-if-test x) (sexpr-if-then x) (sexpr-if-else x) r tail?))

(define-magic-binding begin (x r tail?)
  (objectify-sequential (tail x) r tail?))

(dv $sexpr-%raw-tag '%raw)

(define-magic-binding %raw (x r tail?)
  (objectify-raw (2nd x) r))

(define-magic-binding quote (x r tail?)
  (objectify-quotation (sexpr-text-of-quotation x) r))

(define-magic-binding set (x r tail?)
  (objectify-assignment
    (sexpr-assignment-variable x) (sexpr-assignment-value x) r tail?))

(define-magic-binding define (x r tail?)
  (objectify-definition
    (sexpr-definition-variable x) (sexpr-definition-value x) r))

(define-magic-binding define-syntax (x r tail?)
  (objectify-syntax-definition
    (sexpr-syntax-definition-variable x) (sexpr-syntax-definition-value x) r #t))

(dv $sexpr-define-static-syntax-tag 'dss)

(define-magic-binding define-static-syntax (x r tail?)
  (objectify-syntax-definition
    (sexpr-syntax-definition-variable x) (sexpr-syntax-definition-value x) r #f))

(define-magic-binding define-method (x r tail?)
  (objectify-method-definition
    (sexpr-function-definition-variable x) 
    (sexpr-function-definition-value x) r))

(define-magic-binding define-generic (x r tail?)
  (objectify-generic-definition
    (sexpr-function-definition-variable x) (sexpr-function-signature x) r))

(define-magic-binding define-function (x r tail?)
  (objectify-function-definition
    (sexpr-function-definition-variable x) 
    (sexpr-function-definition-value x) r))

(define-magic-binding method (x r tail?)
  (objectify-function
    (sexpr-method-signature x) (sexpr-method-body x) r tail?))

(dv $sexpr-bound?-tag 'bound?)

(define-magic-binding bound? (x r tail?)
  (objectify-bound? (2nd x) r tail?))

(define-magic-binding let (x r tail?)
  (objectify (sexpr-let->combination x) r tail?))

;; (define-magic-binding let (x r tail?)
;;   (objectify (sexpr-let-value x) r tail?))

(define-magic-binding def (x r tail?)
  (objectify (sexpr-def-value x) r tail?))

(define-magic-binding locals (x r tail?)
  (objectify-locals
    (sexpr-loc-bound-names x) (sexpr-loc-bound-signatures x) 
    (sexpr-loc-bound-bodies x) (sexpr-loc-raw-body x) r tail?))

(define-magic-binding iterate (x r tail?)
  (objectify (sexpr-iterate->loc x) r tail?))

(define-magic-binding bind-exit (x r tail?)
  (objectify-bind-exit (sexpr-block-name x) (sexpr-block-body x) r tail?))

(define-magic-binding unwind-protect (x r tail?)
  (objectify-unwind-protect
    (sexpr-unwind-protect-protected-form x) 
    (sexpr-unwind-protect-cleanup-forms x)
    r tail?))

(define-magic-binding monitor (x r tail?)
  (def (tup type info test handler body) (sexpr-monitor-expand x))
  (objectify-monitor type info test handler body r tail?))

(dm pairize (args|<lst> => <any>)
  (if (empty? args)
      (lst 'quote '())
      (lst '%pair (head args) (pairize (tail args)))))

(define-magic-binding isa (x r tail?)
  (def prop-inits (sexpr-isa-prop-inits x))
  (objectify
   (sexpr-make-application
    '%isa
    (lst (sexpr-isa-parent x)
         (pairize (sexpr-isa-init-props prop-inits))
         (pairize (sexpr-isa-init-values prop-inits))))
   r tail?))

(define-magic-binding define-class (x r tail?)
  (def name (sexpr-definition-variable x))
  (objectify-definition
   name `(fab-class ',name ,(pairize (sexpr-define-class-parents x))) r))
 
(define-magic-binding prop (x r tail?)
  (def name        (sexpr-prop-name x))
  (def var         (sexpr-prop-init-var x))
  (def owner       (sexpr-prop-owner x))
  (def setter-name (sexpr-fab-setter-name name))
  (def type        (sexpr-prop-type x))
  (objectify
   (sexpr-make-begin
    (lst (sexpr-fab-getter name owner)
         (sexpr-fab-setter name owner type)
         (sexpr-make-application
          '%prop
          (lst owner
               name setter-name type
               (if (sexpr-prop-init? x)
                   (sexpr-make-anonymous-method
                    `((,var <any>)) (lst (sexpr-prop-init x)))
                   '%prop-unbound-error)))))
   r tail?))
                            
(dv $sexpr-compile-time-tag 'ct)

(define-magic-binding compile-time (x r tail?)
  (objectify-compile-time (head (tail x)) r tail? #f))

(dv $sexpr-compile-time-also-tag 'ct-also)

(define-magic-binding compile-time-also (x r tail?)
  (objectify-compile-time (head (tail x)) r tail? #t))

(dv $sexpr-define-primitive-tag 'dl)

(define-magic-binding define-primitive (x r tail?)
  (if (sexpr-forward-primitive? x)
      (seq (ast-define-binding
            r (sexpr-function-definition-variable x) #f 'predefined)
           (objectify #f r tail?))
      (objectify-primitive-definition
       (sexpr-function-definition-variable x) 
       (sexpr-function-signature x) (sexpr-function-body x) r)))

(define-magic-binding quasiquote (x r tail?)
  (objectify (sexpr-expand-backquote x) r tail?))

(dm ast-macro-expand (x r tail?)
  (def m (objectify (head x) r tail?))
  (if (and (isa? m <module-binding>) (== (binding-kind m) 'macro))
      (let ((res ((binding-handler m) x r tail?)))
        ;; (msg out "EXPANSION ") (write out res) (msg out "\n")
        res)
      #f))

(define-magic-binding macro-expand (x r tail?)
  (objectify-quotation
    (ast-macro-expand (2nd x) r tail?) r))

(define-magic-binding syntax-if (x r tail?)
  ;; (syntax-if (?pattern ?value) ?form ...)
  ;; x   => just matches etc
  ;; x  => binds x to an sexpr
  ;; @x => binds x to a series of sexprs
  ;; TODO: make this deals with multiple bindings
  (objectify (expand-syntax-if x) r tail?))

(dv $sexpr-export-tag 'export)

(define-magic-binding export (x r tail?)
  (objectify-export (tail x) r tail?))

(dv $sexpr-use-module-tag 'use)

(define-magic-binding use-module (x r tail?)
  (objectify-use-module (2nd x) r tail?))

(dv $sexpr-use/export-module-tag 'use/export)

(define-magic-binding use/export-module (x r tail?)
  (objectify-use/export-module (2nd x) r tail?))

;;;;=======================================================================
;;;;  Transaction Information
;;;;=======================================================================
;;;;  Compilation of a Goo expression has relatively few side effects.
;;;;  So if we want to get rid of some small chunk compiled code (perhaps
;;;;  an error occurred later in the compilation process, or p2c unloaded a
;;;;  module), we can let the garbage collector do most of the work.
;;;;
;;;;  There are a few exceptions:
;;;;    1) Imported free bindings may have been defined.  This hack
;;;;       is needed for the 'need-implementation' macro.
;;;;    2) Any number of dependencies may have been registered.
;;;;
;;;;  We need to take pains to undo these operations manually.  We *could*
;;;;  do this by building destructor functions for all the ast nodes, but
;;;;  that would be bletcherous, and require rewriting half the compiler.
;;;;
;;;;  Instead, we use a simple transaction mechanism.
;;;;
;;;;  Each module has an associated transaction.  If the module is unloaded,
;;;;  the module transaction must be rolled back.
;;;;
;;;;  Each invocation of the compiler has a "subtransaction".  If
;;;;  compilation succeeds, this is merged into the module transaction.  If
;;;;  compilation fails, it is rolled back.

(dc <transaction> (<any>))
  (dp transaction-implemented-bindings (x|<transaction> => <tab>) (fab <tab> 10))
  (dp transaction-dependents (x|<transaction> => <tab>) (fab <tab> 10))

(dv *current-subtransaction* #f)

(df transaction-register-implemented-binding (b|<binding>)
  (unless *current-subtransaction*
    (error "Can't register implemented foreign binding (no subtransaction)"))
  (set (elt (transaction-implemented-bindings *current-subtransaction*) b) #t))

(df transaction-register-dependent (d|<dependent>)
  (unless *current-subtransaction*
    (error "Can't register dependent (no subtransaction)"))
  (set (elt (transaction-dependents *current-subtransaction*) d) #t))

(df transaction-empty? (t|<transaction> => <log>)
  (and (empty? (transaction-implemented-bindings t))
       (empty? (transaction-dependents t))))

(df merge-transactions! (t1|<transaction> t2|<transaction> => <transaction>)
  (cond
    ;; If one of the transactions is empty, return the other.
    ((transaction-empty? t2) t1)
    ((transaction-empty? t1) t2)
    ;; Otherwise, merge t2 into t1 destructively.
    (#t
     (def t1-bindings (transaction-implemented-bindings t1))
     (def t2-bindings (transaction-implemented-bindings t2))
     (def t1-dependents (transaction-dependents t1))
     (def t2-dependents (transaction-dependents t2))
     (do-keyed (fun (k v) (set (elt t1-bindings k) #t)) t2-bindings)
     (do-keyed (fun (k v) (set (elt t1-dependents k) #t)) t2-dependents)
     t1)))

(df roll-back-transaction (t|<transaction>)
  (do-keyed
   (fun (binding junk) (set (binding-free? binding) #t))
   (transaction-implemented-bindings t))
  (do-keyed
   (fun (dependent junk) (detach-dependent dependent))
   (transaction-dependents t)))

(df call-with-subtransaction (module thunk => <any>)
  (def success #f)
  (def saved *current-subtransaction*)
  (fin
    (seq
      (set *current-subtransaction* (new <transaction>))
      (def value (thunk))
      (set success #t)
      value)
    (seq
      (if success
          (set (module-transaction module)
               (merge-transactions! (module-transaction module)
                                    *current-subtransaction*))
          (roll-back-transaction *current-subtransaction*))
      (set *current-subtransaction* saved))))

(ds (with-subtransaction (,module) ,@body)
  `(call-with-subtransaction ,module (fun () ,@body)))
           
;;; Objectify the specified code within a subtransaction associated
;;; with the appropriate module.
;;;
;;; XXX - It's not strictly correct to call this from the interpreter,
;;; because it will finalize the transaction as soon as the code
;;; is succcessfully objectified, but before it is run--and I'm not
;;; sure how we should handle rollbacks if part of the code is
;;; objectified but never executed.  Nonetheless, this is nearly
;;; correct, and probably good enough for now.
(df objectify-with-subtransaction (e r|<static-environment> tail? => <any>)
  (with-subtransaction ((environment-module r))
    (objectify e r tail?)))


;;;;=======================================================================
;;;;  Module Loaders & Modules
;;;;=======================================================================
;;;;  A module contains two environments: a target environment, and a
;;;;  syntax environment.  The target environment is used for objectifying
;;;;  actual programs, and the syntax environment is used for objectifying
;;;;  DS, CT, DSS and any other compile-time forms.  In some cases, the
;;;;  syntax environment and the target environment might be the same.
;;;;
;;;;  See PROPOSALS/SIMPLE-MODULES.TXT for an overview of the module
;;;;  system from a programmer's perspective.
;;;;
;;;;  A <module-loader> loads modules from disk and keeps them in memory.
;;;;  There are typically several module loaders in use:
;;;;    1. A module loader for the running image's listener.
;;;;    2. A module loader for each program being compiled.

(dc <module-loader> (<any>))
  ;; A map from module names (represented as symbols) to
  ;; <module> objects.
  (dp module-loader-modules (x|<module-loader> => <tab>) (fab <tab> 1000))
  ;; A stack of all the names of modules currently being loaded.
  ;; We use this to catch circular dependencies.
  (dp module-loader-stack (x|<module-loader> => <lst>) '())

(export <module-loader>)

(dc <module> (<any>))
  (dp module-name (x|<module> => <sym>))
  ;; The environments associated with this module.
  (dp module-target-environment (x|<module> => <static-global-environment>))
  (dp module-syntax-environment (x|<module> => <static-global-environment>))
  ;; The bindings exported by this module.
  (dp %module-exports (x|<module> => <tab>)            (fab <tab> 1000))
  (dp module-data-processed? (x|<module> => <log>)     #t)
  (dp module-runtime-data (x|<module> => <any>)        #f)
  (dp module-transaction (x|<module> => <transaction>) (new <transaction>))

(dv module-exports-setter %module-exports-setter)
(dm module-exports (x|<module> => <tab>)
  (ensure-module-data x)
  (%module-exports x))

(export
  <module>
  module-name
  module-syntax-environment
  module-target-environment)

(df set-module-environments (mod|<module>
                             syntax-env|<static-global-environment>
                             target-env|<static-global-environment>)
  (set (module-syntax-environment mod) syntax-env)
  (set (module-target-environment mod) target-env))

;;; Call a function 'f' for each module associated with the module loader.
(df do-module-loader-modules (f loader)
  (do (fun (mod) (f mod))
      (module-loader-modules loader)))

;; Create an empty module for use with a particular loader.
;; Override this method to use a custom module class.
(dm module-loader-module-type (loader|<module-loader> => <type>)
  <module>)

;;; Add a module to a module-loader.
(df register-module! (module-loader|<module-loader> mod|<module>
                      => <module-loader>)
  (set (elt (module-loader-modules module-loader) (module-name mod)) mod)
  module-loader)

;;; Find the module with the given name, loading it if necessary.
(df probe-module (loader|<module-loader> name|<sym> => <module>)
  (or (elt-or (module-loader-modules loader) name #f)
      (load-and-register-module loader name)))

;;; This function keeps track of nesting and registration.
(df load-and-register-module (loader|<module-loader> name|<sym> => <module>)
  (def stack (module-loader-stack loader))
  (def depth (len stack))
  (def indent (string-repeat "  " depth))
  
  ;; First, make sure we aren't already loading this module.
  (when (mem? stack name)
    (error "%s: error: Circular use of %s not allowed" (head stack) name))

  ;; Load the module, using a FIN form to manage the load stack.
  ;; XXX - If an error occurs, we currently neglect to mark
  ;; the environment-implements bindings of the half-created
  ;; module as free.
  (msg out "%s[Loading module %s...\n" indent name) 
  (def mod (seq (pushf (module-loader-stack loader) name)
                (fin (load-module loader name)
                     (popf (module-loader-stack loader)))))
  (register-module! loader mod)
  (msg out "%s]\n" indent)
  mod)

;;; Create a <module-loader> subclass and override this method.  It should
;;; create and register a module, call 'read-file', objectify the code in
;;; the module's target environment, and do something appropriate with the
;;; resulting ast.
;;;
;;; TODO - Block recursive loads.
;;; TODO - We must eventually be able to support runtime modules, too.
;;; this may require a fair bit of refactoring.
(dg load-module (loader|<module-loader> name|<sym> => <module>))

;;; Export a binding from a module.
(df export-binding! (module|<module>
                     name|<binding-name>
                     binding|<module-binding>
                     => (t= #f))
  (def exports (module-exports module))
  (def existing (elt-or exports name #f))
  (unless (or (== existing #f) (== existing binding))
    (error "Tried to export %= and %= from %= as %="
           existing binding module name))
  (set (elt exports name) binding)
  #f)

;;; Return true iff a binding was originally defined in the current module.
(df binding-native-to? (binding|<module-binding> module|<module> => <log>)
  (== (module-name module) (binding-module-name binding)))

;;; Report all the undefined bindings in the specified module.
(df report-undefined-global-bindings (mod|<module>)
  (do-static-global-bindings
   (fun (binding)
     (when (and (binding-free? binding)
                (binding-native-to? binding mod))
       (msg out "%s: warning: undefined binding '%s'.\n"
            (module-name mod)
            (binding-name binding))))
   (module-target-environment mod)))

;;; Compute all the modules which use the specified modules, directly or
;;; indirectly.  Yes, this function is slow and ugly.
(df compute-transitive-users (loader|<module-loader>
                              modnames|<lst> => <lst>)
  (def users (fab <tab> 100))
  (loc ((add-user (modname)
          (unless (elt-or users modname #f)
            (set (elt users modname) modname)
            (do-module-loader-modules
             (fun (mod)
               (do
                (fun (uses-mod)
                  (when (== modname (module-name uses-mod))
                    (add-user (module-name mod))))
                (environment-uses-modules (module-target-environment mod))))
             loader))))
    (do add-user modnames)
    (packing () (do (fun (v) (pack v)) users))))

;;; Remove a single module object from the loader.
;;; This should not be called externally, because it does not bother to
;;; remove other modules which use this one.
(df remove-module-internal! (loader|<module-loader> mod|<module>)
  (roll-back-transaction (module-transaction mod))
  (del! (module-loader-modules loader) (module-name mod)))

;;; Unload all the named modules, and all the modules which use them.
(df remove-modules-by-name! (loader|<module-loader> modnames|<lst> => (t= #f))
  (def remove-names (compute-transitive-users loader modnames))
  (do (fun (modname)
        (def mod (elt (module-loader-modules loader) modname))
        (remove-module-internal! loader mod))
      remove-names)
  #f)

;;; Convert a module name to a relative path name.
;;;   foo/bar => "foo/bar" or "foo\\bar", etc.
(df module-name-to-relpath (name|<sym> => <str>)
  (def namestr (map to-lower (sym-name name)))
  (string-join (string-split namestr #\/) *path-separator*))

;;; Copy the binding for 'use' into the module, so it can ask for more
;;; bindings as needed.  Copy 'seq', too, because the top-level of the
;;; file gets wrapped in it.
(df install-initial-bindings (env|<static-global-environment>
                              loader|<module-loader>)
  (def bootmod (probe-module loader $goo-boot-module-name))
  (def bootenv (module-target-environment bootmod))
  (do (fun (name) (insert-global! (find-binding name bootenv) env))
      '(SEQ USE)))

(export
  set-module-environments
  module-loader-module-type
  do-module-loader-modules
  probe-module
  load-module
  binding-native-to?
  report-undefined-global-bindings
  remove-modules-by-name!
  module-name-to-relpath
  install-initial-bindings)


;;;;=======================================================================
;;;;  Set Up Initial Environments for Objectification
;;;;=======================================================================
;;;;  To objectify code, we need to look up variables in a global
;;;;  environment.  Right now, there are several possible environments:
;;;;   
;;;;    1) The listener's module, known as the "runtime" module, contains
;;;;       one environment (which is used as both the syntax
;;;;       and the target environment) per module.
;;;;
;;;;    2) p2c sets up seperate syntax and target environments for each
;;;;       module it compiles.
;;;;       
;;;;       The syntax environments are stripped down versions of the
;;;;       runtime environment.  The compiler uses these environment to
;;;;       process CT and DS forms.  They contains most of the bindings in
;;;;       core goo, but not much else.
;;;;
;;;;       The target environments contain only a few bindings.  The
;;;;       initial bootstrap environments get initialized with a selection
;;;;       of <predefined-bindings>s and a few magic bindings like IF.
;;;;       The target environments of other modules are initially supplied
;;;;       with the magic bindings SEQ and USE, which are enough to allow
;;;;       them to import bindings from other modules.

;;; ENVIRONMENT CREATION 

;; Create a new global environment.
(df fab-static-global-environment 
  (module|<module> module-loader|<module-loader> allow-foreign-names?|<log>
   => <static-global-environment>)
  (def new-env (new <static-global-environment>
                 environment-module module
                 environment-module-loader module-loader
                 environment-next $empty-static-environment
                 environment-allows-foreign-names? allow-foreign-names?
                 environment-bindings (fab <tab> 2000)))
  new-env)

;; Given an environment and a list of symbols, return a new environment
;; containing all the bindings in the original environment that are *not*
;; named by a symbol in 'excluded'.
(df fab-subset-environment (module|<module> src-module|<module> excluded|<col>
                            => <static-global-environment>)
  (def loader
    (environment-module-loader (module-target-environment src-module)))
  (def new-env
    (fab-static-global-environment module loader #f))
  (do-keyed
   (fun (name binding)
     (unless (mem? excluded name)
       ;; TODO - Renaming: Honor name.
       (insert-global! binding new-env)))
   (module-exports src-module))
  new-env)


;;;;=======================================================================
;;;;  Runtime Setup
;;;;=======================================================================
;;;;  Recover information about the modules and bindings that were built
;;;;  into our image.  This mostly involves calling build-runtime-modules
;;;;  and passing it an appropriate set of functions, then doing a small
;;;;  amount of tweaking to set up macros, magic bindings, and other
;;;;  stuff correctly.

(dc <runtime-module-loader> (<module-loader>))

(ddv *now-rt-env* #f)

;;; This is called if somebody tries to load a module at runtime which
;;; hadn't been built into the image.
(dm load-module (loader|<runtime-module-loader> name|<sym> => <module>)
  (def type       (module-loader-module-type loader))
  (def module     (new type module-name name))
  (def env        (fab-static-global-environment module loader #f))
  (def keepmod?   #f)
  (def modpath       (module-name-to-relpath name))
  (def file (find-goo-file-in-path modpath *module-search-path*))
  (set-module-environments module env env)
  (if (not file)
      (error "Unable to find module %s" modpath))
  (fin
    (seq
      (install-initial-bindings env loader)
      (dlet ((*now-rt-env* env))
        (load-in file env))
      ;; Turn on foreign name support once the code has been loaded.
      (set (environment-allows-foreign-names? env) #t)
      (set keepmod? #t)
      module)
        ;;; Tricky unwind handler.  Our module may have altered the the state
        ;;; of other modules, and so we need to back these changes out if we
        ;;; crash midway.  This would look much nicer if we had some kind of
        ;;; try/catch/rethrow construct.
        ;;; TODO - This is much less necessary than before, since we already
        ;;; handle rollbacks for the actual compilation process using a
        ;;; subtransaction.  But there may still be errors /executing/
        ;;; the code, and we choose to apply a module rollback if that code
        ;;; fails.  Is this the right thing?  Hmmm.
    (unless keepmod?
      (roll-back-transaction (module-transaction module)))))
      
(dv *runtime-module-loader* (new <runtime-module-loader>))
(df runtime-module-loader () *runtime-module-loader*)
(df runtime-module (modname|<sym>)
  (probe-module (runtime-module-loader) modname))
(df runtime-environment (modname|<sym>)
  (def module (runtime-module modname))
  (ensure-module-data module)
  (module-target-environment module))
(df runtime-core-environment (modname|<sym>)
  (module-target-environment (runtime-module modname)))
(df unchecked-runtime-environment (modname|<sym>)
  (def loader (runtime-module-loader))
  (if (== (elt-or (module-loader-stack loader) 0 #f) modname)
      *now-rt-env*
      (module-target-environment (runtime-module modname))))

;;; RELOADER METHODS FOR %BUILD-RUNTIME-MODULES
;;; These are called to reload modules which were compiled into our runtime.

(df reloader-do-create-module (modname|<str> data => <module>)
  (def loader (runtime-module-loader))
  (def type   (module-loader-module-type loader))
  (def mod    (new type module-name (as <sym> modname)))
  (def env    (fab-static-global-environment mod loader #t))
  (set (module-data-processed? mod) #f)
  (set-module-environments mod env env)
  (set (module-runtime-data mod) data)
  (register-module! loader mod)
  mod)

(df reloader-do-use-module (mod|<module> uses|<module>)
  (push! (environment-uses-modules (module-target-environment mod)) uses))

(df reloader-do-import (mod|<module> name|<str>
                        from-mod|<module> original-name|<str>)
  (def home-env (module-target-environment from-mod))
  (def binding  (find-binding (as <sym> original-name) home-env))
  ;; TODO - Add support for using 'name'.
  (when (not binding)
    (error "Can't find %s from %s for %s\n"
           original-name (module-name from-mod) (module-name mod)))
  (insert-global! binding (module-target-environment mod)))

(df process-module-data (module|<module>)
  (%process-module 
   (module-runtime-data module) 
   reloader-do-import reloader-do-export))

(df ensure-module-data (module|<module>)
  (unless (module-data-processed? module)
    ;; TODO: DETECT CIRCULARITIES?
    (set (module-data-processed? module) #t)
    (process-module-data module)))

(df reloader-do-runtime-binding (mod|<module> name|<str> loc|<loc>)
  (def binding (new <module-binding>
                 binding-kind        'runtime
                 binding-module-name (module-name mod)
                 binding-name        (as <sym> name)
                 binding-free?       #f
                 binding-locative    loc))
  (insert-global! binding (module-target-environment mod)))

;;; We create all non-runtime bindings with type 'global', so we have
;;; something to export and import while rebuilding the module structure.
;;; Later on, we'll need to update these bindings and change
;;; their types using ast-define-binding.
(df reloader-do-other-binding (mod|<module> name|<str>)
  (def binding (new <module-binding>
                 binding-kind        'predefined;; HACK: JB
                 binding-module-name (module-name mod)
                 binding-name        (as <sym> name)
                 binding-free?       #t))
  (insert-global! binding (module-target-environment mod)))

(df reloader-do-export (mod|<module> name|<str> as-name|<str>)
  (def binding (find-binding (as <sym> name) (module-target-environment mod)))
  (if binding
      (export-binding! mod (as <sym> as-name) binding)
      (error "Can't find %s in %s\n" name (module-name mod))))


(df reload-modules ()
  (%build-runtime-modules 
   reloader-do-create-module reloader-do-use-module
   reloader-do-runtime-binding reloader-do-other-binding))

;;; Change the type of the magic bindings in an environment, and install
;;; the right handlers.  We only need to do this for the boot environment,
;;; because all the other modules have already imported these same binding
;;; objects, as described in reloader-do-other-binding.
(df install-magic-bindings (env)
  (do
   (fun (binding)
     (def clone (ast-define-binding env (binding-name binding) #f 'magic))
     (set (binding-handler clone) (binding-handler binding)))
   (magic-bindings)))

;;; Reload the macros, and change their appropriate binding types.
(df reload-macros ()
  (do3 (rcurry %%macro #f)
       *boot-macro-module-names*
       *boot-macro-names*
       *boot-macro-expanders*)
  (set *macros-ok?* #t))

(df install-interpreter-hacks (env)
  (init-environment-for-eval env))

(df init-runtime ()
  (reload-modules)
  (def bootmod (probe-module (runtime-module-loader) $goo-boot-module-name))
  (def bootenv (module-target-environment bootmod))
  ;; We need to make a bunch of changes to bindings the boot module,
  ;; which will affect all the modules that use those bindings.
  (install-magic-bindings bootenv)
  (reload-macros)
  (install-interpreter-hacks bootenv)
  #f)


;;;;=======================================================================
;;;;  g2c Environments 
;;;;=======================================================================
;;;;  TODO - Figure out what APIs we should export to allow this code to
;;;;  live in g2c.

;; These bindings are initially available in CT and DS forms.
;; The section numbers refer to DOC/DOC.TXT.
(dv syntax-environment-excluded-bindings
  '(CT CT-ALSO DS USE EXPORT))

;; Create a new syntax environment for processing macros.
(df fab-syntax-environment (module|<module> => <static-global-environment>)
  (fab-subset-environment module
                          (runtime-module 'goo)
                          syntax-environment-excluded-bindings))

(df fab-g2c-module (loader|<module-loader> name|<sym> => <module>)
  (def type       (module-loader-module-type loader))
  (def module     (new type module-name name))
  (def syntax-env (fab-syntax-environment module))
  (def target-env (fab-static-global-environment module loader #f))
  (set-module-environments module syntax-env target-env)
  (if (== name $goo-boot-module-name)
      (init-g2c-boot-environment target-env)
      (init-g2c-regular-environment target-env loader))
  module)

(export fab-g2c-module)

(df init-g2c-boot-environment (env|<static-global-environment>)
  ;; Copy in just our macros, since everything else
  ;; must be defined by the program being compiled.  And don't bother
  ;; to call 'init-environment-for-eval'--this is a compile-only environment.
  (insert-globals! (magic-bindings) env))
  
(df init-g2c-regular-environment (env|<static-global-environment>
                                  loader|<module-loader>)
  (install-initial-bindings env loader))


;;;;=======================================================================
;;;;  Other Environment Code
;;;;=======================================================================

(df init-ast ()
  (init-runtime))

;; Given a static global environment 'env', apply 'f' to all the bindings.
(df do-static-global-bindings (f|<fun> env|<static-global-environment>)
  (rep loop ((env env))
    (unless (isa? env <static-empty-environment>)
      (do f (frame-bindings env))
      (loop (environment-next env)))))

;; As above, but also supply the local name of the bindings.
(df do-named-static-global-bindings (f|<fun> env|<static-global-environment>)
  (rep loop ((env env))
    (unless (isa? env <static-empty-environment>)
      (do-keyed f (frame-bindings env))
      (loop (environment-next env)))))


;;;;=======================================================================
;;;;  Public API
;;;;=======================================================================

(need-implementation
  ast-evaluate
  init-environment-for-eval
  load-in)

(export
  <alternative>
  alternative-alternant
  alternative-condition
  alternative-consequent
  <application>
  application-arguments
  application-binding
  application-function
  application-known?
  application-known?-setter
  application-tail?
  <fab-list>
  <arguments>
  <assignment>
  assignment-binding
  assignment-form
  assignment-form-setter
  assignment-reference
  ast-define-binding
  find-binding
  <ast-function>
  <ast-generic>
  <ast-macro-definition>
  <free-environment>
  free-environment
  <ast-method>
  function-free 
  function-free-setter
  function-index
  function-index-setter
  function-self-recursive?
  function-self-recursive?-setter
  function-source
  function-source-setter
  function-temporaries
  function-temporaries-setter
  function-registers
  function-registers-setter
  function-data-refs
  function-data-refs-setter
  <ast-primitive>
  <ast-primitive-definition>
  <bind-exit>
  bind-exit-main-fun
  <binding>
  <module-binding>
  module-binding
  binding-kind
  binding-dynamic-extent?
  binding-dynamic-extent?-setter
  binding-index
  binding-index-setter
  binding-global-box
  binding-global-box-setter
  binding-locative
  binding-module-name
  binding-mutable?
  binding-name
  binding-type
  binding-type-setter
  binding-inferred-type
  binding-inferred-type-setter
  binding-info
  binding-info-setter
  binding-value
  binding-value-setter
  binding-dotted?
  binding-dotted?-setter
  <bound?>
  bound?-reference
  <compile-time>
  compile-time-program
  <constant>
  <immediate-constant>
  constant-value
  constant-index
  constant-index-setter
  <definition>
  def-list
  def-programs
  do-static-global-bindings
  do-named-static-global-bindings
  environment-bindings
  env-object-name
  environment-uses-modules
  <fix-let>
  fix-let-arguments
  fix-let-arguments-setter
  fix-let-types
  fix-let-types-setter
  fix-let-bindings
  fix-let-bindings-setter
  fix-let-body
  fix-let-body-setter
  <ast-signature>
  signature-names
  signature-names-setter
  signature-bindings
  signature-bindings-setter
  signature-specs
  signature-specs-setter
  signature-nary?
  signature-nary?-setter
  signature-arity
  signature-arity-setter
  signature-value
  signature-value-setter
  find-environment-module
  function-signature
  function-signature-setter
  function-bindings
  function-body
  function-body-setter
  function-binding
  function-debug-name
  function-debug-name-setter
  function-nary?
  function-value
  <global-assignment>
  <global-box>
  global-box-value
  global-box-value-setter
  <module-binding-reference>
  <global-reference>
  init-ast
  <local-assignment>
  <local-binding>
  <local-reference>
  <locals>
  locals-bindings
  locals-bindings-setter
  locals-body
  locals-body-setter
  locals-functions
  locals-functions-setter
  %%macro
  module-name
  module-exports
  <monitor>
  monitor-handler
  monitor-info
  monitor-main-thunk
  monitor-test
  monitor-type
  objectify-with-subtransaction
  objectify-quotation
  objectify-signature
  <predefined-application>
  <program>
  program-type
  program-type-setter
  <computed-program>
  <passive-program>
  program-register program-register-setter
  <programs>
  as-lst
  $goo-boot-module-name
  <raw-constant>
  <real-reference>
  <reference>
  reference-binding
  reference-called-function?
  reference-called-function?-setter
  reference-frame-number
  reference-frame-offset
  <regular-application>
  report-undefined-global-bindings
  <runtime-assignment>
  runtime-environment
  unchecked-runtime-environment
  <runtime-reference>
  <sequential>
  sequentialize
  <static-global-environment>
  environment-module
  <unwind-protect>
  unwind-protect-cleanup-thunk
  unwind-protect-protected-thunk)

