;;;; Copyright (c) 2001 Jonathan Bachrach
;;;; BASED ON Lisp In Small Pieces by Christian Queinnec

(dm objectify-error ((message <str>) (arguments ...))
  (apply error message arguments))

;;; programs

(dv <program> (isa <any>))
  (slot <program> (program-register <int>))
  (slot <program> program-type)

;;; Placeholders for world & module stuff.
;;; TODO - This is seriously broken.  It's just a starting point.
(dv <module-name> <sym>)
(df module-name-string ((name <module-name>) => <str>)
  (sym-name name))
(dv $internal-module-name 'proto/internal)
(df module-name (mod) $internal-module-name)

;;; bindings are not programs! they represent bindings.

(dv <binding-name> <any>) ;; (type-union <sym> <int>)

(dv <binding> (isa <any>))
  (slot <binding> (binding-name <binding-name>))
  (slot <binding> (binding-type <program>))

(dm binding-free? ((x <binding>) => <log>)
  #f)

;; TODO: RECONSIDER FOLLOWING?

(dm binding-free?-setter ((_ <log>) (x <binding>))
  _)

(dv <module-binding> (isa <binding>))
  (slot <module-binding> binding-module #f)

;; Global boxes are used by the interpreter to store the values of
;; global variables.
(dv <global-box> (isa <any>))
  (slot <global-box> global-box-value nul)

(dv <global-binding> (isa <module-binding>))
  (slot <global-binding> (binding-free? <log>) #t)
  (slot <global-binding> binding-global-box #f) ; TODO false-or <global-box>

(dv <runtime-binding> (isa <module-binding>))
  (slot <runtime-binding> (binding-locative <loc>))

(dv <predefined-binding> (isa <module-binding>))
  (slot <predefined-binding> binding-description #f)
  (slot <predefined-binding> binding-value       #f)

(dv <local-binding> (isa <binding>))
  (slot <local-binding> binding-value           #f)
  (slot <local-binding> binding-mutable?        #f)
  (slot <local-binding> binding-dynamic-extent? #t)
  (slot <local-binding> binding-dotted?         #f)

;; (dv <next-methods-binding> (isa <binding>))

;;; descriptions

(dv <description> (isa <any>))

(dv <functional-description> (isa <description>))
  (slot <functional-description> description-comparator)
  (slot <functional-description> description-arity)
  (slot <functional-description> description-generator)

(dv <constant-description> (isa <description>))
  (slot <constant-description> description-value)

;;; compile-time

(dv <compile-time> (isa <program>))
  (slot <compile-time> compile-time-program)

;;; references are programs.

(dv <reference> (isa <program>))

;;; special category of bindings

(dv <magic-binding> (isa (<global-binding> <reference>)))
  (slot <magic-binding> binding-handler)

(dv <macro-binding> (isa <magic-binding>))

;; DEAL WITH INITIALIZE

(dm reference-binding ((x <magic-binding>) => <magic-binding>)
  x)

(dv <real-reference> (isa <reference>))
  (slot <real-reference> reference-binding)

(dv <local-reference> (isa <real-reference>))
  (slot <local-reference> reference-called-function? #f)
  (slot <local-reference> (reference-frame-number <int>))
  (slot <local-reference> (reference-frame-offset <int>))

;; (dv <next-methods-reference> (isa <real-reference>))

(dv <global-reference> (isa <real-reference>))

(dv <runtime-reference> (isa <real-reference>))

(dv <predefined-reference> (isa <real-reference>))

(dv <bound?> (isa <program>))
  (slot <bound?> bound?-reference)

(dv <assignment> (isa <program>))
  (slot <assignment> assignment-form)

(dv <local-assignment> (isa <assignment>))
  (slot <local-assignment> assignment-reference)

(dv <global-assignment> (isa <assignment>))
  (slot <global-assignment> assignment-binding)

(dv <runtime-assignment> (isa <global-assignment>))

(dv <definition> (isa <global-assignment>))

(dv <variable-definition> (isa <definition>))

(dv <ast-generic-definition> (isa <definition>))

(dv <ast-function-definition> (isa <definition>))

(dv <ast-method-definition> (isa <definition>))

(dv <ast-primitive-definition> (isa <definition>))

(dv <ast-macro-definition> (isa <definition>))

(dv <ast-function> (isa <program>))
  (slot <ast-function> function-name #f)
  (slot <ast-function> function-bindings)
;;  (slot <ast-function> function-next-methods-binding)
  (slot <ast-function> function-nary? #f)
  (slot <ast-function> function-value #f)

(dm function-kind ((x <ast-function>)) "FUN")

(dv <ast-method> (isa <ast-function>))
  (slot <ast-method> function-body)

(dm function-kind ((x <ast-method>)) "MET")

(dv <ast-primitive> (isa <ast-method>))

(dm function-kind ((x <ast-primitive>)) "PRM")

(dv <ast-generic> (isa <ast-function>))

(dm function-kind ((x <ast-generic>)) "GEN")

(dv <alternative> (isa <program>))
  (slot <alternative> alternative-condition)
  (slot <alternative> alternative-consequent)
  (slot <alternative> alternative-alternant)

(dv <programs> (isa <program>))

(ds (def-list ,name (,@supers))
  (let ((class  (make-sym "<" name ">"))
	($empty (make-sym "$" name "-empty")))
    `(seq (dv ,class (isa (<lst> ,@supers)))
	  (dv ,$empty (isa ,class (set head #f) (set tail #f)))
	  (dm as ((p ,class) (x ,class) => <lst>) x)
	  (dm as ((p <lst>)  (x ,class) => <lst>) (apply lst x))
	  (dm as ((p ,class) (x <lst>) => <lst>) (apply fabs (pair ,class x)))
	  (df ,name (h t) (isa ,class (set head h) (set tail t)))
	  (dm empty ((e ,class) => ,class) ,$empty))))

(ds (def-programs ,name) `(def-list ,name (<programs>)))

(def-programs sequential)

(dv <constant> (isa <program>))
  (slot <constant> constant-value)

(dv <raw-constant> (isa <constant>))

(dv <application> (isa <program>))
  (slot <application> application-arguments)
  (slot <application> application-tail? #f)

(dv <regular-application> (isa <application>))
  (slot <regular-application> application-function)
  (slot <regular-application> application-known? #f)

(dv <predefined-application> (isa <application>))
  (slot <predefined-application> application-binding)

(dv <fix-let> (isa <program>))
  (slot <fix-let> fix-let-bindings)
  (slot <fix-let> fix-let-arguments)
  (slot <fix-let> fix-let-body)

(def-programs arguments)

(dm as ((c <lst>) (e <arguments>) => <lst>)
  (rep loop ((res '()) (e e))
    (if (empty? e)
	(rev! res)
	(loop (arguments res e)))))

(dv <locals> (isa <program>))
  (slot <locals> locals-bindings)
  (slot <locals> locals-functions)
  (slot <locals> locals-body)

(dv <bind-exit> (isa <program>))
  (slot <bind-exit> bind-exit-main-fun)

(dv <unwind-protect> (isa <program>))
  (slot <unwind-protect> unwind-protect-protected-thunk)
  (slot <unwind-protect> unwind-protect-cleanup-thunk)

(dv <monitor> (isa <program>))
  (slot <monitor> monitor-handler)
  (slot <monitor> monitor-main-thunk)

;;; ENVIRONMENT

(dv <static-environment> (isa <any>))
  (slot <static-environment> environment-next #f)
  (slot <static-environment> (environment-bindings <col>))

(dv <static-global-environment> (isa <static-environment>))
  ;; The environment in which CT and DS forms should be run.
  (slot <static-global-environment>
	(environment-syntax-environment <static-global-environment>))

(dv <static-empty-environment> (isa <static-environment>))

(dv $empty-static-environment (isa <static-empty-environment>))

(dv <static-local-environment> (isa <static-environment>))

;; Return true iff an environment is its own syntax environment.  This is
;; typically true for various eval'd environments, and false for compiled
;; environments.
(df environment-is-own-syntax-environment? ((env <static-global-environment>)
					    => <log>)
  (== env (environment-syntax-environment env)))

;; Given an object, try to find a global binding which contains it.
;; Used by the writer.
;; TODO - This will only work in the runtime environment, not any of the
;; various syntax environments.
(dm env-object-name (x => <any>)
  (lab return
    (do-static-global-bindings
     (fun (binding)
       (when (and (isa? binding <global-binding>)
                  (binding-global-box binding)
		  (== x (global-box-value (binding-global-box binding))))
	 (return (binding-name binding))))
     (runtime-environment))
    #f))


;;;; CONVERT TO AST FORM

(dm objectify ((e <lst>) (r <static-environment>) tail? => <any>)
  (if (isa? e <program>) ;; TODO: HACK FOR <PROGRAMS>
      e
      (objectify-list (objectify (head e) r #f) e r tail?)))

(dm objectify-list
    ((f <any>) (e <lst>) (r <static-environment>) tail? => <any>)
  (objectify-application f (tail e) r tail?))

(dm objectify-list
    ((f <magic-binding>) (e <lst>) (r <static-environment>) tail? => <any>)
  ((binding-handler f) e r tail?))

(dm objectify-list
    ((f <macro-binding>) (e <lst>) (r <static-environment>) tail? => <any>)
  (objectify ((binding-handler f) e r tail?) r tail?))

(dm objectify ((e <sym>) (r <static-environment>) tail? => <any>)
  (objectify-symbol e r))

(dm objectify ((e <magic-binding>) (r <static-environment>) tail? => <any>)
  e)

(dm objectify ((e <program>) (r <static-environment>) tail? => <any>)
  e)

(dm objectify ((e '()) (r <static-environment>) tail? => <any>)
  (objectify-quotation e r))

(dm objectify (e (r <static-environment>) tail? => <any>)
  (objectify-quotation e r))

(dm objectify-quotation (value r => <constant>)
  (isa <constant> (set constant-value value)))

(dm objectify-raw (value r => <raw-constant>)
  (isa <raw-constant> (set constant-value value)))

(dm objectify-bound? ((e <sym>) (r <static-environment>) tail? => <any>)
  (let ((ref (objectify-symbol e r)))
    (isa <bound?> (set bound?-reference ref))))

(dm objectify-compile-time (program r tail? => <constant>)
  (let ((syntax-env (find-syntax-environment r))
	(program (objectify program syntax-env tail?)))
    (ast-evaluate program)
    (isa <constant> (set constant-value #f))))

(dm objectify-alternative (t c a r tail? => <alternative>)
  (isa <alternative> 
       (set alternative-condition  (objectify t r #f))
       (set alternative-consequent (objectify c r tail?))
       (set alternative-alternant  (objectify a r tail?))))

(dm sequentialize ((e* <lst>) => <program>)
  (if (empty? e*)
      (isa <constant> (set constant-value #f))
      (if (empty? (tail e*))
	  (head e*)
	  (rep loop ((e* e*))
	    (if (empty? e*)
		(empty <sequential>)
		(sequential (head e*) (loop (tail e*))))))))

(dm objectify-sequential ((e* <lst>) r tail? => <program>)
  (let ((asts 
	 (rep loop ((res '()) (e* e*))
	   (if (empty? e*)
	       (rev! res)
	       (let ((tail? (if (empty? (tail e*)) tail? #f))
		     (head  (objectify (head e*) r tail?)))
		 (loop (pair head res) (tail e*)))))))
    (sequentialize asts)))

(dm objectify-application ((ff <ast-method>) e* r tail? => <program>)
  (let ((ee* (convert2arguments (map (fun (e) (objectify e r #f)) e*))))
    (process-closed-application ff ee* r tail?)))

;; TODO: USE THIS FOR PRIMITIVES

(dm objectify-application ((ff <predefined-reference>) e* r tail? => <program>)
  (let ((ee*  (convert2arguments (map (fun (e) (objectify e r #f)) e*)))
	(fvf  (reference-binding ff))
	(desc (binding-description fvf)))
    (isa <predefined-application> 
	 (set application-binding   fvf)
	 (set application-arguments ee*)
	 (set application-tail?     tail?))))

(dm objectify-application (ff e* r tail? => <program>)
  (let ((ee* (convert2arguments (map (fun (e) (objectify e r #f)) e*))))
    (isa <regular-application> 
	 (set application-function  ff) 
	 (set application-arguments ee*)
	 (set application-tail?     tail?))))

(dm process-closed-application ((f <ast-method>) e* r tail? => <fix-let>)
  (let ((v* (function-bindings f))
	(b  (function-body f)))
    (if (function-nary? f)
	(process-nary-closed-application f e* r tail?)
	(if (= (len e*) (len (function-bindings f)))
	    (isa <fix-let> 
		 (set fix-let-bindings  (function-bindings f))
		 (set fix-let-arguments e*)
		 (set fix-let-body      (function-body f)))
	    (objectify-error "incorrect regular arity" f e*)))))

(dm process-nary-closed-application (f e* r tail? => <fix-let>)
  (loc ((pack-nary-args (e*) ;; TODO: COULD BE SHARED WITH PAIRIZE
	   (if (empty? e*)
	       (lst 'quote '())
	       (lst '%pair (head e*) (pack-nary-args (tail e*)))))
        (gather-arguments (e* v*)
	  (if (binding-dotted? (head v*))
	      (arguments (objectify (pack-nary-args e*) r #f) 
			 (empty <arguments>))
	      (if (empty? e*)
		  (objectify-error "incorrect dotted arity" f e*)
		  (arguments 
		   (head e*) (gather-arguments (tail e*) (tail v*)))))))
   (let ((v* (function-bindings f))
	 (b  (function-body f))
	 (o  (isa <fix-let> 
		  (set fix-let-bindings  v*)
		  (set fix-let-arguments (gather-arguments e* v*))
		  (set fix-let-body      b))))
     (set (binding-dotted? (last v*)) #f)
     o)))
 
(dm convert2arguments ((e* <lst>) => <any>)
  (if (empty? e*)
      (empty <arguments>)
      (arguments (head e*) (convert2arguments (tail e*)))))

;;; assignment on mutable local bindings are immediately
;;; processed. references to local mutable bindings must wait the
;;; second pass.

(dm objectify-assignment ((binding <lst>) e r tail? => <program>)
  (let ((op (sexpr-operator binding)))
    (if (sexpr-variable? op)
	(objectify
	 (sexpr-make-application
	  (objectify (sexpr-make-setter-name op) r #f) 
	  (pair e (sexpr-operands binding)))
	 r tail?)
	(objectify-error "Unsupported Set!: %=" e))))

(dm objectify-assignment ((binding <sym>) e r tail? => <assignment>)
  (let ((ref (objectify binding r #f))
	(val (objectify e r #f)))
    (objectify-assignment-using ref val)))

(dm objectify-assignment-using 
    ((ref <local-reference>) (val <program>) => <local-assignment>)
 (set (binding-mutable? (reference-binding ref)) #t)
 (isa <local-assignment> 
   (set assignment-reference ref)
   (set assignment-form      val)))

(dm objectify-assignment-using 
    ((ref <global-reference>) (val <program>) => <global-assignment>)
 (isa <global-assignment> 
   (set assignment-binding (reference-binding ref))
   (set assignment-form    val)))

(dm objectify-assignment-using 
    ((ref <runtime-reference>) (val <program>) => <runtime-assignment>)
 (isa <runtime-assignment> 
   (set assignment-binding (reference-binding ref))
   (set assignment-form    val)))

;; TODO: HANDLE REDEF

(dm ast-define-binding (r name shadow? make-binding => <any>)
  (let ((existing-binding (find-binding name r))
	(gr (find-static-global-environment r))
	(binding
	 (if (and existing-binding 
		  (or (not shadow?) (== (binding-module existing-binding) gr)))
	     (seq (if (binding-free? existing-binding)
		      (set (binding-free? existing-binding) #f)
		      ;; (format out "REDEF %s\n" name)
		      )
		  existing-binding)
	     (let ((binding (make-binding)))
	       (set (binding-name binding)   name)
	       (set (binding-free? binding)  #f)
	       (set (binding-module binding) gr)
	       (insert-global! binding gr)
	       binding))))
    binding))

(dv *macro-tracing?* #f)

(dm objectify-definition (var e r => <any>)
  (let ((name
	 (sexpr-variable-name var))
	(binding 
	 (ast-define-binding r name #f (fun () (isa <global-binding>))))
	(defn
	 (isa <definition> 
	   (set assignment-binding binding)
	   (set assignment-form (objectify e r #f)))))
    defn))

(dv *shadow-macros?* #f)

(df %%macro (name expander r => <macro-binding>)
  ;; (format out "DEFMACRO ") (writeln out sep-expander)
  (loc ((expand (x r tail?)
	  (when *macro-tracing?*
	    (format out "MACRO ") (write out x) (format out "\n"))
	  (let ((exp (apply expander (lst x))))
	    (when *macro-tracing?*
	      (format out "  => ") (write out exp) (format out "\n"))
	    exp)))
    ;; (format out "DEFMAC %=\n" name)
    (let ((binding 
	   (ast-define-binding
	    r name *shadow-macros?* (fun () (isa <macro-binding>)))))
      (set (binding-handler binding) expand)
      binding)))

;; Process a macro definition.  This is somewhat ugly, because a single
;; macro definition may need to appear in as many as three places:
;;  1) The target environment, so it may be used by the program itself.
;;  2) The syntax environment, so it can be used to write other macros.
;;  3) The runtime environment *of the image we're building*.  This
;;     means that once our program has been compiled and run, macros
;;     should remain available in the listener.  This requires some magic,
;;     which is handled by <ast-macro-definition>.
;; XXX - This function has very ugly semantics, and I don't like it.
(dm objectify-syntax-definition (name e r rt? => <any>)
  (let ((sep-expander (sexpr-make-macro-function e))

	;; Build a version of the macro for use in the target and syntax
	;; environments.
	(syntax-env   (find-syntax-environment r))
	(ast-expander (objectify sep-expander syntax-env #f))
	(expander     (ast-evaluate ast-expander))

	;; Install it into the target environment.
	(binding (%%macro name expander r)))

    ;; If the syntax and runtime environments are different (i.e., we're
    ;; compiling code), then install it in the syntax environment, too.
    (when (not (environment-is-own-syntax-environment? r))
      (insert-global! binding syntax-env))
    
    ;; If the macro should be available in the runtime of the image we're
    ;; building, work some magic.  Otherwise, just return false.
    (if rt?
	(isa <ast-macro-definition> 
	  (set assignment-binding binding)
	  (set assignment-form
	       ;; Re-objectify the expander, this time using bindings from
	       ;; the target environment.  This should allow it to be run
	       ;; in the image (if we're reasonably lucky).
	       (objectify sep-expander r #f)))
	(objectify-quotation #f r))))
  
(dm objectify-function-definition (name e r => <ast-function-definition>)
  (let ((binding (ast-define-binding r name #f (fun () (isa <global-binding>))))
	(f       (objectify e r #f)))
    (set (function-name f) binding)
    (let ((defn (isa <ast-function-definition>
		     (set assignment-binding binding)
		     (set assignment-form f))))
      defn)))

(dm objectify-primitive-definition 
    (name sig body r => <ast-primitive-definition>)
  (let ((binding
	 (ast-define-binding r name #f (fun () (isa <predefined-binding>))))
	;; TODO: MULTIPLE VALUES
	((tup bindings nary? value)
	 (objectify-signature sig r))
	(body
	 (objectify-sequential body (r-extend* r bindings) #t))
	(form
	 (isa <ast-primitive> 
	      (set function-name binding)
	      (set function-bindings bindings)
	      (set function-nary? nary?)
	      (set function-value value)
	      (set function-body body))))
    (set (binding-description binding) form)
    (let ((defn
	   (isa <ast-primitive-definition>
		(set assignment-binding binding)
		(set assignment-form form))))
      defn)))

(dm objectify-generic-definition (name sig r => <ast-generic-definition>)
  (let ((binding
	 (ast-define-binding r name #f (fun () (isa <global-binding>))))
	((tup bindings nary? value)
	 (objectify-signature sig r))
	(form
	 (isa <ast-generic>
	      (set function-name binding)
	      (set function-bindings bindings)
	      (set function-nary? nary?)
	      (set function-value value)))
	(defn
	  (isa <ast-generic-definition>
	       (set assignment-binding binding)
	       (set assignment-form form))))
    defn))

(dm objectify-method-definition (name e r => <ast-method-definition>)
  (let ((binding (ast-define-binding r name #f (fun () (isa <global-binding>))))
	(gen     (lst 'if (lst 'bound? name) name #f))
	(met     (objectify e r #f))
	;; TODO: NAME AND MARK AS GENERIC METHOD
	(call    (lst '%define-method gen met))
	(form    (objectify call r #f))
	(defn    (isa <ast-method-definition>
		      (set assignment-binding binding)
		      (set assignment-form form))))
    (set (function-name met) name)
    defn))

;;; it is important that the body is objectified first so mutability
;;; of local bindings is known and they can be appropriately handled
;;; in objectify-bindings-list. 
;;; all bindings are considered immutable at the beginning.

(dm objectify-function (sig body r tail? => <ast-method>)
  (let (((tup bindings nary? value) (objectify-signature sig r))
	(b (objectify-sequential body (r-extend* r bindings) #t)))
    (isa <ast-method> 
	 (set function-bindings bindings)
	 (set function-nary? nary?)
	 (set function-value value)
	 (set function-body b))))

(dv $sexpr-optionals-tag       '...)
(dv $sexpr-optionals-type-name '<opts>)

;; TODO: MULTIPLE VALUES

(dm objectify-signature
    (sig r => (tup (bindings <lst>) (nary? <log>) (value <any>)))
  (rep col ((params (sexpr-signature-parameters sig)) (nary? #f) (bindings '()))
    (if (empty? params)
	(let ((sexpr-value (sexpr-signature-value sig))
	      (value (objectify (or sexpr-value (default-type r)) r #f)))
	  (tup (rev! bindings) nary? value))
	(let ((param   (head params))
	      (sname   (sexpr-variable-name param))
	      (stype   (sexpr-variable-type param))
	      (dotted? (== stype $sexpr-optionals-tag))
	      (stype   (if dotted? $sexpr-optionals-type-name stype))
	      (type    (objectify stype r #f))
	      (binding
	       (isa <local-binding>
		    (set binding-name sname)
		    (set binding-type type)
		    (set binding-dotted? dotted?))))
	  (col (tail params) dotted? (pair binding bindings))))))

(dm objectify-binding (n (b <magic-binding>) r => <magic-binding>)
  b)

(dm compute-local-reference-offsets 
    ((binding <local-binding>) (r <static-local-environment>) 
     => (tup (frame-number <int>) (frame-offset <int>)))
 (rep loop ((i 0) (r r))
   (if (isa? r <static-local-environment>)
       (rep find ((j 0) (bindings (environment-bindings r)))
	 (if (empty? bindings)
	     (loop (+ i 1) (environment-next r))
	     (if (== (head bindings) binding)
		 (tup i j)
		 (find (+ j 1) (tail bindings)))))
       (error "DIDN'T FIND LOCAL BINDING %= IN %=" (binding-name binding) r))))

(dm objectify-binding (n (b <local-binding>) r => <local-reference>)
  (let (((tup i j) (compute-local-reference-offsets b r)))
    (isa <local-reference>
      (set reference-binding b)
      (set reference-frame-number i)
      (set reference-frame-offset j))))

;; (dm objectify-binding 
;;     (n (b <next-methods-binding>) r => <next-methods-reference>)
;;   (isa <next-methods-reference> (set reference-binding b)))

(dm objectify-binding (n (b <global-binding>) r => <global-reference>)
  (isa <global-reference> (set reference-binding b)))

(dm objectify-binding (n (b <runtime-binding>) r => <runtime-reference>)
  (isa <runtime-reference> (set reference-binding b)))

(dm objectify-binding (n (b <predefined-binding>) r => <predefined-reference>)
  (isa <predefined-reference> (set reference-binding b)))

;;; a free binding is defined to be a global binding defined on the fly.

(dm default-type (r) 
  (objectify '<Any> r #f))

(dm objectify-free-global-reference (name r => <global-reference>)
  (let ((gr (find-static-global-environment r))
	(b (isa <global-binding>
	     (set binding-name name))))
    (insert-global! b gr)
    (isa <global-reference> (set reference-binding b))))

(dm objectify-binding (n b r => <reference>)
  (objectify-free-global-reference n r))

(dm objectify-symbol (name r => <reference>)
  (objectify-binding name (find-binding name r) r))

(dm ftype (r)
  (objectify '<fun> r #f))

(def-programs functions)

(dm objectify-locals (names sigs bodies body r tail? => <locals>)
  (let ((bindings
	 (map (fun (n) (isa <local-binding> 
			    (set binding-name n) (set binding-type (ftype r))))
	      names))
	(new-r
	 (r-extend* r bindings))
	(function-forms
	 (map2 sexpr-make-anonymous-method sigs bodies))
	(functions 
	  (map (rcurry objectify new-r #f) function-forms)))
    ;; TODO: CIRCULARITIES IN AST
    (do2 (fun (f b) (set (function-name f) b) (set (binding-value b) f)) 
	 functions bindings)
    (isa <locals>
	 (set locals-bindings  bindings)
	 (set locals-functions (apply fabs (pair <functions> functions)))
	 (set locals-body      (objectify-sequential body new-r #t)))))

(dm objectify-bind-exit (name body r tail? => <bind-exit>)
  (isa <bind-exit>
       (set bind-exit-main-fun 
	    (objectify (sexpr-make-anonymous-method (lst name) body) r #f))))

(dm objectify-unwind-protect
    (protected-form cleanup-forms r tail? => <unwind-protect>)
  (isa <unwind-protect>
       (set unwind-protect-protected-thunk
	    (objectify
	     (sexpr-make-anonymous-method '() (lst protected-form)) r #f))
       (set unwind-protect-cleanup-thunk
	    (objectify
	     (sexpr-make-anonymous-method '() cleanup-forms) r #f))))

(dm objectify-monitor (handler body r tail? => <monitor>)
  (isa <monitor>
       (set monitor-handler    
	    (objectify handler r #f))
       (set monitor-main-thunk
	    (objectify (sexpr-make-anonymous-method '() body) r #f))))

(dm expand-bind-list (pat var fail => <any>)
  (error "Expected Pattern List %=\n" pat))

(dm expand-bind-list ((pat '()) var fail => <lst>)
  `(match-empty-list ,var ,fail))

(dm expand-bind-list ((pat <lst>) var fail => <lst>)
  (case
    ((sexpr-unquote? pat)
      (error "Unquote Unexpected Here %=\n" pat))
    ((sexpr-unquote-splicing? pat)
     (error "Unquote Splicing Unexpected Here %=\n" pat))
    (#t
     (expand-bind-list* pat var fail))))

(dm expand-bind-list* ((pat '()) var fail => <any>)
  `(match-empty-list ,var ,fail))

(dm expand-bind-list* ((pat <lst>) var fail => <any>)
  `(let ((,var ,(expand-bind-element (head pat) var fail)))
     ,(expand-bind-list* (tail pat) var fail)))

(dm expand-bind-element (pat var fail => <any>)
  `(match-atom ,var ',pat ,fail))

(dm expand-bind-element ((pat <lst>) var fail => <any>)
  (case
    ((sexpr-unquote? pat)
     `(seq (set ,(2nd pat) (match-unquote ,var ,fail)) (tail ,var)))
    ((sexpr-unquote-splicing? pat)
     `(seq (set ,(2nd pat) ,var) '()))
    (#t
     `(seq (let ((,var (match-sublist ,var ,fail)))
	     ,(expand-bind-list pat var fail))
	   (tail ,var)))))

(dm expand-pattern ((pat <lst>) var fail => <any>)
  `(if (isa? ,var <lst>)
       ,(expand-bind-list pat var fail)
       (,fail "Match Pattern Failure" ,var)))

(dm expand-syntax-if ((x <lst>) => <lst>)
  (let ((pat   (sexpr-syntax-if-pattern x))
	(vars  (sexpr-bind-pattern-variables pat))
	(value (sexpr-syntax-if-value x))
	(then  (sexpr-syntax-if-then x))
	(else  (sexpr-syntax-if-else x))
	(var   (gensym))
	(fail  (gensym))
	(epat  (expand-pattern pat var fail)))
    `(lab return
       (loc ((,fail ((msg <str>) (args ...)) (return ,else)))
	 (let ((,var ,value))
	   (let ,(map (fun (x) `(,x #f)) vars)
	     ,epat
	     ,then))))))

;;; AST ENVIRONMENT

;;; these functions deal with the environment.  r is a sequential of
;;; full-environment objects containing local bindings followed by an
;;; instance of environment followed by a sequential of full-environment
;;; containing the global mutable bindings mixed with the global
;;; macros followed by the predefined bindings.

(dm r-extend* (r (bindings <lst>) => <static-environment>)
  (isa <static-local-environment> 
    (set environment-next r)
    (set environment-bindings bindings)))

(dm insert-global! (binding r)
  (let (((r <static-global-environment>) (find-static-global-environment r)))
    (set (elt (environment-bindings r) (binding-name binding)) binding)))

(dm insert-globals! ((bindings <lst>) r) 
  (do (fun (b) (insert-global! b r)) bindings))

(dm find-static-global-environment 
    ((r <static-local-environment>) => <static-global-environment>)
  (find-static-global-environment (environment-next r)))

(dm find-static-global-environment
    ((r <static-global-environment>) => <static-global-environment>)
  r)

(dm find-syntax-environment ((r <static-environment>)
			     => <static-global-environment>)
  (environment-syntax-environment (find-static-global-environment r)))

(dm find-binding (name (r <static-local-environment>) => <any>)
  (rep loop ((bindings (environment-bindings r))) ;; TODO: => (or <binding> #f)
    (if (empty? bindings)
	(find-binding name (environment-next r))
	(if (== name (binding-name (head bindings)))
	    (head bindings)
	    (loop (tail bindings))))))

;; TODO: => FALSE-OR <BINDING>

(dm find-binding (name (r <static-empty-environment>) => <any>)
  #f)

(dm find-binding (name (r <static-global-environment>) => <any>) 
  (let ((binding (elt (environment-bindings r) name)))
    (if (== binding nul)
	(find-binding name (environment-next r))
	binding)))

;; TODO: CLEANUP

(dm frame-bindings ((env <static-environment>) => <col>)
  ;; (as <lst> (map identity (environment-bindings env)))
  (environment-bindings env))

(df report-undefined-global-bindings (env)
  (let ((env (find-static-global-environment env)))
    (rep loop ((env env))
      (unless (isa? env <static-empty-environment>)
        (do (fun (binding)
	      (if (binding-free? binding)
		  (format out "%= UNDEFINED\n" (binding-name binding))))
	    (frame-bindings env))
	(loop (environment-next env))))))

;;;; SPECIAL FORMS

(dv *magic-bindings* '())

(dm register-magic-binding (name value)
  (set *magic-bindings* (add *magic-bindings* value)))

(dm magic-bindings ()
  *magic-bindings*)

(ds (define-magic-binding ,name (,@params) ,@body)
  (let ((special-name (make-sym "special-" name))
	(sexpr-name   (make-sym "$sexpr-" name "-tag")))
    `(seq (dv ,special-name
	       (isa <magic-binding>
		    (set binding-name    ,sexpr-name)
		    (set binding-handler (fun (,@params) ,@body))
		    (set binding-free?   #f)))
	  (register-magic-binding ',name ,special-name))))

(define-magic-binding if (x r tail?)
  (objectify-alternative
    (sexpr-if-test x) (sexpr-if-then x) (sexpr-if-else x) r tail?))

(define-magic-binding begin (x r tail?)
  (objectify-sequential (tail x) r tail?))

(dv $sexpr-%raw-tag '%raw)

(define-magic-binding %raw (x r tail?)
  (objectify-raw (2nd x) r))

(define-magic-binding quote (x r tail?)
  (objectify-quotation (sexpr-text-of-quotation x) r))

(define-magic-binding set (x r tail?)
  (objectify-assignment
    (sexpr-assignment-variable x) (sexpr-assignment-value x) r tail?))

(define-magic-binding define (x r tail?)
  (objectify-definition
    (sexpr-definition-variable x) (sexpr-definition-value x) r))

(define-magic-binding define-syntax (x r tail?)
  (objectify-syntax-definition
    (sexpr-syntax-definition-variable x) (sexpr-syntax-definition-value x) r #t))

(dv $sexpr-define-static-syntax-tag 'dss)

(define-magic-binding define-static-syntax (x r tail?)
  (objectify-syntax-definition
    (sexpr-syntax-definition-variable x) (sexpr-syntax-definition-value x) r #f))

(define-magic-binding define-method (x r tail?)
  (objectify-method-definition
    (sexpr-function-definition-variable x) 
    (sexpr-function-definition-value x) r))

(define-magic-binding define-generic (x r tail?)
  (objectify-generic-definition
    (sexpr-function-definition-variable x) (sexpr-function-signature x) r))

(define-magic-binding define-function (x r tail?)
  (objectify-function-definition
    (sexpr-function-definition-variable x) 
    (sexpr-function-definition-value x) r))

(define-magic-binding method (x r tail?)
  (objectify-function
    (sexpr-method-signature x) (sexpr-method-body x) r tail?))

(dv $sexpr-bound?-tag 'bound?)

(define-magic-binding bound? (x r tail?)
  (objectify-bound? (2nd x) r tail?))

(define-magic-binding let (x r tail?)
  (objectify (sexpr-let->combination x) r tail?))

(define-magic-binding locals (x r tail?)
  (objectify-locals
    (sexpr-loc-bound-names x) (sexpr-loc-bound-signatures x) 
    (sexpr-loc-bound-bodies x) (sexpr-loc-raw-body x) r tail?))

(define-magic-binding iterate (x r tail?)
  (objectify (sexpr-iterate->loc x) r tail?))

(define-magic-binding bind-exit (x r tail?)
  (objectify-bind-exit (sexpr-block-name x) (sexpr-block-body x) r tail?))

(define-magic-binding unwind-protect (x r tail?)
  (objectify-unwind-protect
    (sexpr-unwind-protect-protected-form x) 
    (sexpr-unwind-protect-cleanup-forms x)
    r tail?))

(define-magic-binding monitor (x r tail?)
  (objectify-monitor
   (sexpr-monitor-handler x) (sexpr-monitor-body x) r tail?))

(dm pairize ((args <lst>) => <any>)
  (if (empty? args)
      (lst 'quote '())
      (lst '%pair (head args) (pairize (tail args)))))

(define-magic-binding isa (x r tail?)
  (let ((slot-inits (sexpr-isa-slot-inits x)))
    (objectify
     (sexpr-make-application
       '%isa
       (lst (pairize (sexpr-isa-parents x))
	    (pairize (sexpr-isa-init-slots slot-inits))
	    (pairize (sexpr-isa-init-values slot-inits))))
     r tail?)))

(define-magic-binding slot (x r tail?)
  (let ((var         (sexpr-slot-variable x))
	(name        (sexpr-variable-name var))
	(setter-name (sexpr-make-setter-name name))
	(slot-type   (sexpr-variable-type var)))
    (objectify
     (sexpr-make-begin
      (lst (sexpr-make-getter name (sexpr-slot-object x))
	   (sexpr-make-setter name (sexpr-slot-object x) slot-type)
	   (sexpr-make-application
	     '%slot
	     (lst (sexpr-slot-object x) 
		  name setter-name slot-type
		  (sexpr-make-anonymous-method
		   '((x <any>)) (lst (sexpr-slot-init x)))))))
     r tail?)))
			    
(dv $sexpr-compile-time-tag 'ct)

(define-magic-binding compile-time (x r tail?)
  (objectify-compile-time (head (tail x)) r tail?))

(dv $sexpr-define-primitive-tag 'dp)

(define-magic-binding define-primitive (x r tail?)
  (if (sexpr-forward-primitive? x)
      (seq (ast-define-binding
	    r (sexpr-function-definition-variable x) #f
	    (fun () (isa <predefined-binding>)))
	   (objectify #f r tail?))
      (objectify-primitive-definition
       (sexpr-function-definition-variable x) 
       (sexpr-function-signature x) (sexpr-function-body x) r)))

(define-magic-binding quasiquote (x r tail?)
  (objectify (sexpr-expand-backquote x) r tail?)))

(dm ast-macro-expand (x r tail?)
  (let ((m (objectify (head x) r tail?)))
    (if (isa? m <magic-binding>)
	(let ((res ((binding-handler m) x r tail?)))
	  ;; (format out "EXPANSION ") (write out res) (format out "\n")
	  res)
	#f)))

(define-magic-binding macro-expand (x r tail?)
  (objectify-quotation
    (ast-macro-expand (2nd x) r tail?) r))

(define-magic-binding syntax-if (x r tail?)
  ;; (syntax-if (?pattern ?value) ?form ...)
  ;; x   => just matches etc
  ;; x  => binds x to an sexpr
  ;; @x => binds x to a series of sexprs
  ;; TODO: make this deals with multiple bindings
  (objectify (expand-syntax-if x) r tail?))

(dv *primitives* '())

(dm primitives ()
  *primitives*)

(dm register-primitive (value)
  (set *primitives* (pair value *primitives*)))

(ds (define-primitive ,name (,@params))
  `(let ((binding
	  (isa <predefined-binding> (set binding-name ',name))))
	  ;; (isa <magic-binding> (set binding-name ',name) (set binding-free? #f))
     (register-primitive binding)))

(define-primitive %eq? ())
(define-primitive %bb ())
(define-primitive %i= ())
(define-primitive %i< ())
(define-primitive %i+ ())
(define-primitive %i- ())
(define-primitive %i* ())
(define-primitive %im ())
(define-primitive %ir ())
(define-primitive %it/ ())
(define-primitive %iv ())
(define-primitive %i^ ())
(define-primitive %i& ())
(define-primitive %i! ())
(define-primitive %i? ())
(define-primitive %i<< ())
(define-primitive %i>> ())
(define-primitive %i<<< ())
(define-primitive %i>>> ())
(define-primitive %fi2f ())
(define-primitive %f= ())
(define-primitive %f< ())
(define-primitive %f+ ())
(define-primitive %f* ())
(define-primitive %f- ())
(define-primitive %f/ ())
(define-primitive %ft ())
(define-primitive %ft/ ())
(define-primitive %ff ())
(define-primitive %fc ())
(define-primitive %flo-bits ())
(define-primitive %c= ())
(define-primitive %c< ())
(define-primitive %current-output-port ())
(define-primitive %current-input-port ())
(define-primitive %open-input-file ())
(define-primitive %open-output-file ())
(define-primitive %close-output-port ())
(define-primitive %close-input-port ())
(define-primitive %write-char ())
(define-primitive %write-string ())
(define-primitive %force-output ())
(define-primitive %char-ready? ())
(define-primitive %read-char ())
(define-primitive %newline ())
(define-primitive %eof-object ())
(define-primitive %eof-object ())
(define-primitive %peek-char ())
(define-primitive %char-ready ())
(define-primitive %object-traits ())
(define-primitive %object-traits-setter ())
(define-primitive %object-values ())
(define-primitive %object-values-setter ())
(define-primitive %raw-alloc ())
(define-primitive %make-object ())
(define-primitive %clone ())
(define-primitive %slot-elt ())
(define-primitive %slot-elt-setter ())
(define-primitive %make-object-values ())
(define-primitive %install-object-values ())
(define-primitive %adjust-object-values-size ())
(define-primitive %elt ())
(define-primitive %elt-setter ())
(define-primitive %%slen ())
(define-primitive %%selt ())
(define-primitive %%selt-setter ())
(define-primitive %%sfab ())
(define-primitive %%vlen ())
(define-primitive %%velt ())
(define-primitive %%velt-setter ())
(define-primitive %%vfab ())

(define-primitive %app-filename ())
(define-primitive %app-args ())

(define-primitive %locative-value ())
(define-primitive %locative-value-setter ())
(define-primitive %invoke-debugger ())

(define-primitive %os-name ())
(define-primitive %os-binding-value ())
(define-primitive %os-binding-value-setter ())

(define-primitive %break ())
(define-primitive %binding-name ())
(define-primitive %fun-reg ())

(define-primitive %trace-on ())
(define-primitive %trace-off ())

(define-primitive %%apply ())
(define-primitive %%mep-apply ())
(define-primitive %next-methods ())
(define-primitive %fapply ())

(define-primitive %do-runtime-bindings ())
(define-primitive %do-stack-frames ())

(define-primitive %pair ())


;;;========================================================================
;;;  Set Up Initial Environments for Objectification
;;;========================================================================
;;;  To objectify code, we need to look up variables in a global
;;;  environment.  Right now, there are three possible environments:
;;;   
;;;    1) The runtime environment.  This is the environment is used by the
;;;       listener.  It corresponds to the currently running program.
;;;       There is only one runtime environment per image.
;;;
;;;    2) A syntax environment.  This is a stripped down version of the
;;;       runtime environment.  The compiler uses this environment to
;;;       process CT and DS forms.  It contains most of the bindings in
;;;       core proto, but not much else.
;;;
;;;       (Some environments are their own syntax environments--including
;;;       the runtime environment and syntax environments themselves--so
;;;       they evaluate their own CT and DS forms.  Other environments--
;;;       including target environments--have a separate syntax
;;;       environment.)
;;;
;;;    3) A target environment.  The compiler uses this environment to
;;;       compile code.  Initially, it contains only a few bindings:
;;;       the various <primitive-bindings>s and a few magic bindings
;;;       like IF.  There is one target environment per program
;;;       compiled.

;;; ENVIRONMENT CREATION 

;; Create a new global environment of the specified type.  This environment
;; will be chained to 'next-env' (which may be $empty-static-environment
;; if you so desire).  If you specify a 'syntax-env', it will be used to
;; evaluate DS and CT forms.  If you *don't* specify a syntax-environment,
;; then these forms will be evaluated in the newly-created environment
;; itself.
(df fab-static-global-environment 
  ((next-env <static-environment>)
   syntax-env ; TODO - (false-or <static-global-environment>)
   => <static-global-environment>)
  (assert (or (not syntax-env) (environment-is-own-syntax-environment? env)))
  (let ((new-env (isa <static-global-environment>
		   (set environment-next next-env)
		   (set environment-bindings (fab <tab> 2000)))))
    (set (environment-syntax-environment new-env)
	 (if syntax-env syntax-env new-env))
    new-env))

;; Copy the bindings specified by 'names' from 'src-env' to 'dst-env'.
(df copy-environment-bindings ((dst-env <static-global-environment>)
			       (src-env <static-global-environment>)
			       (names <col>)
			       => <static-global-environment>)
  (for ((name names))
    (let ((binding (find-binding name src-env)))
      (if binding
	  (insert-global! binding dst-env)
	  (error "Can't find binding '%=' for copy.\n" name))))
  dst-env)

;; Given an environment and a list of symbols, return a new environment
;; containing only those bindings in the original environment named by
;; the symbols.
(dm fab-subset-environment ((old-env <static-global-environment>)
			    (subset <col>)
			    syntax-env ; TODO - (false-or <static-environment>)
			    => <static-global-environment>)
  (let ((new-env
	 (fab-static-global-environment $empty-static-environment syntax-env)))
    (copy-environment-bindings new-env old-env subset)
    new-env))

;;; RUNTIME ENVIRONMENT

(dv *runtime-environment* $empty-static-environment)

(df runtime-environment () *runtime-environment*)

;; Create the runtime environment for the current image.  This is used
;; to run code typed into the listener, to process 'eval' calls, and so on.
(df init-runtime-environment ()
  (let ((rt-env (fab-static-global-environment $empty-static-environment #f)))

    ;; First, we need to get all the bindings which were built into our
    ;; image by the compiler, and copy them into our new environment.
    (%do-runtime-bindings
     (fun (name loc)
       (let ((sym (as <sym> name))
	     (binding
	      (isa <runtime-binding>
		(set binding-name     sym)
		(set binding-locative loc))))
	 (insert-global! binding rt-env))))

    ;; Next, we need to copy all our magic bindings into this environment.
    (insert-globals! (magic-bindings) rt-env)
    
    ;; Ask the interpreter to do any setup it will require.
    (init-environment-for-eval rt-env)

    ;; Up until this point, we haven't been able to define any macros in our
    ;; image.  Process the backlog now.
    (do2 (rcurry %%macro rt-env)
	 *boot-macro-names* *boot-macro-expanders*)
    (set *macros-ok?* #t)

    (set *runtime-environment* rt-env)
    #f))

;;; SYNTAX ENVIRONMENT

;; These bindings are initially available in CT and DS forms.
;; The section numbers refer to DOC/DOC.TXT.
(dv syntax-environment-bindings
  '(;; Section 1.1/2.1: Special forms.
    ;; Not included: CT, DS
    IF SEQ SET FUN LET LOC LAB FIN DV DM DG ISA SLOT MACRO-EXPAND
    NEXT-METHOD QUOTE

    ;; Section 1.2/2.2: Macros.
    DF TRY REP MIF AND OR SELECT CASE INC DEC UNLESS WHEN ASSERT
    FOR COLLECTING

    ;; Section 1.3: Read macros.
    quasiquote

    ;; Section 3.1: Any.
    <any> as

    ;; Section 3.2: Comparables.
    == = < ~= ~== > <= >= min max isa? object< object-direct-slots
    object-direct-parents object-slots object-parents object-name

    ;; Section 3.3: Null.
    nul

    ;; Section 3.4: Booleans.
    <log> not

    ;; Section 3.5: Characters.
    <chr> lowercase? uppercase? as-lowercase as-uppercase alphabetic?
    numeric? to-digit eof-object?

    ;; Section 3.6: Numbers.
    ;; Not included: gcd, lcm (which seem to be missing).
    <num> + - * / floor ceiling round truncate floor/ ceiling/ round/
    truncate/ modulo remainder pos? zero? neg? neg abs *print-base*
    num-to-str str-to-num
    <int> logior logxor logand lognot logbit? even? odd? ash lsh
    <flo> flo-bits
    <loc> locative-value locative-value-setter address-of

    ;; Section 3.7: Collections.
    <col> len elt elt-setter empty? empty default fab fabs fill alter any?
    all? reduce reduce+ find-key del-key del-keys do do2 map map2 do-keyed
    map-keyed mem?
    ;; 3.7.1: Iteration protocol.
    ini-state fin-state? nxt-state now-elt now-elt-setter now-key copy-state
    ;; 3.7.2: Maps.
    <map> <assocs> assocs-test
    <tab> table-growth-factor table-growth-threshold table-shrink-threshold
    table-protocol $permanent-hash-state current-gc-state id-hash
    <str-tab> case-insensitive-string-hash case-insensitive-string-equal
    ;; 3.7.3: Sequences.
    <seq> add 1st 2nd 3rd last pos rev rev! cat cat! cat2 sub sub-setter
    pick del del-dups
    ;; 3.7.4 Tuples.
    <tup> tup
    ;; 3.7.5 (the first one): Lists.
    <lst> <list> head tail lst list pair nil
    ;; 3.7.5 (the second one): Optionals.
    <opts>
    ;; 3.7.6 (the first one): Flat sequences.
    <flat> <vec> vec <str> str to-str <buf> buf push pop
    ;; 3.7.6 (the second one):  Ranges.
    <range> from from-by from-to from-to-by from-below from-below-by
    from-above from-above-by
    ;; 3.7.7: Steps.
    <step> first-then

    ;; Section 3.8: Symbols.
    <sym> as make-sym gensym make-setter-name var-name var-type

    ;; Section 3.9: Slots.
    <slot> slot-owner slot-getter slot-setter slot-type slot-init
    slot-value slot-value-setter find-getter find-setter add-slot

    ;; Section 3.10: Functions.
    <fun> fun-name fun-names fun-specs fun-nary? fun-arity fun-value
    identity compose curry rcurry always apply
    <gen> fun-mets gen-add-met sorted-app-mets
    <met> met-app?

    ;; Section 3.11: Conditions.
    <condition> default-handler sig <simple-condition> condition-message
    condition-arguments <serious-condition> <error> error <simple-error>
    <handler> handler-function make-handler handler-matches?

    ;; Section 3.12: Ports.
    <port> <input-port> read-char peek-char char-ready?
    <output-port> newline force-output write-char write-string
    <file-port> <file-input-port> open-input-file close-input-port
    call-with-input-file in
    <file-output-port> open-output-file close-output-port
    call-with-output-file out
    <string-port> port-contents <string-input-port> port-index
    call-with-string-input-port <string-output-port>
    call-with-string-output-port

    ;; Section 3.13: Input.
    read read-from-string read-file

    ;; Section 3.14: Output.
    write display writeln write-to-string format 

    ;; Section 3.15: System.
    app-filename app-args

    ;; Section 3.16: Top level.
    ;; Not included: load eval top.
    ;; Most of these functions have built-in assumptions about which
    ;; environment to use.  Rather than make them work in syntax
    ;; environments, we simply disallow them.
    do-stack-frames backtrace

    ;; Undocumented stuff.  This was all found by a process of trial and
    ;; error, but it needs to be here.
    match-atom match-empty-list match-unquote match-sublist
    sexpr-signature-parameters
    ))

;; Create a new syntax environment for processing macros.
(df fab-syntax-environment (=> <static-global-environment>)
  (let ((syn-env (fab-subset-environment (runtime-environment)
					 syntax-environment-bindings #f)))
    (init-environment-for-eval syn-env)
    syn-env))

;;; TARGET ENVIRONMENT

(df fab-target-environment (=> <static-global-environment>)
  (let ((syntax-env (fab-syntax-environment))
	(target-env (fab-static-global-environment $empty-static-environment
						   syntax-env)))

    ;; Copy in just our macros and our primitives, since everything else
    ;; must be defined by the program being compiled.  And don't bother
    ;; to call 'init-environment-for-eval'--this is a compile-only environment.
    (insert-globals! (cat (magic-bindings) (primitives)) target-env)

    ;; boot.proto uses these macros *before* defining them, so we'll
    ;; need to install temporary copies in the boot environment.
    ;; TODO - Clean up this mess.
    (copy-environment-bindings target-env syntax-env '(UNLESS WHEN OR AND))
    target-env))

;;; OTHER ENVIRONMENT CODE

(df init-ast ()
  (init-runtime-environment))

;; Given a static global environment 'env', apply 'f' to all the bindings.
(df do-static-global-bindings ((f <fun>) env)
  (rep loop ((env env))
    (unless (isa? env <static-empty-environment>)
      (do f (frame-bindings env))
      (loop (environment-next env)))))
