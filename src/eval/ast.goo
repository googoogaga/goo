;;;; Copyright (c) 2001 Jonathan Bachrach
;;;; BASED ON Lisp In Small Pieces by Christian Queinnec

(use boot)
(use macros)
(use runtime)
(use write)
(use syntax)
(use strings)

;;; TODO: MOVE TYPE OUT OF SIGNATURE

;;; The name of the module which contains all of proto's primitives,
;;; magic bindings, and core code.
(dv $proto-boot-module-name 'boot)
;;; The name of the runtime module, which contains a few items used by p2c.
(dv $proto-runtime-module-name 'runtime)

(dm objectify-error ((message <str>) (arguments ...))
  (apply error message arguments))

;;; programs

(dv <program> (isa <any>))
  (slot <program> program-type)

(dm program-register ((x <program>)) #f) ;; TODO: REMOVE

(dv <computed-program> (isa <program>))
  (slot <computed-program> (program-register <any>) #f) ;; TODO: FALSE-OR INT

(dv <passive-program> (isa <program>))

;;; bindings are not programs! they represent bindings.

(dv <binding-name> <any>) ;; (type-union <sym> <int>)

(dv <binding> (isa <any>))
  (slot <binding> (binding-name <binding-name>))
  (slot <binding> (binding-type <program>))

;; Global boxes are used by the interpreter to store the values of
;; global variables.
(dv <global-box> (isa <any>))
  (slot <global-box> global-box-value nul)

(dv <module-binding> (isa <binding>))
  ;; The name of the module in which this binding is defined.
  (slot <module-binding> binding-kind          'global)
  (slot <module-binding> (binding-module-name  <sym>))
  (slot <module-binding> (binding-free? <log>) #f)
  (slot <module-binding> binding-info          #f)

;; TODO: GET RID OF ALIASES OR MAKE SEPARATE INFO OBJECT

(dv binding-global-box        binding-info)
(dv binding-global-box-setter binding-info-setter)
(dv binding-locative          binding-info)
(dv binding-locative-setter   binding-info-setter)
(dv binding-handler           binding-info)
(dv binding-handler-setter    binding-info-setter)

(dv <local-binding> (isa <binding>))
  (slot <local-binding> binding-value           #f)
  (slot <local-binding> binding-mutable?        #f)
  (slot <local-binding> binding-dynamic-extent? #t)
  (slot <local-binding> binding-dotted?         #f)

;; (dv <next-methods-binding> (isa <binding>))

;;; compile-time

(dv <compile-time> (isa <computed-program>))
  (slot <compile-time> compile-time-program)

;;; references are programs.

(dv <reference> (isa <passive-program>))

;;; special category of bindings

;; DEAL WITH INITIALIZE

(dv <real-reference> (isa <reference>))
  (slot <real-reference> reference-binding)

(dv <local-reference> (isa <real-reference>))
  (slot <local-reference> reference-called-function? #f)
  (slot <local-reference> (reference-frame-number <int>))
  (slot <local-reference> (reference-frame-offset <int>))

;; (dv <next-methods-reference> (isa <real-reference>))

(dv <global-reference> (isa <real-reference>))

(dv <runtime-reference> (isa <real-reference>))

(dv <predefined-reference> (isa <real-reference>))

(dv <bound?> (isa <computed-program>))
  (slot <bound?> bound?-reference)

(dv <assignment> (isa <computed-program>))
  (slot <assignment> assignment-form)

(dv <local-assignment> (isa <assignment>))
  (slot <local-assignment> assignment-reference)

(dv <global-assignment> (isa <assignment>))
  (slot <global-assignment> assignment-binding)

(dv <runtime-assignment> (isa <global-assignment>))

(dv <definition> (isa <global-assignment>))

(dv <variable-definition> (isa <definition>))

(dv <ast-generic-definition> (isa <definition>))

(dv <ast-function-definition> (isa <definition>))

(dv <ast-method-definition> (isa <definition>))

(dv <ast-primitive-definition> (isa <definition>))

(dv <ast-macro-definition> (isa <definition>))

(dv <ast-signature> (isa <computed-program>))
  (slot <ast-signature> signature-names '())
  (slot <ast-signature> signature-specs '())
  (slot <ast-signature> signature-nary? #f)
  (slot <ast-signature> signature-value #f)

(dv signature-bindings signature-names)

(dv <ast-function> (isa <computed-program>))
  (slot <ast-function> function-name #f)
  ;;  (slot <ast-function> function-next-methods-binding)
  (slot <ast-function> function-signature)

(df function-bindings ((x <ast-function>)) 
  (signature-names (function-signature x)))
(df function-specs ((x <ast-function>)) 
  (signature-specs (function-signature x)))
(df function-nary? ((x <ast-function>))
  (signature-nary? (function-signature x)))
(df function-value ((x <ast-function>))
  (signature-value (function-signature x)))

(dm function-kind ((x <ast-function>)) "FUN")

(dv <ast-method> (isa <ast-function>))
  (slot <ast-method> function-body)

(dm function-kind ((x <ast-method>)) "MET")

(dv <ast-primitive> (isa <ast-method>))

(dm function-kind ((x <ast-primitive>)) "PRM")

(dv <ast-generic> (isa <ast-function>))

(dm function-kind ((x <ast-generic>)) "GEN")

(dv <alternative> (isa <computed-program>))
  (slot <alternative> alternative-condition)
  (slot <alternative> alternative-consequent)
  (slot <alternative> alternative-alternant)

(dv <programs> (isa <passive-program>))

(ds (def-list ,name (,@supers))
  (let ((class  (make-sym "<" name ">"))
	($empty (make-sym "$" name "-empty")))
    `(seq (dv ,class (isa (<lst> ,@supers)))
	  (dv ,$empty (isa ,class (set head #f) (set tail #f)))
	  (dm as ((p ,class) (x ,class) => <lst>) x)
	  (dm as ((p <lst>)  (x ,class) => <lst>) (apply lst x))
	  (dm as ((p ,class) (x <lst>) => <lst>) (apply fabs (pair ,class x)))
	  (df ,name (h t) (isa ,class (set head h) (set tail t)))
	  (dm empty ((e ,class) => ,class) ,$empty))))

(ds (def-programs ,name) `(def-list ,name (<programs>)))

(def-programs sequential)

(dv <constant> (isa <passive-program>))
  (slot <constant> constant-value)

(dv <raw-constant> (isa <constant>))

(dv <application> (isa <computed-program>))
  (slot <application> application-arguments)
  (slot <application> application-tail? #f)

(dv <regular-application> (isa <application>))
  (slot <regular-application> application-function)
  (slot <regular-application> application-known? #f)

(dv <predefined-application> (isa <application>))
  (slot <predefined-application> application-binding)

(dv <fix-let> (isa <computed-program>))
  (slot <fix-let> fix-let-bindings)
  (slot <fix-let> fix-let-types)
  (slot <fix-let> fix-let-arguments)
  (slot <fix-let> fix-let-body)

(def-programs types)

(def-programs arguments)

(dm as ((c <lst>) (e <arguments>) => <lst>)
  (rep loop ((res '()) (e e))
    (if (empty? e)
	(rev! res)
	(loop (arguments res e)))))

(dv <locals> (isa <computed-program>))
  (slot <locals> locals-bindings)
  (slot <locals> locals-functions)
  (slot <locals> locals-body)

(dv <bind-exit> (isa <computed-program>))
  (slot <bind-exit> bind-exit-main-fun)

(dv <unwind-protect> (isa <computed-program>))
  (slot <unwind-protect> unwind-protect-protected-thunk)
  (slot <unwind-protect> unwind-protect-cleanup-thunk)

(dv <monitor> (isa <computed-program>))
  (slot <monitor> monitor-type)
  (slot <monitor> monitor-info)
  (slot <monitor> monitor-test)
  (slot <monitor> monitor-handler)
  (slot <monitor> monitor-main-thunk)

;;; ENVIRONMENT

(dv <static-environment> (isa <any>))
  (slot <static-environment> environment-next #f)
  (slot <static-environment> (environment-bindings <col>))

(dv <static-global-environment> (isa <static-environment>))
  ;; The module associated with this environment.
  (slot <static-global-environment> environment-module) ;<module>
  ;; The module-loader which should be used to load new modules for
  ;; use by this environment.
  (slot <static-global-environment> environment-module-loader) ;<module-loader>
  ;; The modules used by this environment.
  (slot <static-global-environment> (environment-uses-modules <buf>)
        (fab <buf> 0))
  ;; Forward references from other modules which are resolved by this
  ;; module.
  (slot <static-global-environment> (environment-implements <lst>) '())

(dv <static-empty-environment> (isa <static-environment>))

(dv $empty-static-environment (isa <static-empty-environment>))

(dv <static-local-environment> (isa <static-environment>))

;; Given an object, try to find a global binding which contains it.
;; Used by the writer.
;; TODO - This will only work in the runtime environment, not any of the
;; various syntax environments.
(dm env-object-name (x => <any>)
  (lab return
    (do-static-global-bindings
     (fun (binding)
       (when (and (== (binding-kind binding) 'global)
                  (binding-global-box binding)
		  (== x (global-box-value (binding-global-box binding))))
	 (return (binding-name binding))))
     (runtime-environment))
    #f))


;;;; CONVERT TO AST FORM

(dm objectify ((e <lst>) (r <static-environment>) tail? => <any>)
  (if (isa? e <program>) ;; TODO: HACK FOR <PROGRAMS>
      e
      (objectify-list (objectify (head e) r #f) e r tail?)))

(dm objectify-list
    ((f <any>) (e <lst>) (r <static-environment>) tail? => <any>)
  (objectify-application f (tail e) r tail?))

(dm objectify-list
    ((f <module-binding>) (e <lst>) (r <static-environment>) tail? => <any>)
  (select (binding-kind f)
    (('magic) ((binding-handler f) e r tail?))
    (('macro) (objectify ((binding-handler f) e r tail?) r tail?))
    (#t       (error "Magic or Macro binding expected %=" f))))

(dm objectify ((e <sym>) (r <static-environment>) tail? => <any>)
  (objectify-symbol e r))

(dm objectify ((e <module-binding>) (r <static-environment>) tail? => <any>)
  e)

(dm objectify ((e <program>) (r <static-environment>) tail? => <any>)
  e)

(dm objectify ((e '()) (r <static-environment>) tail? => <any>)
  (objectify-quotation e r))

(dm objectify (e (r <static-environment>) tail? => <any>)
  (objectify-quotation e r))

(dm objectify-quotation (value r => <constant>)
  (isa <constant> (set constant-value value)))

(dm objectify-raw (value r => <raw-constant>)
  (isa <raw-constant> (set constant-value value)))

(dm objectify-bound? ((e <sym>) (r <static-environment>) tail? => <any>)
  (let ((ref (objectify-symbol e r)))
    (isa <bound?> (set bound?-reference ref))))

;;; This routine always produces a version of 'program' which is accessible
;;; in the syntax environment.  If 'rt?' is true, it will make sure that
;;; there is also a version in the runtime environment.
(dm objectify-compile-time (program r tail? rt? => <program>)
  (let ((mod (find-environment-module r))
        (syntax-env (module-syntax-environment mod))
        (target-env (module-target-environment mod))
        (ast (objectify program syntax-env tail?)))
    ;; Process the program immediately.
    (ast-evaluate ast)
    ;; If we have been asked to create a runtime copy of this code--and we
    ;; are compiling--create a second copy of this code which can be
    ;; accessed in the runtime.  This parallels they way
    ;; <ast-macro-definition> works.  Otherwise, objectify #f.
    ;; The value of a CT-ALSO form is currently undefined.
    (if (and rt? (~== syntax-env target-env))
        (objectify program r tail?)
        (isa <constant> (set constant-value #f)))))

(dm objectify-alternative (t c a r tail? => <alternative>)
  (isa <alternative> 
       (set alternative-condition  (objectify t r #f))
       (set alternative-consequent (objectify c r tail?))
       (set alternative-alternant  (objectify a r tail?))))

(dm sequentialize ((e* <lst>) => <program>)
  (if (empty? e*)
      (isa <constant> (set constant-value #f))
      (if (empty? (tail e*))
	  (head e*)
	  (rep loop ((e* e*))
	    (if (empty? e*)
		(empty <sequential>)
		(sequential (head e*) (loop (tail e*))))))))

(dm objectify-sequential ((e* <lst>) r tail? => <program>)
  (let ((asts 
	 (rep loop ((res '()) (e* e*))
	   (if (empty? e*)
	       (rev! res)
	       (let ((tail? (if (empty? (tail e*)) tail? #f))
		     (head  (objectify (head e*) r tail?)))
		 (loop (pair head res) (tail e*)))))))
    (sequentialize asts)))

(dm objectify-application ((ff <ast-method>) e* r tail? => <program>)
  (let ((ee* (convert2arguments (map (fun (e) (objectify e r #f)) e*))))
    (process-closed-application ff ee* r tail?)))

;; TODO: USE THIS FOR PRIMITIVES

(dm objectify-application ((ff <predefined-reference>) e* r tail? => <program>)
  (let ((ee*  (convert2arguments (map (fun (e) (objectify e r #f)) e*)))
	(fvf  (reference-binding ff)))
    (isa <predefined-application> 
	 (set application-binding   fvf)
	 (set application-arguments ee*)
	 (set application-tail?     tail?))))

(dm objectify-application (ff e* r tail? => <program>)
  (let ((ee* (convert2arguments (map (fun (e) (objectify e r #f)) e*))))
    (isa <regular-application> 
	 (set application-function  ff) 
	 (set application-arguments ee*)
	 (set application-tail?     tail?))))

(dm process-closed-application ((f <ast-method>) e* r tail? => <fix-let>)
  (let ((v* (function-bindings f))
	(b  (function-body f)))
    (if (function-nary? f)
	(process-nary-closed-application f e* r tail?)
	(if (= (len e*) (len (function-bindings f)))
	    (isa <fix-let> 
		 (set fix-let-bindings  (function-bindings f))
                 (set fix-let-types     (function-specs f))
		 (set fix-let-arguments e*)
		 (set fix-let-body      (function-body f)))
	    (objectify-error "incorrect regular arity" f e*)))))

(dm process-nary-closed-application (f e* r tail? => <fix-let>)
  (loc ((pack-nary-args (e*) ;; TODO: COULD BE SHARED WITH PAIRIZE
	   (if (empty? e*)
	       (lst 'quote '())
	       (lst '%pair (head e*) (pack-nary-args (tail e*)))))
        (gather-arguments (e* v*)
	  (if (binding-dotted? (head v*))
	      (arguments (objectify (pack-nary-args e*) r #f) 
			 (empty <arguments>))
	      (if (empty? e*)
		  (objectify-error "incorrect dotted arity" f e*)
		  (arguments 
		   (head e*) (gather-arguments (tail e*) (tail v*)))))))
   (let ((v* (function-bindings f))
	 (o  (isa <fix-let> 
		  (set fix-let-bindings  v*)
		  (set fix-let-types     (function-specs f))
		  (set fix-let-arguments (gather-arguments e* v*))
		  (set fix-let-body      (function-body f)))))
     (set (binding-dotted? (last v*)) #f)
     o)))
 
(dm convert2arguments ((e* <lst>) => <any>)
  (if (empty? e*)
      (empty <arguments>)
      (arguments (head e*) (convert2arguments (tail e*)))))

;;; assignment on mutable local bindings are immediately
;;; processed. references to local mutable bindings must wait the
;;; second pass.

(dm objectify-assignment ((binding <lst>) e r tail? => <program>)
  (let ((op (sexpr-operator binding)))
    (if (sexpr-variable? op)
	(objectify
	 (sexpr-make-application
	  (objectify (sexpr-make-setter-name op) r #f) 
	  (pair e (sexpr-operands binding)))
	 r tail?)
	(objectify-error "Unsupported Set!: %=" e))))

(dm objectify-assignment ((binding <sym>) e r tail? => <assignment>)
  (let ((ref (objectify binding r #f))
	(val (objectify e r #f)))
    (objectify-assignment-using ref val)))

(dm objectify-assignment-using 
    ((ref <local-reference>) (val <program>) => <local-assignment>)
 (set (binding-mutable? (reference-binding ref)) #t)
 (isa <local-assignment> 
   (set assignment-reference ref)
   (set assignment-form      val)))

(dm objectify-assignment-using 
    ((ref <global-reference>) (val <program>) => <global-assignment>)
 (isa <global-assignment> 
   (set assignment-binding (reference-binding ref))
   (set assignment-form    val)))

(dm objectify-assignment-using 
    ((ref <runtime-reference>) (val <program>) => <runtime-assignment>)
 (isa <runtime-assignment> 
   (set assignment-binding (reference-binding ref))
   (set assignment-form    val)))

(dm ast-define-binding (r name defining-method? kind => <any>)
  (let ((existing-binding (find-binding name r))
	(gr (find-static-global-environment r))
        (mod (environment-module gr))
	(binding
	 (if existing-binding
             (let ((foreign?
                    (not (or (binding-native-to? existing-binding mod)
                             defining-method?))))
               (if (binding-free? existing-binding)
                   ;; If the binding is free, define it.
                   (seq
                     (set (binding-free? existing-binding) #f)
                     (when foreign?
                       (pushf (environment-implements gr) existing-binding)))
                   ;; Otherwise, redefine the existing binding.
                   ;; TODO - We should do more useful redefinition here.
                   (when foreign?
                     (format out
                             "%s: warning: '%s' clobbers binding from %s.\n"
                             (module-name mod)
                             name
                             (binding-module-name existing-binding))))
               existing-binding)
             (let ((mod-name (module-name (find-environment-module r)))
                   (binding 
                    (isa <module-binding> 
                      (set binding-kind        kind)
                      (set binding-name        name)
                      (set binding-free?       #f)
                      (set binding-module-name mod-name))))
	       (insert-global! binding gr)
	       binding))))
    binding))

(dv *macro-tracing?* #f)

(dm objectify-definition (var e r => <any>)
  (let ((name
	 (sexpr-variable-name var))
	(binding 
	 (ast-define-binding r name #f 'global))
	(defn
	 (isa <definition> 
	   (set assignment-binding binding)
	   (set assignment-form (objectify e r #f)))))
    defn))

(df %%macro (name expander r => <module-binding>)
  ;; (format out "DEFMACRO ") (writeln out sep-expander)
  (loc ((expand (x r tail?)
	  (when *macro-tracing?*
	    (format out "MACRO ") (write out x) (format out "\n"))
	  (let ((exp (apply expander (lst x))))
	    (when *macro-tracing?*
	      (format out "  => ") (write out exp) (format out "\n"))
	    exp)))
    ;; (format out "DEFMAC %=\n" name)
    (let ((binding (ast-define-binding r name #f 'macro)))
      (set (binding-handler binding) expand)
      binding)))

;; Process a macro definition.  This is somewhat ugly, because a single
;; macro definition may need to appear in as many as three places:
;;  1) The target environment, so it may be used by the program itself.
;;  2) The syntax environment, so it can be used to write other macros.
;;  3) The runtime environment *of the image we're building*.  This
;;     means that once our program has been compiled and run, macros
;;     should remain available in the listener.  This requires some magic,
;;     which is handled by <ast-macro-definition>.
;; XXX - This function has very ugly semantics, and I don't like it.
(dm objectify-syntax-definition (name e r rt? => <any>)
  (let ((sep-expander (sexpr-make-macro-function e))

	;; Build a version of the macro for use in the target and syntax
	;; environments.
	(syntax-env   (find-syntax-environment r))
	(ast-expander (objectify sep-expander syntax-env #f))
	(expander     (ast-evaluate ast-expander))

	;; Install it into the target environment.
	(binding (%%macro name expander r)))

    ;; If the syntax and current environments are different (i.e., we're
    ;; compiling code), then install it in the syntax environment, too.
    (when (~== syntax-env (find-static-global-environment r))
      (insert-global! binding syntax-env))
    
    ;; If the macro should be available in the runtime of the image we're
    ;; building, work some magic.  Otherwise, just return false.
    (if rt?
	(isa <ast-macro-definition> 
	  (set assignment-binding binding)
	  (set assignment-form
	       ;; Re-objectify the expander, this time using bindings from
	       ;; the target environment.  This should allow it to be run
	       ;; in the image (if we're reasonably lucky).
	       (objectify sep-expander r #f)))
	(objectify-quotation #f r))))
  
(dm objectify-function-definition (name e r => <ast-function-definition>)
  (let ((binding (ast-define-binding r name #f 'global))
	(f       (objectify e r #f)))
    (set (function-name f) binding)
    (let ((defn (isa <ast-function-definition>
		     (set assignment-binding binding)
		     (set assignment-form f))))
      defn)))

(df module-binding ((kind <sym>) => <module-binding>)
  (isa <module-binding> (set binding-kind kind)))

(dm objectify-primitive-definition 
    (name sig body r => <ast-primitive-definition>)
  (let ((binding   (ast-define-binding r name #f 'predefined))
	(signature (objectify-signature sig r))
        (new-r     (r-extend* r (signature-bindings signature)))
	(body      (objectify-sequential body new-r #t))
	(form      (isa <ast-primitive> 
                     (set function-name binding)
                     (set function-signature signature)
                     (set function-body body))))
    (let ((defn (isa <ast-primitive-definition>
                  (set assignment-binding binding)
                  (set assignment-form form))))
      defn)))

(dm objectify-generic-definition (name sig r => <ast-generic-definition>)
  (let ((binding   (ast-define-binding r name #f 'global))
	(signature (objectify-signature sig r))
	(form      (isa <ast-generic>
                     (set function-name binding)
                     (set function-signature signature)))
	(defn      (isa <ast-generic-definition>
                     (set assignment-binding binding)
                     (set assignment-form form))))
    defn))

(dm objectify-method-definition (name e r => <ast-method-definition>)
  (let ((binding (ast-define-binding r name #t 'global))
	(gen     (lst 'if (lst 'bound? name) name #f))
	(met     (objectify e r #f))
	;; TODO: NAME AND MARK AS GENERIC METHOD
	(call    (lst '%define-method gen met))
	(form    (objectify call r #f))
	(defn    (isa <ast-method-definition>
		      (set assignment-binding binding)
		      (set assignment-form    form))))
    (set (function-name met) name)
    defn))

;;; it is important that the body is objectified first so mutability
;;; of local bindings is known and they can be appropriately handled
;;; in objectify-bindings-list. 
;;; all bindings are considered immutable at the beginning.

(dm objectify-function (sig body r tail? => <ast-method>)
  (let ((signature (objectify-signature sig r))
        (new-r     (r-extend* r (signature-bindings signature)))
	(b         (objectify-sequential body new-r #t)))
    (isa <ast-method> 
	 (set function-signature signature)
	 (set function-body b))))

(dv $sexpr-optionals-tag       '...)
(dv $sexpr-optionals-type-name '<opts>)

(dm objectify-signature (sig r => <ast-signature>)
  (let ((sexpr-params (sexpr-signature-parameters sig)))
    (rep col ((params sexpr-params) (nary? #f) (bindings '()) 
              (types (empty <types>)))
      (if (empty? params)
          (let ((sexpr-value (sexpr-signature-value sig))
                (value (objectify (or sexpr-value (default-type r)) r #f)))
            (isa <ast-signature>
              (set signature-names (rev! bindings))
              (set signature-specs (rev! types))
              (set signature-nary? nary?)
              (set signature-value value)))
          (let ((param   (head params))
                (sname   (sexpr-variable-name param))
                (stype   (sexpr-variable-type param))
                (dotted? (== stype $sexpr-optionals-tag))
                (stype   (if dotted? $sexpr-optionals-type-name stype))
                (type    (objectify stype r #f))
                (binding
                 (isa <local-binding>
                      (set binding-name sname)
                      (set binding-type type)
                      (set binding-dotted? dotted?))))
            (col (tail params) dotted? 
                 (pair binding bindings)
                 (isa <types> (set head type) (set tail types))))))))

(dm compute-local-reference-offsets 
    ((binding <local-binding>) (r <static-local-environment>) 
     => (tup (frame-number <int>) (frame-offset <int>)))
 (rep loop ((i 0) (r r))
   (if (isa? r <static-local-environment>)
       (rep find ((j 0) (bindings (environment-bindings r)))
	 (if (empty? bindings)
	     (loop (+ i 1) (environment-next r))
	     (if (== (head bindings) binding)
		 (tup i j)
		 (find (+ j 1) (tail bindings)))))
       (error "DIDN'T FIND LOCAL BINDING %= IN %=" (binding-name binding) r))))

(dm objectify-binding (n (b <local-binding>) r => <local-reference>)
  (let (((tup i j) (compute-local-reference-offsets b r)))
    (isa <local-reference>
      (set reference-binding b)
      (set reference-frame-number i)
      (set reference-frame-offset j))))

;; (dm objectify-binding 
;;     (n (b <next-methods-binding>) r => <next-methods-reference>)
;;   (isa <next-methods-reference> (set reference-binding b)))

(dm binding-reference-prototype ((b <module-binding>) => <reference>)
  (select (binding-kind b)
    (('global)     <global-reference>)
    (('predefined) <predefined-reference>)
    (('runtime)    <runtime-reference>)
    (#t            (error "Unknown binding-kind %=" (binding-kind b)))))

(dm objectify-binding (n (b <module-binding>) r => <any>)
  (select (binding-kind b)
    (('magic 'macro) b)
    (#t              (let ((<ref> (binding-reference-prototype b)))
                       (isa <ref> (set reference-binding b))))))

(dm objectify-binding (n b r => <reference>)
  (objectify-free-global-reference n r))

;;; a free binding is defined to be a global binding defined on the fly.

(dm default-type (r) 
  (objectify '<Any> r #f))

(dm objectify-free-global-reference (name r => <global-reference>)
  (let ((gr (find-static-global-environment r))
	(b (isa <module-binding>
             (set binding-free? #t)
             (set binding-kind  'global)
	     (set binding-name  name)
             (set binding-module-name
                  (module-name (find-environment-module r))))))
    (insert-global! b gr)
    (isa <global-reference> (set reference-binding b))))

(dm objectify-symbol (name r => <any>)
  (objectify-binding name (find-binding name r) r))

(dm ftype (r)
  (objectify '<fun> r #f))

(def-programs functions)

(dm objectify-locals (names sigs bodies body r tail? => <locals>)
  (let ((bindings
	 (map (fun (n) (isa <local-binding> 
			    (set binding-name n) (set binding-type (ftype r))))
	      names))
	(new-r
	 (r-extend* r bindings))
	(function-forms
	 (map2 sexpr-make-anonymous-method sigs bodies))
	(functions 
	  (map (rcurry objectify new-r #f) function-forms)))
    ;; TODO: CIRCULARITIES IN AST
    (do2 (fun (f b) (set (function-name f) b) (set (binding-value b) f)) 
	 functions bindings)
    (isa <locals>
	 (set locals-bindings  bindings)
	 (set locals-functions (apply fabs (pair <functions> functions)))
	 (set locals-body      (objectify-sequential body new-r #t)))))

(dm objectify-bind-exit (name body r tail? => <bind-exit>)
  (isa <bind-exit>
       (set bind-exit-main-fun 
	    (objectify (sexpr-make-anonymous-method (lst name) body) r #f))))

(dm objectify-unwind-protect
    (protected-form cleanup-forms r tail? => <unwind-protect>)
  (isa <unwind-protect>
       (set unwind-protect-protected-thunk
	    (objectify
	     (sexpr-make-anonymous-method '() (lst protected-form)) r #f))
       (set unwind-protect-cleanup-thunk
	    (objectify
	     (sexpr-make-anonymous-method '() cleanup-forms) r #f))))

(dm objectify-monitor (type info test handler body r tail? => <monitor>)
  (isa <monitor>
    (set monitor-type       (objectify type r #f))
    (set monitor-info       (objectify info r #f))
    (set monitor-test       (objectify test r #f))
    (set monitor-handler    (objectify handler r #f))
    (set monitor-main-thunk (objectify body r #f))))

(dm objectify-export (names r tail? => <program>)
  (let ((env (find-static-global-environment r))
        (module (find-environment-module r)))
    (unless (== env (module-target-environment module))
      ;; The user tried to export bindings from a syntax environment.
      ;; (This shouldn't happen, because we don't provide 'export'.)
      (error "Can only export bindings from target environment.\n"))
    (for ((name names))
      (let ((binding (find-binding name env)))
        (if (== binding #f)
            (error "Can't export undefined binding %s.\n" name)
            (export-binding! module name binding)))))
  (isa <constant> (set constant-value #f)))

;;; This works like 'insert-global!', but it's more careful about clobbering.
(df import-global! ((b <module-binding>) (env <static-global-environment>))
  (let ((existing (find-binding (binding-name b) env)))
    (unless (or (== existing #f) (== existing b))
      (format out "warning: '%s' from %s clobbers local binding.\n"
              (binding-name b) (binding-module-name b))))
  (insert-global! b env)
  #f)

(dm objectify-use-module (name r tail? => <program>)
  (let ((env (find-static-global-environment r))
        (loader (environment-module-loader env))
        (used-module (probe-module loader name)))
    (push-last! (environment-uses-modules env) used-module)
    (do (rcurry import-global! env) (module-exports used-module)))
  (isa <constant> (set constant-value #f)))

(dm expand-bind-list (pat var fail => <any>)
  (error "Expected Pattern List %=\n" pat))

(dm expand-bind-list ((pat '()) var fail => <lst>)
  `(match-empty-list ,var ,fail))

(dm expand-bind-list ((pat <lst>) var fail => <lst>)
  (case
    ((sexpr-unquote? pat)
      (error "Unquote Unexpected Here %=\n" pat))
    ((sexpr-unquote-splicing? pat)
     (error "Unquote Splicing Unexpected Here %=\n" pat))
    (#t
     (expand-bind-list* pat var fail))))

(dm expand-bind-list* ((pat '()) var fail => <any>)
  `(match-empty-list ,var ,fail))

(dm expand-bind-list* ((pat <lst>) var fail => <any>)
  `(let ((,var ,(expand-bind-element (head pat) var fail)))
     ,(expand-bind-list* (tail pat) var fail)))

(dm expand-bind-element (pat var fail => <any>)
  `(match-atom ,var ',pat ,fail))

(dm expand-bind-element ((pat <lst>) var fail => <any>)
  (case
    ((sexpr-unquote? pat)
     `(seq (set ,(2nd pat) (match-unquote ,var ,fail)) (tail ,var)))
    ((sexpr-unquote-splicing? pat)
     `(seq (set ,(2nd pat) ,var) '()))
    (#t
     `(seq (let ((,var (match-sublist ,var ,fail)))
	     ,(expand-bind-list pat var fail))
	   (tail ,var)))))

(dm expand-pattern ((pat <lst>) var fail => <any>)
  `(if (isa? ,var <lst>)
       ,(expand-bind-list pat var fail)
       (,fail "Match Pattern Failure" ,var)))

(dm expand-syntax-if ((x <lst>) => <lst>)
  (let ((pat   (sexpr-syntax-if-pattern x))
	(vars  (sexpr-bind-pattern-variables pat))
	(value (sexpr-syntax-if-value x))
	(then  (sexpr-syntax-if-then x))
	(else  (sexpr-syntax-if-else x))
	(var   (gensym))
	(fail  (gensym))
	(epat  (expand-pattern pat var fail)))
    `(lab return
       (loc ((,fail ((msg <str>) (args ...)) (return ,else)))
	 (let ((,var ,value))
	   (let ,(map (fun (x) `(,x #f)) vars)
	     ,epat
	     ,then))))))

;;; AST ENVIRONMENT

;;; these functions deal with the environment.  r is a sequential of
;;; full-environment objects containing local bindings followed by an
;;; instance of environment followed by a sequential of full-environment
;;; containing the global mutable bindings mixed with the global
;;; macros followed by the predefined bindings.

(dm r-extend* (r (bindings <lst>) => <static-environment>)
  (isa <static-local-environment> 
    (set environment-next r)
    (set environment-bindings bindings)))

(dm insert-global! (binding r)
  (let (((r <static-global-environment>) (find-static-global-environment r)))
    (set (elt (environment-bindings r) (binding-name binding)) binding)))

(dm insert-globals! ((bindings <lst>) r) 
  (do (fun (b) (insert-global! b r)) bindings))

(dm find-static-global-environment 
    ((r <static-local-environment>) => <static-global-environment>)
  (find-static-global-environment (environment-next r)))

(dm find-static-global-environment
    ((r <static-global-environment>) => <static-global-environment>)
  r)

(dm find-syntax-environment ((r <static-environment>)
			     => <static-global-environment>)
  (module-syntax-environment (find-environment-module r)))

(dm find-environment-module ((r <static-environment>)) ; => <module>
  (environment-module (find-static-global-environment r)))

(dm find-binding (name (r <static-local-environment>) => <any>)
  (rep loop ((bindings (environment-bindings r))) ;; TODO: => (or <binding> #f)
    (if (empty? bindings)
	(find-binding name (environment-next r))
	(if (== name (binding-name (head bindings)))
	    (head bindings)
	    (loop (tail bindings))))))

;; TODO: => FALSE-OR <BINDING>

(dm find-binding (name (r <static-empty-environment>) => <any>)
  #f)

(dm find-binding (name (r <static-global-environment>) => <any>) 
  (let ((binding (elt (environment-bindings r) name)))
    (if (== binding nul)
	(find-binding name (environment-next r))
	binding)))

;; TODO: CLEANUP

(dm frame-bindings ((env <static-environment>) => <col>)
  ;; (as <lst> (map identity (environment-bindings env)))
  (environment-bindings env))

;;;; SPECIAL FORMS

(dv *magic-bindings* '())

(dm register-magic-binding (name value)
  (set *magic-bindings* (add *magic-bindings* value)))

(dm magic-bindings ()
  *magic-bindings*)

(ds (define-magic-binding ,name (,@params) ,@body)
  (let ((special-name (make-sym "special-" name))
	(sexpr-name   (make-sym "$sexpr-" name "-tag")))
    `(seq (dv ,special-name
	       (isa <module-binding>
                    (set binding-kind        'magic)
		    (set binding-name        ,sexpr-name)
                    (set binding-module-name $proto-boot-module-name)
		    (set binding-handler     (fun (,@params) ,@body))
		    (set binding-free?       #f)))
	  (register-magic-binding ',name ,special-name))))

(define-magic-binding if (x r tail?)
  (objectify-alternative
    (sexpr-if-test x) (sexpr-if-then x) (sexpr-if-else x) r tail?))

(define-magic-binding begin (x r tail?)
  (objectify-sequential (tail x) r tail?))

(dv $sexpr-%raw-tag '%raw)

(define-magic-binding %raw (x r tail?)
  (objectify-raw (2nd x) r))

(define-magic-binding quote (x r tail?)
  (objectify-quotation (sexpr-text-of-quotation x) r))

(define-magic-binding set (x r tail?)
  (objectify-assignment
    (sexpr-assignment-variable x) (sexpr-assignment-value x) r tail?))

(define-magic-binding define (x r tail?)
  (objectify-definition
    (sexpr-definition-variable x) (sexpr-definition-value x) r))

(define-magic-binding define-syntax (x r tail?)
  (objectify-syntax-definition
    (sexpr-syntax-definition-variable x) (sexpr-syntax-definition-value x) r #t))

(dv $sexpr-define-static-syntax-tag 'dss)

(define-magic-binding define-static-syntax (x r tail?)
  (objectify-syntax-definition
    (sexpr-syntax-definition-variable x) (sexpr-syntax-definition-value x) r #f))

(define-magic-binding define-method (x r tail?)
  (objectify-method-definition
    (sexpr-function-definition-variable x) 
    (sexpr-function-definition-value x) r))

(define-magic-binding define-generic (x r tail?)
  (objectify-generic-definition
    (sexpr-function-definition-variable x) (sexpr-function-signature x) r))

(define-magic-binding define-function (x r tail?)
  (objectify-function-definition
    (sexpr-function-definition-variable x) 
    (sexpr-function-definition-value x) r))

(define-magic-binding method (x r tail?)
  (objectify-function
    (sexpr-method-signature x) (sexpr-method-body x) r tail?))

(dv $sexpr-bound?-tag 'bound?)

(define-magic-binding bound? (x r tail?)
  (objectify-bound? (2nd x) r tail?))

(define-magic-binding let (x r tail?)
  (objectify (sexpr-let->combination x) r tail?))

(define-magic-binding locals (x r tail?)
  (objectify-locals
    (sexpr-loc-bound-names x) (sexpr-loc-bound-signatures x) 
    (sexpr-loc-bound-bodies x) (sexpr-loc-raw-body x) r tail?))

(define-magic-binding iterate (x r tail?)
  (objectify (sexpr-iterate->loc x) r tail?))

(define-magic-binding bind-exit (x r tail?)
  (objectify-bind-exit (sexpr-block-name x) (sexpr-block-body x) r tail?))

(define-magic-binding unwind-protect (x r tail?)
  (objectify-unwind-protect
    (sexpr-unwind-protect-protected-form x) 
    (sexpr-unwind-protect-cleanup-forms x)
    r tail?))

(define-magic-binding monitor (x r tail?)
  (let (((tup type info test handler body) (sexpr-monitor-expand x)))
    (objectify-monitor type info test handler body r tail?)))

(dm pairize ((args <lst>) => <any>)
  (if (empty? args)
      (lst 'quote '())
      (lst '%pair (head args) (pairize (tail args)))))

(define-magic-binding isa (x r tail?)
  (let ((slot-inits (sexpr-isa-slot-inits x)))
    (objectify
     (sexpr-make-application
       '%isa
       (lst (pairize (sexpr-isa-parents x))
	    (pairize (sexpr-isa-init-slots slot-inits))
	    (pairize (sexpr-isa-init-values slot-inits))))
     r tail?)))

(define-magic-binding slot (x r tail?)
  (let ((var         (sexpr-slot-variable x))
	(name        (sexpr-variable-name var))
	(setter-name (sexpr-make-setter-name name))
	(slot-type   (sexpr-variable-type var)))
    (objectify
     (sexpr-make-begin
      (lst (sexpr-make-getter name (sexpr-slot-object x))
	   (sexpr-make-setter name (sexpr-slot-object x) slot-type)
	   (sexpr-make-application
	     '%slot
	     (lst (sexpr-slot-object x) 
		  name setter-name slot-type
		  (sexpr-make-anonymous-method
		   '((x <any>)) (lst (sexpr-slot-init x)))))))
     r tail?)))
			    
(dv $sexpr-compile-time-tag 'ct)

(define-magic-binding compile-time (x r tail?)
  (objectify-compile-time (head (tail x)) r tail? #f))

(dv $sexpr-compile-time-also-tag 'ct-also)

(define-magic-binding compile-time-also (x r tail?)
  (objectify-compile-time (head (tail x)) r tail? #t))

(dv $sexpr-define-primitive-tag 'dp)

(define-magic-binding define-primitive (x r tail?)
  (if (sexpr-forward-primitive? x)
      (seq (ast-define-binding
	    r (sexpr-function-definition-variable x) #f 'predefined)
	   (objectify #f r tail?))
      (objectify-primitive-definition
       (sexpr-function-definition-variable x) 
       (sexpr-function-signature x) (sexpr-function-body x) r)))

(define-magic-binding quasiquote (x r tail?)
  (objectify (sexpr-expand-backquote x) r tail?)))

(dm ast-macro-expand (x r tail?)
  (let ((m (objectify (head x) r tail?)))
    (if (and (isa? m <module-binding>) (== (binding-kind m) 'magic))
	(let ((res ((binding-handler m) x r tail?)))
	  ;; (format out "EXPANSION ") (write out res) (format out "\n")
	  res)
	#f)))

(define-magic-binding macro-expand (x r tail?)
  (objectify-quotation
    (ast-macro-expand (2nd x) r tail?) r))

(define-magic-binding syntax-if (x r tail?)
  ;; (syntax-if (?pattern ?value) ?form ...)
  ;; x   => just matches etc
  ;; x  => binds x to an sexpr
  ;; @x => binds x to a series of sexprs
  ;; TODO: make this deals with multiple bindings
  (objectify (expand-syntax-if x) r tail?))

(dv $sexpr-export-tag 'export)

(define-magic-binding export (x r tail?)
  (objectify-export (tail x) r tail?))

(dv $sexpr-use-module-tag 'use)

(define-magic-binding use-module (x r tail?)
  (objectify-use-module (2nd x) r tail?))

;;;;=======================================================================
;;;;  Module Loaders & Modules
;;;;=======================================================================
;;;;  A module contains two environments: a target environment, and a
;;;;  syntax environment.  The target environment is used for objectifying
;;;;  actual programs, and the syntax environment is used for objectifying
;;;;  DS, CT, DSS and any other compile-time forms.  In some cases, the
;;;;  syntax environment and the target environment might be the same.
;;;;
;;;;  See PROPOSALS/SIMPLE-MODULES.TXT for an overview of the module
;;;;  system from a programmer's perspective.
;;;;
;;;;  A <module-loader> loads modules from disk and keeps them in memory.
;;;;  There are typically several module loaders in use:
;;;;    1. A module loader for the running image's listener.
;;;;    2. A module loader for each program being compiled.

(dv <module-loader> (isa <any>))
  ;; A map from module names (represented as symbols) to
  ;; <module> objects.
  (slot <module-loader> (module-loader-modules <tab>) (fab <tab> 1000))
  ;; A stack of all the names of modules currently being loaded.
  ;; We use this to catch circular dependencies.
  (slot <module-loader> (module-loader-stack <lst>) '())

(export <module-loader>)

(dv <module> (isa <any>))
  (slot <module> (module-name <sym>))
  ;; The environments associated with this module.
  (slot <module> (module-target-environment <static-global-environment>))
  (slot <module> (module-syntax-environment <static-global-environment>))
  ;; The bindings exported by this module.
  (slot <module> (module-exports <tab>) (fab <tab> 1000))

(export
  <module>
  module-name
  module-syntax-environment
  module-target-environment)

(df set-module-environments ((mod <module>)
                             (syntax-env <static-global-environment>)
                             (target-env <static-global-environment>))
  (set (module-syntax-environment mod) syntax-env)
  (set (module-target-environment mod) target-env))

;;; Call a function 'f' for each module associated with the module loader.
(df do-module-loader-modules (f loader)
  (do (fun (mod) (f mod))
      (module-loader-modules loader)))

;; Create an empty module for use with a particular loader.
;; Override this method to use a custom module class.
(dm module-loader-module-type ((loader <module-loader>) => <module>)
  <module>)

;;; Add a module to a module-loader.
(df register-module! ((module-loader <module-loader>) (mod <module>)
                      => <module-loader>)
  (set (elt (module-loader-modules module-loader) (module-name mod)) mod)
  module-loader)

;;; Find the module with the given name, loading it if necessary.
(df probe-module ((module-loader <module-loader>) (name <sym>) => <module>)
  (let ((module (elt (module-loader-modules module-loader) name)))
    (if (== module nul)
	(load-and-register-module module-loader name)
	module)))

;;; This function keeps track of nesting and registration.
(df load-and-register-module ((loader <module-loader>)
                              (name <sym>)
                              => <module>)
  (let ((stack (module-loader-stack loader))
        (depth (len stack))
        (indent (string-repeat "  " depth)))
  
    ;; First, make sure we aren't already loading this module.
    (when (mem? stack name)
      (error "%s: error: Circular use of %s not allowed" (head stack) name))

    ;; Load the module, using a FIN form to manage the load stack.
    ;; XXX - If an error occurs, we currently neglect to mark
    ;; the environment-implements bindings of the half-created
    ;; module as free.
    (format out "%s[Loading module %s...\n" indent name)
    (let ((mod (seq (pushf (module-loader-stack loader) name)
                    (fin
                      (load-module loader name)
                      (popf (module-loader-stack loader))))))
      (register-module! loader mod)
      (format out "%s]\n" indent)
      mod)))

;;; Create a <module-loader> subclass and override this method.  It should
;;; create and register a module, call 'read-file', objectify the code in
;;; the module's target environment, and do something appropriate with the
;;; resulting ast.
;;;
;;; TODO - Block recursive loads.
;;; TODO - We must eventually be able to support runtime modules, too.
;;; this may require a fair bit of refactoring.
(dg load-module  ((loader <module-loader>)
                  (name <sym>)
                  => <module>))

;;; Export a binding from a module.
(df export-binding! ((module <module>)
		     (name <binding-name>)
		     (binding <module-binding>)
		     => #f)
  (let ((exports (module-exports module)))
    (let ((existing (elt exports name)))
      (unless (or (== existing nul) (== existing binding))
	(error "Tried to export %= and %= from %= as %="
	       existing binding module name)))
    (set (elt exports name) binding)
    #f))

;;; Return true iff a binding was originally defined in the current module.
(df binding-native-to? ((binding <module-binding>) (module <module>) => <log>)
  (== (module-name module) (binding-module-name binding)))

;;; Report all the undefined bindings in the specified module.
(df report-undefined-global-bindings ((mod <module>))
  (do-static-global-bindings
   (fun (binding)
     (when (and (binding-free? binding)
                (binding-native-to? binding mod))
       (format out "%s: warning: undefined binding '%s'.\n"
               (module-name mod)
               (binding-name binding))))
   (module-target-environment mod)))

;;; Compute all the modules which use the specified modules, directly or
;;; indirectly.  Yes, this function is slow and ugly.
(df compute-transitive-users ((loader <module-loader>)
                              (modnames <lst>) => <lst>)
  (let ((users (fab <tab> 100)))
    (loc ((add-user (modname)
            (when (nul? (elt users modname))
              (set (elt users modname) modname)
              (do-module-loader-modules
               (fun (mod)
                 (do
                  (fun (uses-mod)
                    (when (== modname (module-name uses-mod))
                      (add-user (module-name mod))))
                  (environment-uses-modules (module-target-environment mod))))
               loader))))
      (do add-user modnames)
      (collecting ()
        (do (fun (v) (collect v)) users)))))

;;; Remove a single module object from the loader.
;;; This should not be called externally, because it does not bother to
;;; remove other modules which use this one.
(df remove-module-internal! ((loader <module-loader>) (mod <module>))
  ;; If this module defined any foreign bindings, set them back to free.
  (do
   (fun (binding) (set (binding-free? binding) #t))
   (environment-implements (module-target-environment mod)))
  ;; Remove it from our list of modules.
  (del-key (module-loader-modules loader) (module-name mod)))

;;; Unload all the named modules, and all the modules which use them.
(df remove-modules-by-name! ((loader <module-loader>) (modnames <lst>) => #f)
  (let ((remove-names (compute-transitive-users loader modnames)))
    (do
     (fun (modname)
       (let ((mod (elt (module-loader-modules loader) modname)))
         (remove-module-internal! loader mod)))
     remove-names))
  #f)

(export
  set-module-environments
  module-loader-module-type
  do-module-loader-modules
  probe-module
  load-module
  binding-native-to?
  report-undefined-global-bindings
  remove-modules-by-name!)


;;;;=======================================================================
;;;;  Set Up Initial Environments for Objectification
;;;;=======================================================================
;;;;  To objectify code, we need to look up variables in a global
;;;;  environment.  Right now, there are several possible environments:
;;;;   
;;;;    1) The listener's module, known as the "runtime" module, contains
;;;;       one global environment (which is used as both the syntax
;;;;       and the target environment).
;;;;       TODO - Recreate module structure in the listener.
;;;;
;;;;    2) p2c sets up seperate syntax and target environments for each
;;;;       module it compiles.
;;;;       
;;;;       The syntax environments are stripped down versions of the
;;;;       runtime environment.  The compiler uses these environment to
;;;;       process CT and DS forms.  They contains most of the bindings in
;;;;       core proto, but not much else.
;;;;
;;;;       The target environments contain only a few bindings.  The
;;;;       initial bootstrap environments get initialized with a selection
;;;;       of <predefined-bindings>s and a few magic bindings like IF.
;;;;       The target environments of other modules are initially supplied
;;;;       with the magic bindings SEQ and USE, which are enough to allow
;;;;       them to import bindings from other modules.

;;; ENVIRONMENT CREATION 

;; Create a new global environment.
(df fab-static-global-environment 
  ((module <module>)
   (module-loader <module-loader>)
   => <static-global-environment>)
  (let ((new-env (isa <static-global-environment>
                   (set environment-module module)
                   (set environment-module-loader module-loader)
		   (set environment-next $empty-static-environment)
		   (set environment-bindings (fab <tab> 2000)))))
    new-env))

;; Copy the bindings specified by 'names' from 'src-env' to 'dst-env'.
(df copy-environment-bindings ((dst-env <static-global-environment>)
			       (src-env <static-global-environment>)
			       (names <col>)
			       => <static-global-environment>)
  (for ((name names))
    (let ((binding (find-binding name src-env)))
      (if binding
	  (insert-global! binding dst-env)
	  (error "Can't find binding '%=' for copy.\n" name))))
  dst-env)

;; Given an environment and a list of symbols, return a new environment
;; containing only those bindings in the original environment named by
;; the symbols.
(dm fab-subset-environment ((module <module>)
                            (old-env <static-global-environment>)
			    (subset <col>)
			    => <static-global-environment>)
  (let ((new-env
	 (fab-static-global-environment module
                                        (environment-module-loader old-env))))
    (copy-environment-bindings new-env old-env subset)
    new-env))

;;; RUNTIME SETUP
;;; TODO - We smash everything into one top-level module for now.

(dv *runtime-environment* nul)
(dv *runtime-module* nul)
(dv *runtime-module-loader* nul)

(df runtime-environment () *runtime-environment*)
(df runtime-module () *runtime-module*)
(df runtime-module-loader () *runtime-module-loader*)

;; Create the runtime environment for the current image.  This is used
;; to run code typed into the listener, to process 'eval' calls, and so on.
(df init-runtime ()
  (let ((rt-loader (isa <module-loader>))
        (type      (module-loader-module-type rt-loader))
        (rt-module (isa type (set module-name $proto-boot-module-name)))
        (rt-env (fab-static-global-environment rt-module rt-loader)))
    (set-module-environments rt-module rt-env rt-env)

    ;; First, we need to get all the bindings which were built into our
    ;; image by the compiler, and copy them into our new environment.
    (%do-runtime-bindings
     (fun (mod name loc)
       (let ((binding
	      (isa <module-binding>
                (set binding-kind        'runtime)
                (set binding-module-name (as <sym> mod))
		(set binding-name        (as <sym> name))
		(set binding-locative    loc))))
	 (insert-global! binding rt-env))))
    
    ;; Next, we need to copy all our magic bindings into this environment.
    (insert-globals! (magic-bindings) rt-env)
    
    ;; Ask the interpreter to do any setup it will require.
    (init-environment-for-eval rt-env)

    ;; Up until this point, we haven't been able to define any macros in our
    ;; image.  Process the backlog now.
    (do2 (rcurry %%macro rt-env)
	 *boot-macro-names* *boot-macro-expanders*)
    (set *macros-ok?* #t)

    (set *runtime-module-loader* rt-loader)
    (set *runtime-module* rt-module)
    (set *runtime-environment* rt-env)
    #f))

;;; CREATING SYNTAX ENVIRONMENTS

;; These bindings are initially available in CT and DS forms.
;; The section numbers refer to DOC/DOC.TXT.
(dv syntax-environment-bindings
  '(;; Section 1.1/2.1: Special forms.
    ;; Not included: CT, CT-ALSO, DS, USE, EXPORT
    IF SEQ SET FUN LET LOC LAB FIN DV DM DG ISA SLOT MACRO-EXPAND
    NEXT-METHOD QUOTE

    ;; Section 1.2/2.2: Macros.
    DF TRY REP MIF AND OR SELECT CASE INC DEC UNLESS WHEN ASSERT
    FOR COLLECTING PUSHF POPF

    ;; Section 1.3: Read macros.
    quasiquote

    ;; Section 3.1: Any.
    <any> as

    ;; Section 3.2: Comparables.
    == = < ~= ~== > <= >= min max isa? object< object-direct-slots
    object-direct-parents object-slots object-parents object-name

    ;; Section 3.3: Null.
    nul nul?

    ;; Section 3.4: Booleans.
    <log> not

    ;; Section 3.5: Characters.
    <chr> lowercase? uppercase? as-lowercase as-uppercase alphabetic?
    numeric? to-digit eof-object?

    ;; Section 3.6: Numbers.
    ;; Not included: gcd, lcm (which seem to be missing).
    <num> + - * / floor ceiling round truncate floor/ ceiling/ round/
    truncate/ modulo remainder pos? zero? neg? neg abs *print-base*
    num-to-str str-to-num
    <int> logior logxor logand lognot logbit? even? odd? ash lsh
    <flo> flo-bits
    <loc> locative-value locative-value-setter address-of

    ;; Section 3.7: Collections.
    <col> len elt elt-setter empty? empty default fab fabs fill alter any?
    all? reduce reduce+ find-key del-key del-keys do do2 map map2 do-keyed
    map-keyed mem?
    ;; 3.7.1: Iteration protocol.
    ini-state fin-state? nxt-state now-elt now-elt-setter now-key copy-state
    ;; 3.7.2: Maps.
    <map> <assocs> assocs-test
    <tab> table-growth-factor table-growth-threshold table-shrink-threshold
    table-protocol $permanent-hash-state current-gc-state id-hash
    <str-tab> case-insensitive-string-hash case-insensitive-string-equal
    ;; 3.7.3: Sequences.
    <seq> add 1st 2nd 3rd last pos rev rev! cat cat! cat2 sub sub-setter
    pick del del-dups
    ;; 3.7.4 Tuples.
    <tup> tup
    ;; 3.7.5 (the first one): Lists.
    <lst> <list> head tail lst list pair nil push pop
    ;; 3.7.5 (the second one): Optionals.
    <opts>
    ;; 3.7.6 (the first one): Flat sequences.
    <flat> <vec> vec <str> str to-str <buf> buf push-last! pop-last!
    ;; 3.7.6 (the second one):  Ranges.
    <range> from from-by from-to from-to-by from-below from-below-by
    from-above from-above-by
    ;; 3.7.7: Steps.
    <step> first-then

    ;; Section 3.8: Symbols.
    <sym> as make-sym gensym make-setter-name var-name var-type

    ;; Section 3.9: Slots.
    <slot> slot-owner slot-getter slot-setter slot-type slot-init
    slot-value slot-value-setter find-getter find-setter add-slot

    ;; Section 3.10: Functions.
    <fun> fun-name fun-names fun-specs fun-nary? fun-arity fun-value
    identity compose curry rcurry always apply
    <gen> fun-mets gen-add-met sorted-app-mets
    <met> met-app?

    ;; Section 3.11: Conditions.
    <condition> default-handler sig <simple-condition> condition-message
    condition-arguments <serious-condition> <error> error <simple-error>
    <handler> handler-function make-handler handler-matches?

    ;; Section 3.12: Ports.
    <port> <input-port> read-char peek-char char-ready?
    <output-port> newline force-output write-char write-string
    <file-port> <file-input-port> open-input-file close-input-port
    call-with-input-file in
    <file-output-port> open-output-file close-output-port
    call-with-output-file out
    <string-port> port-contents <string-input-port> port-index
    call-with-string-input-port <string-output-port>
    call-with-string-output-port

    ;; Section 3.13: Input.
    read read-from-string read-file

    ;; Section 3.14: Output.
    write display writeln write-to-string format 

    ;; Section 3.15: System.
    app-filename app-args

    ;; Section 3.16: Top level.
    ;; Not included: load eval top.
    ;; Most of these functions have built-in assumptions about which
    ;; environment to use.  Rather than make them work in syntax
    ;; environments, we simply disallow them.
    do-stack-frames backtrace

    ;; Undocumented stuff.  This was all found by a process of trial and
    ;; error, but it needs to be here.
    match-atom match-empty-list match-unquote match-sublist
    sexpr-signature-parameters
    ))

;; Create a new syntax environment for processing macros.
(df fab-syntax-environment ((module <module>) => <static-global-environment>)
  (let ((syn-env (fab-subset-environment module
                                         (runtime-environment)
					 syntax-environment-bindings)))
    (init-environment-for-eval syn-env)
    syn-env))

;;; P2C ENVIRONMENTS
;;; TODO - Figure out what APIs we should export to allow this code to
;;; live in p2c.proto.

(df fab-p2c-module ((loader <module-loader>) (name <sym>) => <module>)
  (let ((type       (module-loader-module-type loader))
        (module     (isa type (set module-name name)))
        (syntax-env (fab-syntax-environment module))
	(target-env (fab-static-global-environment module loader)))
    (set-module-environments module syntax-env target-env)
    (if (== name $proto-boot-module-name)
        (init-p2c-boot-environment target-env)
        (init-p2c-regular-environment target-env loader))
    module))

(export fab-p2c-module)

(df init-p2c-boot-environment ((env <static-global-environment>))
  ;; Copy in just our macros, since everything else
  ;; must be defined by the program being compiled.  And don't bother
  ;; to call 'init-environment-for-eval'--this is a compile-only environment.
  (insert-globals! (magic-bindings) env)
  
  ;; boot.proto uses these macros *before* defining them, so we'll
  ;; need to install temporary copies in the boot environment.
  ;; TODO - Clean up this mess.
  (copy-environment-bindings env (runtime-environment) '(UNLESS WHEN OR AND)))
  
(df init-p2c-regular-environment ((env <static-global-environment>)
                                     (loader <module-loader>))
  ;; Copy the binding for 'use' into the module, so it can ask for more
  ;; bindings as needed.  Copy 'seq', too, because the top-level of the
  ;; file gets wrapped in it.
  (let ((bootmod (probe-module loader $proto-boot-module-name))
        (bootenv (module-target-environment bootmod)))
    (copy-environment-bindings env bootenv '(SEQ USE))))

;;; OTHER ENVIRONMENT CODE

(df init-ast ()
  (init-runtime))

;; Given a static global environment 'env', apply 'f' to all the bindings.
(df do-static-global-bindings ((f <fun>) (env <static-global-environment>))
  (rep loop ((env env))
    (unless (isa? env <static-empty-environment>)
      (do f (frame-bindings env))
      (loop (environment-next env)))))


;;;;=======================================================================
;;;;  Public API
;;;;=======================================================================

(need-implementation
  ast-evaluate
  init-environment-for-eval)

(export
  <alternative>
  alternative-alternant
  alternative-condition
  alternative-consequent
  <application>
  application-arguments
  application-binding
  application-function
  application-known?
  application-known?-setter
  application-tail?
  <arguments>
  assignment-binding
  assignment-form
  assignment-reference
  ast-define-binding
  <ast-function>
  <ast-generic>
  <ast-macro-definition>
  <ast-method>
  <ast-primitive>
  <ast-primitive-definition>
  <bind-exit>
  bind-exit-main-fun
  <binding>
  <module-binding>
  module-binding
  binding-kind
  binding-dynamic-extent?
  binding-dynamic-extent?-setter
  binding-global-box
  binding-global-box-setter
  binding-locative
  binding-module-name
  binding-mutable?
  binding-name
  binding-type
  binding-type-setter
  binding-info
  binding-info-setter
  binding-value
  binding-value-setter
  <bound?>
  bound?-reference
  <compile-time>
  compile-time-program
  <constant>
  constant-value
  <definition>
  def-list
  def-programs
  do-static-global-bindings
  env-object-name
  environment-uses-modules
  <fix-let>
  fix-let-arguments
  fix-let-arguments-setter
  fix-let-types
  fix-let-types-setter
  fix-let-bindings
  fix-let-bindings-setter
  fix-let-body
  fix-let-body-setter
  <ast-signature>
  signature-names
  signature-names-setter
  signature-specs
  signature-specs-setter
  signature-nary?
  signature-nary?-setter
  signature-value
  signature-value-setter
  function-signature
  function-bindings
  function-body
  function-body-setter
  function-name
  function-nary?
  function-value
  <global-assignment>
  <global-box>
  global-box-value
  global-box-value-setter
  <global-reference>
  init-ast
  <local-assignment>
  <local-binding>
  <local-reference>
  <locals>
  locals-bindings
  locals-bindings-setter
  locals-body
  locals-body-setter
  locals-functions
  locals-functions-setter
  %%macro
  module-name
  <monitor>
  monitor-handler
  monitor-info
  monitor-main-thunk
  monitor-test
  monitor-type
  objectify
  <predefined-application>
  <program>
  <computed-program>
  <passive-program>
  program-register program-register-setter
  <programs>
  $proto-boot-module-name
  $proto-runtime-module-name
  <raw-constant>
  <real-reference>
  <reference>
  reference-binding
  reference-called-function?
  reference-called-function?-setter
  reference-frame-number
  reference-frame-offset
  <regular-application>
  report-undefined-global-bindings
  <runtime-assignment>
  runtime-environment
  <runtime-reference>
  <sequential>
  sequentialize
  <static-global-environment>
  <unwind-protect>
  unwind-protect-cleanup-thunk
  unwind-protect-protected-thunk)
