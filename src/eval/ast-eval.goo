;;;; Copyright (c) 2001 Jonathan Bachrach
;;;; BASED ON Lisp In Small Pieces by Christian Queinnec

(use boot)
(use macros)
(use runtime)
(use ast)

;;; ENV

;;; Global binding box support.  Right now, we allocate storage boxes for
;;; each <global-binding> lazily, and we assume the absence of a box 
;;; means the binding is uninitialized.  When we implement a "LISP in
;;; Small Pieces"-style fast intepreter, we may want to change this around.
(dm env-global-binding-value ((b <global-binding>) => <any>)
  (let ((box (binding-global-box b)))
    (if box
	(global-box-value box)
	(error "Unbound binding: %=" (binding-name b)))))

(dm env-global-binding-value-setter (value (b <global-binding>) => <any>)
  (let ((box (binding-global-box b)))
    (unless box
      ;; Lazy box creation.
      ;; TODO - Should we mark this binding non-free at some point?  Ask jrb.
      (set box (set (binding-global-box b) (isa <global-box>))))
    (set (global-box-value box) value)))

(dm env-global-binding-bound? ((b <global-binding>) => <log>)
  (let ((box (binding-global-box b)))
    (if box #t #f)))

;;; <runtime-binding>s don't need boxes--they already have storage space
;;; allocated in the C runtime.
(dm env-runtime-value ((x <loc>))
  (locative-value x))

(dm env-runtime-value-setter (v (x <loc>))
  (set (locative-value x) v))

(dv <loc-env> (isa <any>))
  (slot <loc-env> env-parent         #f)
  (slot <loc-env> env-function       #f)
  (slot <loc-env> (env-names  <lst>) '())
  (slot <loc-env> (env-values <vec>) '())

(dv $nul-loc-env (isa <loc-env>))

(dm env-frame! 
    ((env <loc-env>) function (names <lst>) (args <lst>) => <loc-env>)
  (let ((values (as <vec> args)))
    (isa <loc-env>
      (set env-parent   env)
      (set env-function function)
      (set env-values   values)
      (set env-names    names))))

(dm env-local-value ((env <loc-env>) (i <int>) (j <int>))
  (if (= i 0)
      (elt (env-values env) j)
      (env-local-value (env-parent env) (- i 1) j)))

(dm env-local-value-setter (v (env <loc-env>) (i <int>) (j <int>))
  (if (= i 0)
      (set (elt (env-values env) j) v)
      (set (env-local-value (env-parent env) (- i 1) j) v)))

;; TODO: SHOULD GO AWAY SOON
(dm env-binding-value ((env <loc-env>) (name <sym>) => <any>)
  (if (== env $nul-loc-env)
      nul
      (rep loop ((names (env-names env)) (i 0))
	(if (empty? names)
	    (env-binding-value (env-parent env) name)
	    (if (== name (head names))
		(elt (env-values env) i)
		(loop (tail names) (+ i 1)))))))

(dm env-binding-value-setter (v (env <loc-env>) (name <sym>))
  (rep loop ((names (env-names env)) (i 0))
    (if (empty? names)
	(set (env-binding-value (env-parent env) name) v)
	(if (== name (head names))
	    (set (elt (env-values env) i) v)
	    (loop (tail names) (+ i 1))))))

;;; EVAL

;; TODO - Rename ast-eval to ast-eval-(in|env) and ast-evalutate to ast-eval.
;; Or something like that.
(dm ast-evaluate ((e <program>))
  (ast-eval e $nul-loc-env))

(dg ast-eval ((e <program>) (env <loc-env>)))

(dm ast-eval ((e <constant>) (env <loc-env>))
  (constant-value e))

(dm ast-eval ((e <raw-constant>) (env <loc-env>))
  (constant-value e))

(dm ast-eval ((e <compile-time>) (ee <loc-env>))
  (ast-evaluate (compile-time-program e)))

(dm ast-eval-specs 
    ((specs <lst>) (nary? <log>) (env <loc-env>) => <any>)
  (let ((nreq (if nary? (- (len specs) 1) (len specs))))
    (rep loop ((res '()) (specs specs) (i 0))
      (if (= i nreq)
	  (rev! res)
	  (let ((spec (head specs))
		(type (if spec (ast-eval spec env) <any>)))
	    (loop (pair type res) (tail specs) (+ i 1)))))))

(dv *stack* (fab <buf> 0))

(ds (ifun (,env ,f ,names ,@args) ,body)
  `(fun (,@args)
     (let ((nms
	    (%next-methods))
	   (frame 
	    (env-frame! ;; TODO: SLOW HACK
	     ,env ,f (cat2 ,names (lst '%next-methods)) (lst ,@args nms))))
       ;; (push *stack* frame)
       (,body frame)
       ;; (pop *stack*)
       )))

;; TODO -- CLEAN UP BELOW
(dm as-fun-name ((x <fun>) => <any>)            (fun-name x))
(dm as-fun-name ((x <ast-function>) => <any>)   (as-fun-name (function-name x)))
(dm as-fun-name ((x <global-binding>) => <any>) (binding-name x))
(dm as-fun-name ((x <sym>) => <sym>)            x)
(dm as-fun-name ((x <any>) => <any>)            #f)

(dm export-proto-method (f names specs nary? value body env)
  (let ((efun
	 (select (len names)
	   ((0) (ifun (env f names) body))
	   ((1) (ifun (env f names a1) body))
	   ((2) (ifun (env f names a1 a2) body))
	   ((3) (ifun (env f names a1 a2 a3) body))
	   ((4) (ifun (env f names a1 a2 a3 a4) body))
	   ((5) (ifun (env f names a1 a2 a3 a4 a5) body))
	   ((6) (ifun (env f names a1 a2 a3 a4 a5 a6) body))
	   ((7) (ifun (env f names a1 a2 a3 a4 a5 a6 a7) body))
	   ((8) (ifun (env f names a1 a2 a3 a4 a5 a6 a7 a8) body))
	   ((9) (ifun (env f names a1 a2 a3 a4 a5 a6 a7 a8 a9) body)))))
    ;; TODO: HANDLE MORE THAN 7 CASE
    (set (fun-name  efun) (as-fun-name f))
    (set (fun-sig efun) (isa <sig>
                          (set sig-names names)
                          (set sig-specs (ast-eval-specs specs nary? env))
                          (set sig-nary? nary?)
                          (set sig-arity (- (fun-arity efun) (if nary? 1 0)))
                          (set sig-value (if value (ast-eval value env) <any>))))
    efun))

(dm ast-eval ((e <ast-method>) (env <loc-env>))
  (let ((params (function-bindings e))
	(eval   (fun ((env <loc-env>)) (ast-eval (function-body e) env))))
    (export-proto-method
     e (map binding-name params) (map binding-type params) 
     (function-nary? e) (function-value e) eval env)))

;; (dm ast-eval ((e <ast-primitive>) (env <loc-env>))
;;   (let ((params (function-bindings e))
;; 	   (eval   (fun ((env <loc-env>)) (ast-eval (function-body e) env))))
;;     (make-primitive (map binding-name params) (function-nary? e) eval env)))

(dm ast-eval ((e <ast-generic>) (env <loc-env>))
  (let ((params (function-bindings e))
	(nary?  (function-nary? e))
	(names  (map binding-name params))
	(specs  (ast-eval-specs (map binding-type params) nary? env)))
    (fab-gen (as-fun-name e) names specs nary? '())))

(dm env-local-reference-value ((env <loc-env>) (ref <local-reference>) => <any>)
  (env-local-value
   env (reference-frame-number ref) (reference-frame-offset ref)))

(dm env-local-reference-value-setter 
    (val (env <loc-env>) (ref <local-reference>))
  (set (env-local-value 
	env (reference-frame-number ref) (reference-frame-offset ref)) 
       val))

(dm ast-eval ((e <local-reference>) (env <loc-env>))
  (env-local-reference-value env e))

(dm ast-eval ((e <global-reference>) (env <loc-env>))
  (env-global-binding-value (reference-binding e)))

(dm ast-eval ((e <runtime-reference>) (env <loc-env>))
  (env-runtime-value (binding-locative (reference-binding e))))

(dm ast-eval ((e <bound?>) (env <loc-env>))
  (ast-eval-bound? e (reference-binding (bound?-reference e)) env))

(dm ast-eval-bound? ((e <bound?>) (binding <global-binding>) (env <loc-env>))
  (env-global-binding-bound? binding))

(dm ast-eval-bound? ((e <bound?>) (binding <runtime-binding>) (env <loc-env>))
  #t)

(dm ast-eval-bound? ((e <bound?>) (binding <local-binding>) (env <loc-env>))
  #t)

(dm ast-eval ((e <global-assignment>) (env <loc-env>))
  (let ((value (ast-eval (assignment-form e) env)))
    (set (env-global-binding-value (assignment-binding e)) value)))

(dm ast-eval ((e <ast-macro-definition>) (env <loc-env>))
  #f) ;; PERFORMED DURING OBJECTIFICATION

(dm ast-eval ((e <runtime-assignment>) (env <loc-env>))
  (let ((value (ast-eval (assignment-form e) env)))
    (set (env-runtime-value (binding-locative (assignment-binding e)))
	 value)))

(dm ast-eval ((e <local-assignment>) (env <loc-env>))
  (let ((value (ast-eval (assignment-form e) env)))
    (set (env-local-reference-value env (assignment-reference e)) value)))

(dm env-define-binding! ((b <runtime-binding>) v)
  (set (env-runtime-value (binding-locative b)) v))

(dm env-define-binding! ((b <global-binding>) v)
  (set (env-global-binding-value b) v))

(dm ast-eval ((e <definition>) (env <loc-env>))
  (let ((value (ast-eval (assignment-form e) env)))
    (env-define-binding! (assignment-binding e) value)
    #f))

;; (dv <box> (isa <any>))
;;   (slot <box> box-value)
;; 
;; (dm ast-eval ((e <box-read>) (env <loc-env>))
;;   (box-value (ast-eval (box-reference e) env)))
;; 
;; (dm ast-eval ((e <box-write>) (env <loc-env>))
;;   (set (box-value (ast-eval (box-reference e) env))
;;        (ast-eval (box-form e) env)))
;; 
;; (dm ast-eval ((e <box-creation>) (env <loc-env>))
;;   (set (env-binding-value 
;;          env (binding-name (reference-binding (box-reference e))))
;;        (isa <box>)))

(dm ast-eval ((e <alternative>) (env <loc-env>))
  (if (ast-eval (alternative-condition e) env)
      (ast-eval (alternative-consequent e) env)
      (ast-eval (alternative-alternant e) env)))

(dm ast-eval ((e <sequential>) (env <loc-env>))
  (rep eval ((e e))
    (let ((nxt (tail e))
	  (val (ast-eval (head e) env)))
      (if (empty? nxt)
	  val
	  (eval nxt)))))

(dm ast-eval ((e <arguments>) (env <loc-env>))
  (rep eval ((res '()) (args e))
    (if (empty? args)
	(rev! res)
	(eval (pair (ast-eval (head args) env) res) (tail args)))))

(dm ast-eval ((e <regular-application>) (env <loc-env>))
  (let ((f    (ast-eval (application-function e) env))
	(args (ast-eval (application-arguments e) env)))
    (apply f args)))

(dm ast-eval ((e <predefined-application>) (env <loc-env>))
  (let ((b (application-binding e)))
    (if (== (binding-name b) '%next-methods)
	(let ((nms (env-binding-value env '%next-methods)))
	  (if (== nms nul) #f nms))
	(let ((f    (binding-value b))
	      (args (ast-eval (application-arguments e) env)))
	  (apply f args)))))

(dm ast-eval ((e <fix-let>) (env <loc-env>))
  (let ((args (ast-eval (fix-let-arguments e) env))
	(nenv (env-frame! env #f (map binding-name (fix-let-bindings e)) args)))
    (ast-eval (fix-let-body e) nenv)))

(dm ast-eval ((e <locals>) (env <loc-env>))
  (let ((bindings
	 (locals-bindings e))
	(new-env 
	 (env-frame!
	  env #f (map binding-name bindings) (map (always nul) bindings))))
    (do2 (fun (name value) 
	   (set (env-binding-value new-env name) value))
	 (map binding-name bindings)
	 (map (rcurry ast-eval new-env) (locals-functions e)))
    ;; (rep loop ((funs (locals-functions e)) (i 0))
    ;;   (unless (empty? funs)
    ;;     (set (env-local-value new-env 0 i) 
    ;;          (ast-eval (head funs) new-env))
    ;;     (loop (tail funs) (+ i 1))))
    (ast-eval (locals-body e) new-env)))

(dm ast-eval ((e <bind-exit>) (env <loc-env>))
  (lab return
    (let ((rproc (fun ((env <loc-env>)) 
		   (return (env-binding-value env 'x))))
	  (exit  (export-proto-method rproc (lst 'x) (lst #f) #f #f rproc env)))
      ((ast-eval (bind-exit-main-fun e) env) exit))))

(dm ast-eval ((e <unwind-protect>) (env <loc-env>))
  (fin ((ast-eval (unwind-protect-protected-thunk e) env))
       ((ast-eval (unwind-protect-cleanup-thunk e) env))))

(dm ast-eval ((e <monitor>) (env <loc-env>))
  (%with-monitor
   (ast-eval (monitor-handler e) env)
   (ast-eval (monitor-main-thunk e) env)))

;;; ENVIRONMENT

;; Add any bindings required by the interpreter to an environment.
;; The function '%pair' is a compile-time primitive.  Unfortunately, the
;; objectifier inserts it into some of the code it generates, so we need
;; to add a run-time shadow.
;; TODO - This function smells bad.
(df init-environment-for-eval ((env <static-global-environment>))
  (let ((b (ast-define-binding env '%pair #f (fun () (isa <global-binding>)))))
    (set (env-global-binding-value b) pair)))

(export
  ast-evaluate
  init-environment-for-eval)
