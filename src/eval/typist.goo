;;;; Copyright 2002, Jonathan Bachrach.  See file TERMS.

(use goo)
(use goo/boot)
(use eval/ast)

(dv <bot> #f) ;; TODO:

(dm unconstrained-type? (b|<program> => <log>)
  #f)

(dm unconstrained-type? (b|<module-binding> => <log>)
  (and (== (binding-module-name b) 'goo/boot) (== (binding-name b) '<any>)))

(dm unconstrained-type? (o|<module-binding-reference> => <log>)
  (unconstrained-type? (reference-binding o)))

(dm type-union (x|<type> y|<type> => <union>)
  (cond
    ((subtype? x y) y)
    ((subtype? y x) x)
    ((isa? x <union>) 
     (new <union> 
       union-elts 
         (if (isa? y <union>)
             (cat x y)
             (pair y x))))
    (#t 
     (new <union> 
       union-elts 
         (if (isa? y <union>)
             (pair x y)
             (lst x y))))))

(dm type-infer-check (inferred-type type)
  ;; (msg out "IT %= T %=\n" inferred-type type)
  (if (isa? inferred-type type) 
      inferred-type
      type))

(dm type-infer (x|<program>)
  (def type (program-type x))
  (if (== type <bot>) 
      (set (program-type x) (do-type-infer x))
      type))

(dm do-type-infer (x|<program>)
  (error "NYI"))

(dm do-type-infer (x|<constant>)
  (class-of (constant-value x)))

(dm do-type-infer (x|<assignment>)
  (type-infer (assignment-form x)))

(dm type-infer-binding (x|<binding>)
  ;; TODO: PRETTY LIMITED
  <any>)

(dm type-infer-binding (x|<local-binding>)
  ;; (msg out "LB %=" x)
  (if (binding-mutable? x)
      <any>
      (type-infer-check (type-infer (binding-type x))
                        (binding-inferred-type x))))

(dm do-type-infer (x|<real-reference>)
  (type-infer-binding (reference-binding x)))

(dm do-type-infer (x|<bound?>)
  <log>)

(dm do-type-infer (x|<definition>)
  (t= #f))

(dm do-type-infer (x|<ast-method>)
  (type-infer (function-body x))
  ;; TODO: TIGHTEN UP
  <met>)

(dm do-type-infer (x|<ast-generic>)
  <gen>)

(dm do-type-infer (x|<alternative>)
  (type-union (type-infer (alternative-consequent x))
              (type-infer (alternative-alternant x))))

(dm do-type-infer (x|<sequential>)
  (type-infer (last x)))

(dm do-type-infer (x|<fix-let>)
  (for ((binding (fix-let-bindings x))
        (type    (fix-let-types x))
        (arg     (fix-let-arguments x)))
    (unless (binding-mutable? binding)
      (set (binding-inferred-type binding) (type-infer arg))))
  (type-infer (fix-let-body x)))

;; TODO: the following are incomplete

(dm do-type-infer (x|<locals>)
  (do type-infer (locals-functions x))
  (type-infer (locals-body x)))

(dm do-type-infer (x|<loop>)
  (type-infer (loop-body x)))

(dm do-type-infer (x|<regular-application>)
  <any>)

(dm do-type-infer (x|<bind-exit>)
  <any>)

(dm do-type-infer (x|<unwind-protect>)
  <any>)

(dm do-type-infer (x|<monitor>)
  <any>)

(export type-infer
        unconstrained-type?)
