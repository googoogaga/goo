;;; Copyright (c) 2001 Jonathan Bachrach
;;;; BASED ON Lisp In Small Pieces by Christian Queinnec

;;; WALKER

(dm update-walk! (g o (args ...))
  ;; (format out "WALKING %=\n" o)
  (for ((slot (object-slots o)))
    ;; (format out "  SLOT %=\n" slot)
    (let ((getter (slot-getter slot)))
      (unless (== getter binding-value) ;; TODO: HACK
	(let ((x (slot-value o getter)))
	  (when (isa? x <program>)
	    ;; (format out "    UPDATING %=\n" x)
	    (set (slot-value o getter) (apply g (pair x args))))))))
  o)

;;; BOXING

(dv <box-read> (isa <program>))
  (slot <box-read> box-reference)

(dv <box-write> (isa <program>))
  (slot <box-write> box-reference)
  (slot <box-write> box-form)

(dv <box-creation> (isa <program>))
  (slot <box-creation> box-reference)

(dm insert-box! ((o <program>))
  (update-walk! insert-box! o))

(dm insert-box! ((o <local-reference>))
  (if (binding-mutable? (reference-binding o))
      (isa <box-read> (set box-reference o))
      o))

(dm insert-box! ((o <local-assignment>))
  (isa <box-write> 
       (set box-reference (assignment-reference o))
       (set box-form      (insert-box! (assignment-form o)))))

(dm insert-box! ((o <ast-method>))
  (set (function-body o)
       (insert-box! (boxify-mutable-bindings
		     (function-body o) (function-bindings o))))
  o)

(dm insert-box! ((o <fix-let>))
  (set (fix-let-arguments o)
       (insert-box! (fix-let-arguments o)))
  (set (fix-let-body o)
       (insert-box! 
	(boxify-mutable-bindings (fix-let-body o) (fix-let-bindings o))))
  o)

(dm insert-box! ((o <locals>))
  (set (locals-functions o)
       (map insert-box! (locals-functions o)))
  (set (locals-body o)
       (insert-box!
	(boxify-mutable-bindings (locals-body o) (locals-bindings o))))
  o)

(dm boxify-mutable-bindings (form (bindings <lst>))
  (sequentialize
    (rep loop ((res '()) (bindings bindings))
      (if (empty? bindings)
	  (rev! (pair form res))
	  (let ((binding (head bindings)))
	    (if (binding-mutable? binding)
		(let ((creator 
		       (isa <box-creation>
			 (set box-reference
			      (isa <local-reference>
				(set reference-binding binding))))))
		  (loop (pair creator res) (tail bindings)))
		(loop res (tail bindings))))))))

(dm sexp->object (exp r)
  (insert-box! (objectify exp r #f)))

;;; DYNAMIC-EXTENT ANALYSIS

(dm do-do-call-references! ((o <program>))
  (update-walk! do-call-references! o))

(dm do-call-references! ((o <program>))
  (do-do-call-references! o))

(dm do-call-references! ((o <regular-application>))
  (do-do-call-references! o)
  (if (isa? (application-function o) <local-reference>)
      (set (reference-called-function? (application-function o)) #t))
  o)

(dm do-call-references! ((o <locals>))
  (do-do-call-references! o)
  (do do-call-references! (locals-functions o))
  o)

(dm analyze-call-references (o)
  (do-call-references! o))

(dm do-do-dynamic-extent! ((o <program>))
  (update-walk! do-dynamic-extent! o))

(dm do-dynamic-extent! ((o <program>))
  (do-do-dynamic-extent! o))

(dm do-dynamic-extent! ((o <local-reference>))
  (do-do-dynamic-extent! o)
  (unless (reference-called-function? o)
    (set (binding-dynamic-extent? (reference-binding o)) #f))
  o)

(dm do-dynamic-extent! ((o <locals>))
  (do-do-dynamic-extent! o)
  (do do-dynamic-extent! (locals-functions o))
  o)

(dm analyze-dynamic-extent (o)
  (analyze-call-references o)
  (do-dynamic-extent! o))

;;; FLATTENING

(def-list free-environment (isa <program>))

(dm number-of ((o <free-environment>) => <int>)
  (if (empty-free-environment? o)
      0
      (+ (number-of (free-environment-tail o)) 1)))

(dv <flat-function> (isa <ast-method>))
  (slot <flat-function> (function-free <free-environment>)
	$empty-free-environment)

(dv <free-reference> (isa <real-reference>))
  (slot <free-reference> (reference-offset (type-or <int> #f)))
  (slot <free-reference> (reference-self? <log>))

(dm lift! (o)
  (lift-procedures! o #f '()))

(dm lift-procedures! ((o <program>) flat-fun bindings)
  (update-walk! lift-procedures! o flat-fun bindings))

(dm lift-procedures! ((o <local-reference>) flat-fun bindings)
  (let ((b (reference-binding o)))
    (if (mem? bindings b)
	o
	(let ((offset (adjoin-free-binding! flat-fun o)))
	  (isa <free-reference> 
	    (set reference-binding b)
	    (set reference-offset offset)
	    (set reference-self?
		 (== (reference-binding o) (function-name flat-fun))))))))

(dm adjoin-free-binding! ((flat-fun <flat-function>) ref => <int>)
  (rep check (((i <int>) 0) (free* (function-free flat-fun)))
    (if (empty-free-environment? free*)
	(let ((new-env
	       (isa <free-environment> 
		 (set free-environment-head ref)
		 (set free-environment-tail (empty-free-environment)))))
	  (if (empty-free-environment? (function-free flat-fun))
	      (set (function-free flat-fun) new-env)
	      (rep add ((free* (function-free flat-fun)))
		(let ((tail (free-environment-tail free*)))
		  (if (empty-free-environment? tail)
		      (set (free-environment-tail free*) new-env)
		      (add tail)))))
	  i)
	(if (== (reference-binding ref)
		(reference-binding (free-environment-head free*)))
	    i
	    (check (+ i 1) (free-environment-tail free*))))))

(dm lift-procedures! ((o <fix-let>) flat-fun bindings)
  (set (fix-let-arguments o)
       (lift-procedures! (fix-let-arguments o) flat-fun bindings))
  (let ((new-bindings
	 (cat (fix-let-bindings o) bindings)))
    (set (fix-let-body o)
	 (lift-procedures! (fix-let-body o) flat-fun new-bindings))
    o))

(dm lift-procedures! ((o <locals>) flat-fun bindings)
  (let ((new-bindings (cat (locals-bindings o) bindings)))
    (set (locals-functions o)
	 (map (rcurry lift-procedures! flat-fun new-bindings) 
	      (locals-functions o)))
    (set (locals-body o)
	 (lift-procedures! (locals-body o) flat-fun new-bindings))
    o))

(dm lift-procedures! ((o <ast-primitive>) flat-fun bindings)
  (set (function-body o)
       (lift-procedures! (function-body o) #f (function-bindings o)))
  o)

(dm lift-procedures! ((o <ast-generic>) flat-fun bindings)
  o)

(dm lift-procedures! ((o <ast-function>) flat-fun bindings)
  (let ((local-bindings 
	 (function-bindings o))
	(body           
	 (function-body o))
	(new-fun        
	 (isa <flat-function> 
	   (set function-name     (function-name o))
	   (set function-bindings local-bindings)
	   (set function-nary?    (function-nary? o))
	   (set function-value    (function-value o))
	   (set function-body     body)
	   (set function-free     (empty-free-environment)))))
    (set (function-body new-fun)
	 (lift-procedures! body new-fun local-bindings))
    (let ((free* (function-free new-fun)))
      (set (function-free new-fun) 
	   (lift-procedures! free* flat-fun bindings)))
    new-fun))

;;; COLLECTING QUOTATIONS AND FUNCTIONS

(dv <flattened-program> (isa <program>))
  (slot <flattened-program> (program-form (type-or <program> #f)))
  (slot <flattened-program> program-quotations '())
  (slot <flattened-program> program-definitions '())

(dv <top-level-form> (isa <program>))
  (slot <top-level-form> (form-program <program>))
  (slot <top-level-form> form-quotations '())
  (slot <top-level-form> form-definitions '())

(dv <quotation-binding> (isa <binding>))
  (slot <quotation-binding> binding-value)

(dv <function-definition> (isa <flat-function>))
  (slot <function-definition> function-index)
  (slot <function-definition> function-temporaries '())
  (slot <function-definition> function-self-recursive? #f)

(dv <primitive-definition> (isa <ast-primitive>))
  (slot <primitive-definition> function-temporaries '())
  (slot <primitive-definition> function-self-recursive? #f)

(dv <closure-creation> (isa <program>))
  (slot <closure-creation> closure-creation-index)
  (slot <closure-creation> closure-creation-bindings)
  (slot <closure-creation> closure-creation-free)

(dm flatten-seqs (o)
  (lst o))

(dm flatten-seqs ((o <sequential>))
  (rep loop ((s o) (r '()))
     (if (empty-sequential? s)
	 (rev! r)
	 (rep inner ((ss (flatten-seqs (sequential-head s))) (r r))
           (if (empty? ss)
	       (loop (sequential-tail s) r)
	       (inner (tail ss) (pair (head ss) r)))))))

(dm as-top-level-forms (programs)
  (map (fun (x) (isa <top-level-form> (set form-program x))) programs))

(dm extract-things! (o)
  (let ((forms (as-top-level-forms (flatten-seqs o)))
	(result (isa <flattened-program>)))
    (set (program-form result)
	 (sequentialize
	  (map (fun (form) (extract! form form result)) forms)))
    result))

(dm extract! 
    ((o <program>) (form <top-level-form>) (result <flattened-program>))
  (update-walk! extract! o form result))

(dm extract! 
    ((o <locals>) (form <top-level-form>) (result <flattened-program>))
  (set (locals-functions o)
       (map (rcurry extract! form result) (locals-functions o)))
  (extract! (locals-body o) form result)
  o)

(dm extract! 
    ((o <constant>) (form <top-level-form>) (result <flattened-program>))
  (let ((value (constant-value o)))
    (if (or (== value #f) (== value #t) (== value '()))
	o
	(let ((qb*   (program-quotations result))
	      (index (len qb*))
	      (qb    (isa <quotation-binding> 
		       (set binding-name index) (set binding-value value))))
	  (set (program-quotations result) (pair qb qb*))
	  (set (form-quotations form)      (pair qb (form-quotations form)))
	  (isa <global-reference> (set reference-binding qb))))))

(dm extract! 
    ((o <raw-constant>) (form <top-level-form>) (result <flattened-program>))
  o)

(dm extract! 
    ((o <flat-function>) 
     (form <top-level-form>) (result <flattened-program>))
  (let ((new-body (extract! (function-body o) form result))
	(name     (function-name o))
	(bindings (function-bindings o))
	(nary?    (function-nary? o))
	(value    (function-value o)))
    (do (fun (binding)
	  (set (binding-type binding) 
	       (extract! (binding-type binding) form result)))
	bindings)
    (let ((free-bindings 
	   (rep extract ((free (function-free o)))
	     (if (empty-free-environment? free)
		 '()
		  (pair (reference-binding (free-environment-head free))
			(extract (free-environment-tail free))))))
	  (index
	   (adjoin-definition!
	    form result name bindings nary? value new-body free-bindings)))
      (isa <closure-creation> 
	(set closure-creation-index    index)
	(set closure-creation-bindings bindings)
	(set closure-creation-free     (function-free o))
	;; TODO: WHY THE FOLLOWING?
	;; (set closure-creation-body     new-body)
	))))

(dm extract! 
    ((o <ast-primitive-definition>) 
     (form <top-level-form>) (result <flattened-program>))
  (let ((p    (assignment-form o))
	(body (extract! (function-body p) form result))
	(definition
	 (isa <primitive-definition> 
	   (set function-name     (function-name p))
	   (set function-bindings (function-bindings p))
	   (set function-value    (function-value p))
	   (set function-body     body))))
    ;; (assert (function-name p) "NO NAME FOR %=" p)
    (set (program-definitions result)
	 (pair definition (program-definitions result)))
    (set (form-definitions form)
	 (pair definition (form-definitions form)))
    (extract! (isa <constant> (set constant-value #f)) form result)))

(dm adjoin-definition! 
    ((form <top-level-form>) (result <flattened-program>) 
     name bindings nary? value body free)
  (let ((definitions
	 (program-definitions result))
	(new-index
	 (len definitions))
	(definition
	 (isa <function-definition> 
	   (set function-name     name)
	   (set function-bindings bindings)
	   (set function-nary?    nary?)
	   (set function-value    value)
           (set function-body     body)
	   (set function-free     free)
	   (set function-index    new-index))))
    (set (program-definitions result) (pair definition definitions))
    (set (form-definitions form)      (pair definition (form-definitions form)))
    new-index))

(dm closurize-main! 
    ((o <flattened-program>) r => <flattened-program>)
  (let ((index
	 (len (program-definitions o)))
	(name
	 '*---MAIN---*) ;; TODO: MAKE THIS HIDDEN
	(binding
	 (ast-define-binding r name (fun () (isa <predefined-binding>))))
	(defn
	 (isa <primitive-definition>
	   (set function-name     binding)
           (set function-bindings '())
	   (set function-body     (program-form o))
	   (set function-index    index)))
	(call
	 (isa <predefined-application> 
           (set application-binding   binding)
	   ;; (set application-function  
	   ;;      (isa <closure-creation> 
           ;;        (set function-index        index)
	   ;;        (set function-bindings     '())
	   ;;        (set closure-creation-free (empty-free-environment))))
	   (set application-arguments (empty-arguments))
	   (set application-tail?     #f)
	   )))
    ;; TODO: reverse definitions in forms
    (set (program-definitions o)
	 (rev! (pair defn (program-definitions o))))
    (set (program-form o)
	 (isa <top-level-form> 
	   (set form-program call)
	   (set form-definitions (lst defn))))
    o))

;; (def f (fun (n k) (if (= n 0) (k 1) (f (- n 1) (fun (r) (k (* n r)))))))

(dm gather-temporaries! ((o <program>))
  (set (program-definitions o)
       (map (fun (def)
	      (collect-temporaries! def def '()))
	    (program-definitions o)))
  o)

(dm collect-temporaries! ((o <program>) flat-fun r)
  (update-walk! collect-temporaries! o flat-fun r))

(dm collect-temporaries! ((o <local-reference>) flat-fun r)
  (let ((binding (reference-binding o))
	(b       (assocq binding r)))
    (if b
	(isa <local-reference> (set reference-binding (assoc-value b)))
	o)))

(dm collect-temporaries! ((o <fix-let>) flat-fun r)
  (set (fix-let-arguments o)
       (collect-temporaries! (fix-let-arguments o) flat-fun r))
  (let ((new-bindings
	 (map new-renamed-binding (fix-let-bindings o)))
	(new-r
	 (cat (map2 assoc (fix-let-bindings o) new-bindings) r)))
    (adjoin-temporary-variables! flat-fun new-bindings)
    (set (fix-let-bindings o)
	 new-bindings)
    (set (fix-let-body o)     
	 (collect-temporaries! (fix-let-body o) flat-fun new-r))
    o))

(dm collect-temporaries! ((o <locals>) flat-fun r)
  (let ((new-bindings
	 (map new-renamed-binding (locals-bindings o)))
	(new-r
	 (cat (map2 assoc (locals-bindings o) new-bindings) r)))
    (set (locals-functions o)
	 (map (rcurry collect-temporaries! flat-fun new-r) (locals-functions o)))
    (adjoin-temporary-variables! flat-fun new-bindings)
    (set (locals-bindings o) new-bindings)
    (set (locals-body o)
	 (collect-temporaries! (locals-body o) flat-fun new-r))
    o))

(dm adjoin-temporary-variables! (flat-fun new-bindings)
  (rep adjoin 
      ((temps (function-temporaries flat-fun)) (bindings new-bindings))
    (if (empty? bindings)
	(set (function-temporaries flat-fun) temps)
	(if (mem? temps (head bindings))
	    (adjoin temps (tail bindings))
	    (adjoin (pair (head bindings) temps) (tail bindings))))))

(dv <renamed-local-binding> (isa <local-binding>))
  (slot <renamed-local-binding> binding-index)

(dv *renaming-bindings-counter* 0)

(dm new-renamed-binding ((binding <local-binding>))
  (set *renaming-bindings-counter* (+ *renaming-bindings-counter* 1))
  (isa <renamed-local-binding>      ;; TODO: SHOULD USE CLONING
       (set binding-name            (binding-name binding))
       (set binding-type            (binding-type binding))
       (set binding-dynamic-extent? (binding-dynamic-extent? binding))
       (set binding-index           *renaming-bindings-counter*)))
