;;; Copyright (c) 2001 Jonathan Bachrach
;;;; BASED ON Lisp In Small Pieces by Christian Queinnec

;;; WALKER

(dm update-walk! (g o (args ...))
  ;; (format out "WALKING %=\n" o)
  (for ((slot (object-slots o)))
    ;; (format out "  SLOT %=\n" slot)
    (let ((getter (slot-getter slot)))
      (unless (== getter binding-value) ;; TODO: HACK
	(let ((x (slot-value o getter)))
	  (when (isa? x <program>)
	    ;; (format out "    UPDATING %=\n" x)
	    (set (slot-value o getter) (apply g (pair x args))))))))
  o)

;;; BOXING

(dv <box-read> (isa <program>))
  (slot <box-read> box-reference)

(dv <box-write> (isa <program>))
  (slot <box-write> box-reference)
  (slot <box-write> box-form)

(dv <box-creation> (isa <program>))
  (slot <box-creation> box-reference)

(dm insert-box! ((o <program>))
  (update-walk! insert-box! o))

(dm insert-box! ((o <local-reference>))
  (if (binding-mutable? (reference-binding o))
      (isa <box-read> (set box-reference o))
      o))

(dm insert-box! ((o <local-assignment>))
  (isa <box-write> 
       (set box-reference (assignment-reference o))
       (set box-form      (insert-box! (assignment-form o)))))

(dm insert-box! ((o <ast-method>))
  (set (function-body o)
       (insert-box! (boxify-mutable-bindings
		     (function-body o) (function-bindings o))))
  o)

(dm insert-box! ((o <fix-let>))
  (set (fix-let-arguments o)
       (insert-box! (fix-let-arguments o)))
  (set (fix-let-body o)
       (insert-box! 
	(boxify-mutable-bindings (fix-let-body o) (fix-let-bindings o))))
  o)

(dm insert-box! ((o <locals>))
  (set (locals-functions o)
       (map insert-box! (locals-functions o)))
  (set (locals-body o)
       (insert-box!
	(boxify-mutable-bindings (locals-body o) (locals-bindings o))))
  o)

(dm boxify-mutable-bindings (form (bindings <lst>))
  (sequentialize
    (rep loop ((res '()) (bindings bindings))
      (if (empty? bindings)
	  (rev! (pair form res))
	  (let ((binding (head bindings)))
	    (if (binding-mutable? binding)
		(let ((creator 
		       (isa <box-creation>
			 (set box-reference
			      (isa <local-reference>
				(set reference-binding binding))))))
		  (loop (pair creator res) (tail bindings)))
		(loop res (tail bindings))))))))

(dm sexp->object (exp r)
  (insert-box! (objectify exp r #f)))

;;; DYNAMIC-EXTENT ANALYSIS

(dm do-do-call-references! ((o <program>))
  (update-walk! do-call-references! o))

(dm do-call-references! ((o <program>))
  (do-do-call-references! o))

(dm do-call-references! ((o <regular-application>))
  (do-do-call-references! o)
  (if (isa? (application-function o) <local-reference>)
      (set (reference-called-function? (application-function o)) #t))
  o)

(dm analyze-call-references (o)
  (do-call-references! o))

(dm do-do-dynamic-extent! ((o <program>))
  (update-walk! do-dynamic-extent! o))

(dm do-dynamic-extent! ((o <program>))
  (do-do-dynamic-extent! o))

(dm do-dynamic-extent! ((o <local-reference>))
  (do-do-dynamic-extent! o)
  (unless (reference-called-function? o)
    (set (binding-dynamic-extent? (reference-binding o)) #f))
  o)

(dm analyze-dynamic-extent (o)
  (analyze-call-references o)
  (do-dynamic-extent! o))

;;; CALL ANALYSIS

(dm do-do-call-upgrades! ((o <program>))
  (update-walk! do-call-upgrades! o))

(dm do-call-upgrades! ((o <program>))
  (do-do-call-upgrades! o))

(dm unconstrained-type? ((o <program>) => <log>)
  (and (isa? o <global-reference>) 
       (== (binding-name (reference-binding o)) '<any>)))

(dm do-call-upgrades! ((o <regular-application>))
  (do-do-call-upgrades! o)
  (if (isa? (application-function o) <local-reference>)
      (let ((met (binding-value (reference-binding (application-function o)))))
	(if (and (isa? met <ast-function>)
		 (all? (compose unconstrained-type? binding-type)
		       (function-bindings met))
		 (unconstrained-type? (function-value met))
		 (not (function-nary? met))
		 (= (len (application-arguments o))
		    (len (function-bindings met))))
	    (set (application-known? o) #t))))
  o)

(dm analyze-calls (o)
  (do-call-upgrades! o))

;;; FLATTENING

(def-programs free-environment)

(dv <flat-function> (isa <ast-method>))
  (slot <flat-function> (function-free <free-environment>)
	(empty <free-environment>))

(dv <free-reference> (isa <real-reference>))
  (slot <free-reference> (reference-offset (type-or <int> #f)))
  (slot <free-reference> (reference-self? <log>))

(dm lift! (o)
  (lift-procedures! o #f '()))

(dm lift-procedures! ((o <program>) flat-fun bindings)
  (update-walk! lift-procedures! o flat-fun bindings))

(dm lift-procedures! ((o <local-reference>) flat-fun bindings)
  (let ((b (reference-binding o)))
    (if (mem? bindings b)
	o
	(let ((offset (adjoin-free-binding! flat-fun o)))
	  (isa <free-reference> 
	    (set reference-binding b)
	    (set reference-offset offset)
	    (set reference-self?
		 (== (reference-binding o) (function-name flat-fun))))))))

(dm adjoin-free-binding! ((flat-fun <flat-function>) ref => <int>)
  (rep check (((i <int>) 0) (free* (function-free flat-fun)))
    (if (empty? free*)
	(let ((new-env (free-environment ref (empty <free-environment>))))
	  (if (empty? (function-free flat-fun))
	      (set (function-free flat-fun) new-env)
	      (rep add ((free* (function-free flat-fun)))
		(let ((tail (tail free*)))
		  (if (empty? tail)
		      (set (tail free*) new-env)
		      (add tail)))))
	  i)
	(if (== (reference-binding ref)
		(reference-binding (head free*)))
	    i
	    (check (+ i 1) (tail free*))))))

(dm lift-procedures! ((o <fix-let>) flat-fun bindings)
  (set (fix-let-arguments o)
       (lift-procedures! (fix-let-arguments o) flat-fun bindings))
  (let ((new-bindings
	 (cat (fix-let-bindings o) bindings)))
    (set (fix-let-body o)
	 (lift-procedures! (fix-let-body o) flat-fun new-bindings))
    o))

(dm lift-procedures! ((o <locals>) flat-fun bindings)
  (let ((new-bindings (cat (locals-bindings o) bindings)))
    (set (locals-functions o)
	 (map (rcurry lift-procedures! flat-fun new-bindings) 
	      (locals-functions o)))
    (set (locals-body o)
	 (lift-procedures! (locals-body o) flat-fun new-bindings))
    o))

(dm lift-procedures! ((o <ast-primitive>) flat-fun bindings)
  (set (function-body o)
       (lift-procedures! (function-body o) #f (function-bindings o)))
  o)

(dm lift-procedures! ((o <ast-generic>) flat-fun bindings)
  o)

(dm lift-procedures! ((o <ast-function>) flat-fun bindings)
  (let ((local-bindings 
	 (function-bindings o))
	(body           
	 (function-body o))
	(new-fun        
	 (isa <flat-function> 
	   (set function-name     (function-name o))
	   (set function-bindings local-bindings)
	   (set function-nary?    (function-nary? o))
	   (set function-value    (function-value o))
	   (set function-body     body)
	   (set function-free     (empty <free-environment>)))))
    (set (function-body new-fun)
	 (lift-procedures! body new-fun local-bindings))
    (let ((free* (function-free new-fun)))
      (set (function-free new-fun) 
	   (lift-procedures! free* flat-fun bindings)))
    new-fun))

;;; COLLECTING QUOTATIONS AND FUNCTIONS

(dv <flattened-program> (isa <program>))
  (slot <flattened-program> (program-form (type-or <program> #f)))
  (slot <flattened-program> program-quotations '())
  (slot <flattened-program> program-definitions '())

(dv <top-level-form> (isa <program>))
  (slot <top-level-form> (form-program <program>))
  (slot <top-level-form> form-quotations '())
  (slot <top-level-form> form-definitions '())

(dv <quotation-binding> (isa <binding>))
  (slot <quotation-binding> binding-value)

(dv <function-definition> (isa <flat-function>))
  (slot <function-definition> function-index)
  (slot <function-definition> function-temporaries '())
  (slot <function-definition> function-self-recursive? #f)

(dv <primitive-definition> (isa <ast-primitive>))
  (slot <primitive-definition> function-temporaries '())
  (slot <primitive-definition> function-self-recursive? #f)

(dv <closure-creation> (isa <program>))
  (slot <closure-creation> closure-creation-index)
  (slot <closure-creation> closure-creation-bindings)
  (slot <closure-creation> closure-creation-free)

(dm flatten-seqs (o)
  (lst o))

(dm flatten-seqs ((o <sequential>))
  (rep loop ((s o) (r '()))
     (if (empty? s)
	 (rev! r)
	 (rep inner ((ss (flatten-seqs (head s))) (r r))
           (if (empty? ss)
	       (loop (tail s) r)
	       (inner (tail ss) (pair (head ss) r)))))))

(dm as-top-level-forms (programs)
  (map (fun (x) (isa <top-level-form> (set form-program x))) programs))

(dm extract-things! (o)
  (let ((forms (as-top-level-forms (flatten-seqs o)))
	(result (isa <flattened-program>)))
    (set (program-form result)
	 (sequentialize
	  (map (fun (form) (extract! form form result)) forms)))
    result))

(dm extract! 
    ((o <program>) (form <top-level-form>) (result <flattened-program>))
  (update-walk! extract! o form result))

(dm extract! 
    ((o <constant>) (form <top-level-form>) (result <flattened-program>))
  (let ((value (constant-value o)))
    (if (or (== value #f) (== value #t) (== value '()) 
	    (isa? value <int>) (isa? value <chr>))
	o
	(let ((qb*   (program-quotations result))
	      (index (len qb*))
	      (qb    (isa <quotation-binding> 
		       (set binding-name index) (set binding-value value))))
	  (set (program-quotations result) (pair qb qb*))
	  (set (form-quotations form)      (pair qb (form-quotations form)))
	  (isa <global-reference> (set reference-binding qb))))))

(dm extract! 
    ((o <raw-constant>) (form <top-level-form>) (result <flattened-program>))
  o)

(dm extract! 
    ((o <flat-function>) 
     (form <top-level-form>) (result <flattened-program>))
  (let ((new-body (extract! (function-body o) form result))
	(name     (function-name o))
	(bindings (function-bindings o))
	(nary?    (function-nary? o))
	(value    (function-value o)))
    (do (fun (binding)
	  (set (binding-type binding) 
	       (extract! (binding-type binding) form result)))
	bindings)
    (let ((free-bindings 
	   (rep extract ((free (function-free o)))
	     (if (empty? free)
		 '()
		  (pair (reference-binding (head free))
			(extract (tail free))))))
	  (index
	   (adjoin-definition!
	    form result name bindings nary? value new-body free-bindings)))
      (isa <closure-creation> 
	(set closure-creation-index    index)
	(set closure-creation-bindings bindings)
	(set closure-creation-free     (function-free o))
	;; TODO: WHY THE FOLLOWING?
	;; (set closure-creation-body     new-body)
	))))

(dm extract! 
    ((o <ast-primitive-definition>) 
     (form <top-level-form>) (result <flattened-program>))
  (let ((p    (assignment-form o))
	(body (extract! (function-body p) form result))
	(definition
	 (isa <primitive-definition> 
	   (set function-name     (function-name p))
	   (set function-bindings (function-bindings p))
	   (set function-value    (function-value p))
	   (set function-body     body))))
    ;; (assert (function-name p) "NO NAME FOR %=" p)
    (set (program-definitions result)
	 (pair definition (program-definitions result)))
    (set (form-definitions form)
	 (pair definition (form-definitions form)))
    (extract! (isa <constant> (set constant-value #f)) form result)))

(dm adjoin-definition! 
    ((form <top-level-form>) (result <flattened-program>) 
     name bindings nary? value body free)
  (let ((definitions
	 (program-definitions result))
	(new-index
	 (len definitions))
	(definition
	 (isa <function-definition> 
	   (set function-name     name)
	   (set function-bindings bindings)
	   (set function-nary?    nary?)
	   (set function-value    value)
           (set function-body     body)
	   (set function-free     free)
	   (set function-index    new-index))))
    (set (program-definitions result) (pair definition definitions))
    (set (form-definitions form)      (pair definition (form-definitions form)))
    new-index))

(dm split-program (o (max-count <int>))
  (lst o))

(dm split-program ((o <sequential>) (max-count <int>))
  (rep loop ((forms '()) (s o))
    (rep inner ((res '()) (es s) (count 0))
      (case ((empty? es)
	     (rev! (pair (sequentialize (rev! res)) forms)))
	    ((= count max-count)
	     (loop (pair (sequentialize (rev! res)) forms) es))
	    (#T 
	      (inner (pair (head es) res) (tail es) (+ count 1)))))))

(dm closurize-main! 
    ((o <flattened-program>) r max-count => <flattened-program>)
  (let ((forms      (split-program (program-form o) max-count))
	(base-index (len (program-definitions o)))) ;; TODO: HACK INTERFACE
    (rep loop ((calls '()) (defns (program-definitions o)) (i 0) (forms forms))
      (if (empty? forms)
	  (seq (set (program-definitions o) (rev! defns))
	       (set (program-form o)
		    (isa <top-level-form>
		         (set form-program     (sequentialize (rev! calls)))
			 (set form-definitions (rev! defns))))
	       o)
	  (let ((name
		 (make-sym "---main-" i "---"))
		(binding
		 (ast-define-binding 
		  r name #f (fun () (isa <predefined-binding>))))
		(defn
		 (isa <primitive-definition>
		   (set function-name     binding)
		   (set function-bindings '())
		   (set function-body     (head forms))
		   (set function-index    (+ base-index i))))
		(call
		 (isa <predefined-application> 
		   (set application-binding   binding)
		   (set application-arguments (empty <arguments>))
		   (set application-tail?     #f))))
	    (loop (pair call calls) (pair defn defns) (+ i 1) (tail forms)))))))

;; (def f (fun (n k) (if (= n 0) (k 1) (f (- n 1) (fun (r) (k (* n r)))))))

(dm gather-temporaries! ((o <program>))
  (set (program-definitions o)
       (map (fun (def)
	      (collect-temporaries! def def '()))
	    (program-definitions o)))
  o)

(dm collect-temporaries! ((o <program>) flat-fun r)
  (update-walk! collect-temporaries! o flat-fun r))

(dm collect-temporaries! ((o <local-reference>) flat-fun r)
  (let ((binding (reference-binding o))
	(b       (assocq binding r)))
    (if b
	(isa <local-reference> (set reference-binding (assoc-value b)))
	o)))

(dm collect-temporaries! ((o <fix-let>) flat-fun r)
  (set (fix-let-arguments o)
       (collect-temporaries! (fix-let-arguments o) flat-fun r))
  (let ((new-bindings
	 (map new-renamed-binding (fix-let-bindings o)))
	(new-r
	 (cat (map2 assoc (fix-let-bindings o) new-bindings) r)))
    (adjoin-temporary-variables! flat-fun new-bindings)
    (set (fix-let-bindings o)
	 new-bindings)
    (set (fix-let-body o)     
	 (collect-temporaries! (fix-let-body o) flat-fun new-r))
    o))

(dm collect-temporaries! ((o <locals>) flat-fun r)
  (let ((new-bindings
	 (map new-renamed-binding (locals-bindings o)))
	(new-r
	 (cat (map2 assoc (locals-bindings o) new-bindings) r)))
    (set (locals-functions o)
	 (map (rcurry collect-temporaries! flat-fun new-r) (locals-functions o)))
    (adjoin-temporary-variables! flat-fun new-bindings)
    (set (locals-bindings o) new-bindings)
    (set (locals-body o)
	 (collect-temporaries! (locals-body o) flat-fun new-r))
    o))

(dm adjoin-temporary-variables! (flat-fun new-bindings)
  (rep adjoin 
      ((temps (function-temporaries flat-fun)) (bindings new-bindings))
    (if (empty? bindings)
	(set (function-temporaries flat-fun) temps)
	(if (mem? temps (head bindings))
	    (adjoin temps (tail bindings))
	    (adjoin (pair (head bindings) temps) (tail bindings))))))

(dv <renamed-local-binding> (isa <local-binding>))
  (slot <renamed-local-binding> binding-index)

(dv *renaming-bindings-counter* 0)

(dm new-renamed-binding ((binding <local-binding>))
  (set *renaming-bindings-counter* (+ *renaming-bindings-counter* 1))
  (isa <renamed-local-binding>      ;; TODO: SHOULD USE CLONING
       (set binding-name            (binding-name binding))
       (set binding-type            (binding-type binding))
       (set binding-dynamic-extent? (binding-dynamic-extent? binding))
       (set binding-index           *renaming-bindings-counter*)))
