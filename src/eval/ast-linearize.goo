;;; Copyright (c) 2001 Jonathan Bachrach
;;;; BASED ON Lisp In Small Pieces by Christian Queinnec

(use goo/boot)
(use goo/macros)
(use goo/runtime)
(use eval/ast)
(use goo/types)
(use goo/math)
(use goo/cols)

;;; this is moved from runtime
;;; this doesn't deserve to be part of goo AFAICT, but its used here.

;;; ASSOC

(dc <assoc> (<any>))
  (dp assoc-key (x|<assoc> => <any>))
  (dp assoc-value (x|<assoc> => <any>))
(df assoc (x y => <assoc>)
  (new <assoc> assoc-key x assoc-value y))

(dm assocq (x l|<lst> => <any>)
  (if (empty? l)
      #f
      (if (== x (assoc-key (head l)))
          (head l)
          (assocq x (tail l)))))
;;; END code from runtime

;;; WALKER

(dm update-walk! (g o args|...)
  ;; (msg out "WALKING %=\n" o)
  (for ((prop (object-props o)))
    ;; (msg out "  PROP %=\n" prop)
    (def getter (prop-getter prop))
    (def setter (prop-setter prop))
    (unless (== getter binding-value);; TODO: HACK
      (when (prop-bound? o getter)
        (def x (getter o))
        (when (isa? x <program>)
          ;; (msg out "    UPDATING %=\n" x)
          (setter (app g x args) o)))))
  o)

(dm ast-walk (g o args|...)
  (for ((prop (object-props o)))
    (def getter (prop-getter prop))
    (unless (== getter binding-value) ;; TODO: HACK
      (when (prop-bound? o getter)
        (def x (getter o))
        (when (isa? x <program>)
          (app g x args)))))
  o)

;;; BOXING

(dc <box-read> (<computed-program>))
  (dp box-reference (x|<box-read> => <any>))

(dc <box-write> (<computed-program>))
  (dp box-reference (x|<box-write> => <any>))
  (dp box-form (x|<box-write> => <any>))

(dc <box-creation> (<computed-program>))
  (dp box-reference (x|<box-creation> => <any>))

(dm insert-box! (o|<program>)
  (update-walk! insert-box! o))

(dm insert-box! (o|<local-reference>)
  (if (binding-mutable? (reference-binding o))
      (new <box-read> box-reference o)
      o))

(dm insert-box! (o|<local-assignment>)
  (new <box-write> 
    box-reference (assignment-reference o)
    box-form      (insert-box! (assignment-form o))))

(dm insert-box! (o|<ast-method>)
  (set (function-body o)
       (insert-box! (boxify-mutable-bindings
                     (function-body o) (function-bindings o))))
  o)

(dm insert-box! (o|<fix-let>)
  (set (fix-let-arguments o)
       (insert-box! (fix-let-arguments o)))
  (set (fix-let-body o)
       (insert-box! 
        (boxify-mutable-bindings (fix-let-body o) (fix-let-bindings o))))
  o)

(dm insert-box! (o|<locals>)
  (set (locals-functions o)
       (map insert-box! (locals-functions o)))
  (set (locals-body o)
       (insert-box!
        (boxify-mutable-bindings (locals-body o) (locals-bindings o))))
  o)

(dm boxify-mutable-bindings (form bindings|<lst>)
  (sequentialize
    (rep loop ((res '()) (bindings bindings))
      (if (empty? bindings)
          (rev! (pair form res))
          (let ((binding (head bindings)))
            (if (binding-mutable? binding)
                (let ((creator 
                        (new <box-creation>
                          box-reference
                          (new <local-reference>
                            reference-binding binding))))
                  (loop (pair creator res) (tail bindings)))
                (loop res (tail bindings))))))))

;;; DYNAMIC-EXTENT ANALYSIS

(dm do-do-call-references! (o|<program>)
  (update-walk! do-call-references! o))

(dm do-call-references! (o|<program>)
  (do-do-call-references! o))

(dm do-call-references! (o|<regular-application>)
  (do-do-call-references! o)
  (if (isa? (application-function o) <local-reference>)
      (set (reference-called-function? (application-function o)) #t))
  o)

(dm analyze-call-references (o)
  (do-call-references! o))

(dm do-do-dynamic-extent! (o|<program>)
  (update-walk! do-dynamic-extent! o))

(dm do-dynamic-extent! (o|<program>)
  (do-do-dynamic-extent! o))

(dm do-dynamic-extent! (o|<local-reference>)
  (do-do-dynamic-extent! o)
  (unless (reference-called-function? o)
    (set (binding-dynamic-extent? (reference-binding o)) #f))
  o)

(dm analyze-dynamic-extent (o)
  (analyze-call-references o)
  (do-dynamic-extent! o))

;;; CALL ANALYSIS

(dm do-do-call-upgrades! (o|<program>)
  (update-walk! do-call-upgrades! o))

(dm do-call-upgrades! (o|<program>)
  (do-do-call-upgrades! o))

(dm unconstrained-type? (b|<program> => <log>)
  #f)

(dm unconstrained-type? (b|<module-binding> => <log>)
  (and (== (binding-module-name b) 'goo/boot) (== (binding-name b) '<any>)))

(dm unconstrained-type? (o|<module-binding-reference> => <log>)
  (unconstrained-type? (reference-binding o)))

(dm do-call-upgrades! (o|<regular-application>)
  (do-do-call-upgrades! o)
  (if (isa? (application-function o) <local-reference>)
      (let ((met (binding-value (reference-binding (application-function o)))))
        (if (and (isa? met <ast-function>)
                 (all? (fun (x) (unconstrained-type? (binding-type x)))
                       (function-bindings met))
                 (unconstrained-type? (function-value met))
                 (not (function-nary? met))
                 (= (len (application-arguments o))
                    (len (function-bindings met))))
            (set (application-known? o) #t))))
  o)

(dm analyze-calls (o)
  (do-call-upgrades! o))

;;; FLATTENING ENVIRONMENTS

(dc <free-reference> (<real-reference>))
  (dp reference-offset (x|<free-reference> => (t? <int>))) 
  (dp reference-self? (x|<free-reference> => <log>))

(dm lift! (o)
  (lift-procedures! o #f '()))

(dm lift-procedures! (o|<program> flat-fun bindings)
  (update-walk! lift-procedures! o flat-fun bindings))

(dm lift-procedures! (o|<local-reference> flat-fun bindings)
  (def b (reference-binding o))
  (if (mem? bindings b)
      o
      (let ((offset (adjoin-free-binding! flat-fun o)))
        (new <free-reference> 
          reference-binding b
          reference-offset offset
          reference-self?
          (== (reference-binding o) (function-binding flat-fun))))))

(dm adjoin-free-binding! (flat-fun|<ast-method> ref => <int>)
  (rep check ((i|<int> 0) (free* (function-free flat-fun)))
    (if (empty? free*)
        (let ((new-env (free-environment ref (empty <free-environment>))))
          (if (empty? (function-free flat-fun))
              (set (function-free flat-fun) new-env)
              (rep add ((free* (function-free flat-fun)))
                (def tail (tail free*))
                (if (empty? tail)
                    (set (tail free*) new-env)
                    (add tail))))
          i)
        (if (== (reference-binding ref)
                (reference-binding (head free*)))
            i
            (check (+ i 1) (tail free*))))))

(dm lift-procedures! (o|<fix-let> flat-fun bindings)
  (set (fix-let-arguments o)
       (lift-procedures! (fix-let-arguments o) flat-fun bindings))
  (def new-bindings (cat (fix-let-bindings o) bindings))
  (set (fix-let-body o)
       (lift-procedures! (fix-let-body o) flat-fun new-bindings))
  o)

(dm lift-procedures! (o|<locals> flat-fun bindings)
  (def new-bindings (cat (locals-bindings o) bindings))
  (set (locals-functions o)
       (map (rcurry lift-procedures! flat-fun new-bindings) 
            (locals-functions o)))
  (set (locals-body o)
       (lift-procedures! (locals-body o) flat-fun new-bindings))
  o)

(dm lift-procedures! (o|<ast-primitive> flat-fun bindings)
  (set (function-body o)
       (lift-procedures! (function-body o) #f (function-bindings o)))
  o)

(dm lift-procedures! (o|<ast-generic> flat-fun bindings)
  o)

(dm lift-procedures! (o|<ast-method> flat-fun bindings)
  (set (function-body o)
       (lift-procedures! (function-body o) o (function-bindings o)))
  (set (function-free o) 
       (lift-procedures! (function-free o) flat-fun bindings))
  o)

;;; COLLECTING QUOTATIONS AND FUNCTIONS

(dc <flattened-program> (<computed-program>))
  (dp program-form (x|<flattened-program> => (t? <program>)))
  (dp program-quotations (x|<flattened-program> => <any>) (fab <tab> 40))
  (dp program-definitions (x|<flattened-program> => <any>) '())

(dc <top-level-form> (<computed-program>))
  (dp form-program (x|<top-level-form> => <program>))
  (dp form-quotations (x|<top-level-form> => <any>) '())
  (dp form-definitions (x|<top-level-form> => <any>) '())

(dc <closure-creation> (<computed-program>))
  (dp closure-creation-index (x|<closure-creation> => <any>))
  (dp closure-creation-free (x|<closure-creation> => <any>))

(dm flatten-seqs (o)
  (lst o))

(dm flatten-seqs (o|<sequential>)
  (rep loop ((s o) (r '()))
     (if (empty? s)
         (rev! r)
         (rep inner ((ss (flatten-seqs (head s))) (r r))
           (if (empty? ss)
               (loop (tail s) r)
               (inner (tail ss) (pair (head ss) r)))))))

(dm as-top-level-forms (programs)
  (map (fun (x) (new <top-level-form> form-program x)) programs))

(dm extract-things! (o)
  (def forms  (as-top-level-forms (flatten-seqs o)))
  (def result (new <flattened-program>))
  (set (program-form result)
       (sequentialize (map (fun (form) (extract! form form result)) forms)))
  result)

(dm extract! (o|<program> form|<top-level-form> result|<flattened-program>)
  (update-walk! extract! o form result))

(dm extract! (o|<constant> form|<top-level-form> result|<flattened-program>)
  (def value (constant-value o))
  (if (or (== value #f) (== value #t) (== value '())
          (isa? value <int>) (isa? value <chr>))
      o
      (let ((qb*   (program-quotations result))
            (index (len qb*))
            (probe (elt-or qb* value #f)))
        (if probe
            (new <global-reference> reference-binding probe)
            (let ((qb (new <module-binding> 
                        binding-kind 'quotation
                        binding-name index 
                        binding-info value)))
              (set (elt qb* value) qb)
              (pushf (form-quotations form) qb)
              (new <global-reference> reference-binding qb))))))

(dm extract! (o|<raw-constant> form|<top-level-form> result|<flattened-program>)
  o)

(dm extract! (o|<ast-method> form|<top-level-form> result|<flattened-program>)
  (set (function-debug-name o)
       (extract! (function-debug-name o) form result))
  (set (function-signature o)
       (extract! (function-signature o) form result))
  (set (function-body o) (extract! (function-body o) form result))
  (do (fun (binding)
        (set (binding-type binding) 
             (extract! (binding-type binding) form result)))
      (function-bindings o))
  (def free          (function-free o))
  (def free-bindings (map reference-binding free))
  (def index         (adjoin-definition! form result o))
  (set (function-index o) index)
  (set (function-free o)  free-bindings)
  (new <closure-creation> 
    closure-creation-index index closure-creation-free free))

(dm extract! 
    (o|<ast-primitive-definition> 
     form|<top-level-form> result|<flattened-program>)
  (def prim (assignment-form o))
  (set (function-body prim) (extract! (function-body prim) form result))
  (pushf (program-definitions result) prim)
  (extract! (new <constant> constant-value #f) form result))

(dm adjoin-definition! (form|<top-level-form> result|<flattened-program> x)
  (def new-index (len (program-definitions result)))
  (pushf (program-definitions result) x)
  (pushf (form-definitions form)      x)
  new-index)

;;; CLOSURIZE MAIN

(dm split-program (o max-count|<int>)
  (lst o))

(dm split-program (o|<sequential> max-count|<int>)
  (rep loop ((forms '()) (s o))
    (rep inner ((res '()) (es s) (count 0))
      (cond ((empty? es)
             (rev! (pair (sequentialize (rev! res)) forms)))
            ((= count max-count)
             (loop (pair (sequentialize (rev! res)) forms) es))
            (#T 
              (inner (pair (head es) res) (tail es) (+ count 1)))))))

(dm closurize-main! (o|<flattened-program> r max-count => <flattened-program>)
  (def forms      (split-program (program-form o) max-count))
  (def base-index (len (program-definitions o))) ;; TODO: HACK INTERFACE
  (rep loop ((calls '()) (defns (program-definitions o)) (i 0) (forms forms))
    (if (empty? forms)
        (seq (set (program-definitions o) (rev! defns))
             (set (program-form o)
                  (new <top-level-form>
                    form-program     (sequentialize (rev! calls))
                    form-definitions (rev! defns)))
             o)
        (let ((name
               (cat-sym "---main-" i "---"))
              (binding
               (ast-define-binding r name #f 'predefined))
              (defn
               (new <ast-primitive>
                 function-binding    binding
                 function-debug-name (objectify-quotation name 4)
                 function-signature  (objectify-signature '() r)
                 function-body       (head forms)))
              (call
               (new <predefined-application> 
                 application-binding   binding
                 application-arguments (empty <arguments>)
                 application-tail?     #f)))
          (loop (pair call calls) (pair defn defns) (+ i 1) (tail forms))))))

;; (def f (fun (n k) (if (= n 0) (k 1) (f (- n 1) (fun (r) (k (* n r)))))))

;;; GATHER-TEMPORARIES -- PULLS ALL FIX-LET ARGS UP TO ENCLOSING FUN
;;;   FLAT-FUN IS ENCLOSING FUN AND R IS ENVIRONMENT FOR NEW AST

(dm gather-temporaries! (o|<program>)
  (set (program-definitions o)
       (map (fun (def) (collect-temporaries! def def '()))
            (program-definitions o)))
  o)

(dm collect-temporaries! (o|<program> flat-fun r)
  (update-walk! collect-temporaries! o flat-fun r))

(dm collect-temporaries! (o|<local-reference> flat-fun r)
  (def binding (reference-binding o))
  (def b       (assocq binding r))
  (if b
      (new <local-reference> reference-binding (assoc-value b))
      o))

(dm collect-temporaries! (o|<fix-let> flat-fun r)
  (set (fix-let-arguments o)
       (collect-temporaries! (fix-let-arguments o) flat-fun r))
  (def new-bindings (map new-renamed-binding (fix-let-bindings o)))
  (def new-r (cat (map2 assoc (fix-let-bindings o) new-bindings) r))
  (adjoin-temporary-variables! flat-fun new-bindings)
  (set (fix-let-bindings o) new-bindings)
  (set (fix-let-body o) (collect-temporaries! (fix-let-body o) flat-fun new-r))
  o)

(dm collect-temporaries! (o|<locals> flat-fun r)
  (def new-bindings (map new-renamed-binding (locals-bindings o)))
  (def new-r (cat (map2 assoc (locals-bindings o) new-bindings) r))
  (set (locals-functions o)
       (map (rcurry collect-temporaries! flat-fun new-r) 
            (locals-functions o)))
  (adjoin-temporary-variables! flat-fun new-bindings)
  (set (locals-bindings o) new-bindings)
  (set (locals-body o)
       (collect-temporaries! (locals-body o) flat-fun new-r))
  o)

(dm adjoin-temporary-variables! (flat-fun new-bindings)
  (rep adjoin 
      ((temps (function-temporaries flat-fun)) (bindings new-bindings))
    (if (empty? bindings)
        (set (function-temporaries flat-fun) temps)
        (if (mem? temps (head bindings))
            (adjoin temps (tail bindings))
            (adjoin (pair (head bindings) temps) (tail bindings))))))

(dc <renamed-local-binding> (<local-binding>))
  (dp binding-index (x|<renamed-local-binding> => <any>))

(ddv *renaming-bindings-counter* 0)

(dm new-renamed-binding (binding|<local-binding>)
  (set *renaming-bindings-counter* (+ *renaming-bindings-counter* 1))
  (new <renamed-local-binding>      ;; TODO: SHOULD USE CLONING
    binding-name            (binding-name binding)
    binding-type            (binding-type binding)
    binding-dynamic-extent? (binding-dynamic-extent? binding)
    binding-index           *renaming-bindings-counter*))

;;; REGISTER ALLOCATION

(dv *register-passive?* #f) ;; FORCES ALL LOADS THROUGH REGISTERS (E.G., RISC)

(dm register-allocate! (o|<program> register-passive?|<log>)
  (dlet ((*register-passive?* register-passive?))
    (do (fun (def) (collect-registers! def #f #t)) (program-definitions o)))
  o)

(dm allocate-register (o|<program> flat-fun val?)
  (when (and val? flat-fun (not (program-register o)))
    ;; TODO: INEFFICIENT
    (set (program-register o) (len (function-registers flat-fun)))
    (pushf (function-registers flat-fun) o)))

(dm collect-registers! (o|<computed-program> flat-fun val?)
  (allocate-register o flat-fun val?)
  (update-walk! collect-registers! o flat-fun #t))

(dm collect-registers! (o|<sequential> flat-fun val?)
  (rep loop ((x o))
    (if (empty? x)
        o
        (let ((next-x (tail x))) ;; ONLY LAST FORM IN SEQ CONSUMES VALUE
          (collect-registers! (head x) flat-fun (and val? (empty? next-x)))
          (loop next-x)))))

(dm collect-registers! (o|<passive-program> flat-fun val?)
  (when *register-passive?* 
    (allocate-register o flat-fun val?))
  (update-walk! collect-registers! o flat-fun #t))

(dm collect-registers! (o|<top-level-form> flat-fun val?)
  (allocate-register o flat-fun val?)
  (do (fun (def) (collect-registers! def flat-fun val?)) (form-definitions o))
  (collect-registers! (form-program o) flat-fun val?)
  o)

(dm collect-registers! (o|<ast-method> flat-fun val?)
  (allocate-register o flat-fun val?)
  (collect-registers! (function-signature o) flat-fun #t)
  (do (rcurry collect-registers! flat-fun #t) (function-data-refs o))
  (collect-registers! (function-debug-name o) o #t)
  (collect-registers! (function-body o) o #t)
  o)

(dm collect-registers! (o|<ast-primitive> flat-fun val?)
  (collect-registers! (function-body o) o #t)
  o)

(dm ast-contains-fun? (x|<ast-method> => <log>) 
  #t)

(dm ast-contains-fun? (x => <log>)
  (esc return
    (loc ((walk (y) (if (isa? y <ast-method>) (return #t) (ast-walk walk y))))
      (ast-walk walk x))
    #f))

(export
  analyze-calls
  analyze-dynamic-extent
  <box-creation>
  box-form
  <box-read>
  box-reference
  <box-write>
  <closure-creation>
  closure-creation-free
  closure-creation-index
  closurize-main!
  extract-things!
  form-definitions
  form-program
  form-quotations
  <free-reference>
  gather-temporaries!
  insert-box!
  register-allocate!
  lift!
  program-definitions
  program-form
  program-quotations
  reference-offset
  reference-self?
  <renamed-local-binding>
  <top-level-form>
  unconstrained-type?
  update-walk!
  flatten-seqs
  *register-passive?*
  collect-temporaries!
  collect-registers!
  ast-contains-fun?
)
