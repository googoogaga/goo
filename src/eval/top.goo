;;;; Copyright (c) 2001 Jonathan Bachrach

(use boot)
(use macros)
(use runtime)
(use read)
(use write)
(use syntax)
(use ast)
(use ast-eval)
(use proto/system)

(dm parse-in ((s <str>) ct-env)
  (objectify (read-from-string s) ct-env #f))

(dm parse ((s <str>) (modname <sym>))
  (parse-in s (runtime-environment modname)))

(dm str-parse-in ((s <str>) ct-env)
  (format out "%=\n" (parse-in s ct-env)))

(dm str-parse ((s <str>) (modname <sym>))
  (str-parse-in s (runtime-environment modname)))

(dm eval-in ((x <any>) ct-env)
  (let ((o (objectify x ct-env #f))
	(e (ast-evaluate o)))
    e))

(dm eval ((x <any>) (modname <sym>))
  (eval-in x (runtime-environment modname)))

(dm str-eval-in ((x <str>) ct-env => <any>)
  (write-to-string (eval-in (read-from-string x) ct-env)))

(dm str-eval ((x <str>) (modname <sym>))
  (str-eval-in x (runtime-environment modname)))

(dm read-file ((filename <str>) => <any>)
  (call-with-input-file
    filename
    (fun (port)
      (rep loop ((forms '()))
	(let ((x (read port)))
	  (if (eof-object? x)
	      (sexpr-sequence->begin (rev! forms))
	      (loop (pair x forms))))))))

(dm load-in ((filename <str>) ct-env) 
  (let ((x (read-file filename))
	(o (objectify x ct-env #f)))
    (ast-evaluate o)
    ;; TODO - Hook me into the new module loader system in a useful way.
    ;; (report-undefined-global-bindings ct-env)
    ))

(dm load ((filename <str>) (modname <sym>)) 
  (load-in filename (runtime-environment modname)))

(dm load-from (name (modname <sym>))
  (load (proto-filename name) modname))

(dm prompt-for-command-expression (env level prompt)
  (format out "%s %=%s"
          (module-name (find-environment-module env)) level prompt)
  (force-output out)
  (read in))

(dm print-result-expression (env level label result)
  (format out "%s %=%s"
           (module-name (find-environment-module env)) level label)
  (write out result))

(dm do-stack-frames (fun)
  (%do-stack-frames fun))

(dm backtrace ()
  (let ((num 0))
    (do-stack-frames
      (fun (f (args ...))
	(unless (isa? f <gen>) 
	  (format out "[%=] %= %=\n" num f args) (inc num))))))

(dv <keyboard-interrupt> (isa <condition>))

(df keyboard-interrupt ()
  (sig <keyboard-interrupt>))

(df do-restart (restarts n)
  (unless restarts
    (error "No restarts available.\n"))
  (unless (and (> n 0) (<= n (len restarts)))
    (error "No restart #%d.\n"))
  (invoke-handler-interactively (elt restarts (- n 1)) in out))

;;  Initialization and driver loop
;;  The prompt is handled a bit differently than in the notes
(dm top-in (level top quit show-restarts? ct-env)
  (let ((restarts #f))
    (lab blow
      (rep loop ()
        (lab continue
          (try <condition>
            (fun (c r)
              (if (isa? c <keyboard-interrupt>)
                  (format out "BREAK")
                  (format out "ERROR: %s" (describe-condition c)))
              ;; (backtrace (env))
              (top-in (+ level 1) top quit #t ct-env)
              (continue #f))
            (try ((type <restart>)
                  (description "Return to interpreter level %d" level))
              (fun (c r) (continue #f))
              (newline out)
              (when show-restarts?
                (format out "Type (restart N) to restart execution:\n")
                (set restarts (list-handlers <restart> out))
                (set show-restarts? #f))
              (let ((form (prompt-for-command-expression ct-env level "<= ")))
                (case
                  ((or (= form '(quit)) (= form (eof-object)))
                   (quit #f))
                  ((= form '(up))
                   (blow #f))
                  ((= form '(top))
                   (top #f))
                  ((= form '(handlers))
                   (list-handlers <condition> out))
                  ((= form '(restarts))
                   (list-handlers <restart> out))
                  ((mif ((restart ,n) form) #t #f)
                   (do-restart restarts (2nd form)))
                  ((mif ((in-mod ,m) form) #t #f)
                   (let ((new-env (runtime-environment (2nd form))))
                     (set ct-env new-env)))
                  (#t
                   (let ((ast    (objectify form ct-env #f))
                         (result (ast-evaluate ast)))
                     (print-result-expression ct-env level "=> " result))))))))
        (loop)))))

(dm top ((modname <sym>))
  (lab quit
    (try ((type <restart>)
          (description "Exit the top-level interpreter"))
      (fun (c r) (quit #f))
      (rep loop ()
        (lab top
          (top-in 0 top quit #f (runtime-environment modname)))
        (loop)))))

(export
  eval
  load
  parse-in
  read-file
  top
  do-stack-frames
  backtrace)
