;;;; Copyright (c) 2001 Jonathan Bachrach

(use boot)
(use macros)
(use runtime)
(use read)
(use write)
(use syntax)
(use ast)
(use ast-eval)

(dm os-name (=> <str>)
  (%sb (%os-name)))

(dm os-binding-value ((s <str>) => <str>)
  (%sb (%os-binding-value (%su s))))

(dm os-binding-value-setter ((v <str>) (s <str>) => <str>)
  (set (%os-binding-value (%su s)) (%su v))
  v)

(dv *path-separator*
  (case
    ((= (os-name) "linux") "/")
    ((= (os-name) "win32") "\\")
    (#t "/")))

(dm base-path ((filename <str>) => <str>)
  (rep loop ((i (- (len filename) 1)))
    (if (< i 0)
	""
	(if (= (elt filename i) (elt *path-separator* 0))
	    (sub filename 0 (+ i 1))
	    (loop (- i 1))))))

(dv *proto-root*
  (let ((env-root (os-binding-value "PROTO_ROOT")))
    (if (empty? env-root)
        ;; Defaults to a path relative to the current working directory.
        (cat (base-path (app-filename)) ".." *path-separator* "..")
        env-root)))

(dm add-src-path (relpath => <str>)
  (cat *proto-root* *path-separator* "SRC" *path-separator* relpath))

(dm add-build-path (builddir relpath => <str>)
  (cat *proto-root* *path-separator* "C" *path-separator*
       builddir *path-separator* relpath))

(dm parse-in ((s <str>) ct-env)
  (objectify (read-from-string s) ct-env #f))

(dm parse ((s <str>)) (parse-in s (runtime-environment)))

(dm str-parse-in ((s <str>) ct-env)
  (format out "%=\n" (parse-in s ct-env)))

(dm str-parse ((s <str>)) (str-parse-in s (runtime-environment)))

(dm eval-in ((x <any>) ct-env)
  (let ((o (objectify x ct-env #f))
	(e (ast-evaluate o)))
    e))

(dm eval ((x <any>)) (eval-in x (runtime-environment)))

(dm str-eval-in ((x <str>) ct-env => <any>)
  (write-to-string (eval-in (read-from-string x) ct-env)))

(dm str-eval ((x <str>))
  (str-eval-in x (runtime-environment)))

(dm read-file ((filename <str>) => <any>)
  (call-with-input-file
    filename
    (fun (port)
      (rep loop ((forms '()))
	(let ((x (read port)))
	  (if (eof-object? x)
	      (sexpr-sequence->begin (rev! forms))
	      (loop (pair x forms))))))))

(dm load-in ((filename <str>) ct-env) 
  (let ((x (read-file filename))
	(o (objectify x ct-env #f)))
    (ast-evaluate o)
    ;; TODO - Hook me into the new module loader system in a useful way.
    ;; (report-undefined-global-bindings ct-env)
    ))

(dm load ((filename <str>)) 
  (load-in filename (runtime-environment)))

(dv *proto-extension* ".proto")
(dv *c-extension* ".c")
(dv *obj-extension* ".o")
(dv *exe-extension* "")

(df proto-filename (name)
  (cat name *proto-extension*))

(df c-filename (name)
  (cat name *c-extension*))

(df obj-filename (name)
  (cat name *obj-extension*))

(df exe-filename (name)
  (cat name *exe-extension*))

(dm load-from (name)
  (load (proto-filename name)))

(dm prompt-for-command-expression (level prompt)
  (format out "%=%s" level prompt)
  (force-output out)
  (read in))

(dm do-stack-frames (fun)
  (%do-stack-frames fun))

(dm backtrace ()
  (let ((num 0))
    (do-stack-frames
      (fun (f (args ...))
	(unless (isa? f <gen>) 
	  (format out "[%=] %= %=\n" num f args) (inc num))))))

(dv <keyboard-interrupt> (isa <condition>))

(df keyboard-interrupt ()
  (sig <keyboard-interrupt>))

;;  Initialization and driver loop
;;  The prompt is handled a bit differently than in the notes
(dm top-in (level top quit ct-env)
  (lab blow
    (rep loop ()
      (lab continue
	(try ((c r)
	       (if (isa? c <keyboard-interrupt>)
	           (format out "BREAK")
	           (seq
		     (format out "ERROR: ")
		     (when (isa? c <simple-condition>)
		       (apply (curry format out (condition-message c))
			      (condition-arguments c)))))
	       ;; (backtrace (env))
	       (top-in (+ level 1) top quit ct-env)
	       (continue #f))
	  (newline out)
	  (let ((form (prompt-for-command-expression level "<= ")))
	    (if (or (= form '(quit)) (= form (eof-object)))
		(quit #f)
		(if (= form '(up))
		    (blow #f)
		    (if (= form '(top))
			(top #f) 
			(let ((ast    (objectify form ct-env #f))
			      (result (ast-evaluate ast)))
			  (format out "%==> " level) 
			  (write out result))))))))
	(loop))))

(dm top ()
  (lab quit
    (rep loop ()
      (lab top
        (top-in 0 top quit (runtime-environment)))
      (loop))))

(export
  add-src-path
  add-build-path

  *proto-extension*
  *c-extension*
  *obj-extension*
  *exe-extension*

  c-filename
  proto-filename
  exe-filename
  obj-filename

  eval
  load
  parse-in
  *path-separator*
  *proto-root*
  read-file
  top)
