;;;; Copyright (c) 2001 Jonathan Bachrach

(use runtime/boot)
(use goo/macros)
(use runtime/runtime)
(use goo/io/read)
(use goo/io/write)
(use compiler/syntax)
(use compiler/ast)
(use compiler/ast-linearize)
(use compiler/ast-eval)
(use goo/system)
(use goo/type)
(use goo/math)
(use goo/collections)
(use goo/port)

(df esctst ()
  (esc exit 
    (fin (exit 'exit) 
         (format out "CLEANUP\n")
         'cleanup) 
    (format out "DO\n")
    'done))

(dg g2c-eval (exp ct-env))

(dm parse-in (s|<str> ct-env)
  (objectify-with-subtransaction (read-from-string s) ct-env #f))

(dm parse (s|<str> modname|<sym>)
  (parse-in s (runtime-environment modname)))

(dm str-parse-in (s|<str> ct-env)
  (format out "%=\n" (parse-in s ct-env)))

(dm str-parse (s|<str> modname|<sym>)
  (str-parse-in s (runtime-environment modname)))

(df ast-run (ast ct-env)
  (ast-evaluate ast))

(df g2c-run (ast ct-env)
  (g2c-eval ast ct-env))

(df auto-run (ast ct-env)
  (if (ast-contains-fun? ast)
      (g2c-run ast ct-env)
      (ast-run ast ct-env)))

(df auto-eval (form ct-env)
  (def ast (objectify-with-subtransaction form ct-env #f))
  (auto-run ast ct-env))

(ddv run auto-run)

(dm eval-in (x ct-env)
  (def o (objectify-with-subtransaction x ct-env #f))
  (def e (ast-evaluate o))
  e)

(dm eval (x modname|<sym>)
  (eval-in x (runtime-environment modname)))

(dm str-eval-in (x|<str> ct-env => <any>)
  (write-to-string (eval-in (read-from-string x) ct-env)))

(dm str-eval (x|<str> modname|<sym>)
  (str-eval-in x (runtime-environment modname)))

(dm read-file (filename|<str> => <any>)
  (with-port (port (open <file-in-port> filename))
    (rep loop ((forms '()))
      (def x (read port))
      (if (eof-object? x)
          (sexpr-sequence->begin (rev! forms))
          (loop (pair x forms))))))

(dm load-in (filename|<str> ct-env) 
  (def x (read-file filename))
  (def o (objectify-with-subtransaction x ct-env #f))
  (run o ct-env)
  ;; TODO - Hook me into the new module loader system in a useful way.
  ;; (report-undefined-global-bindings ct-env)
  )

(dm load (filename|<str> modname|<sym>) 
  (load-in filename (runtime-environment modname)))

(dm load-from (name modname|<sym>)
  (load (goo-filename name) modname))

(dm prompt-for-command-expression (env level prompt)
  (format out "%s %=%s"
          (module-name (find-environment-module env)) level prompt)
  (force-out out)
  (def form (read in))
  (if (and (isa? form <lst>) (== (head form) 'unquote))
      (let ((arg-str (gets in))
            (args    (read-from-string (cat "(" arg-str ")"))))
        (pair (2nd form) args))
      form))

(dm print-result-expression (env level label result)
  (format out "%s %=%s"
           (module-name (find-environment-module env)) level label)
  (write out result))

(dm do-stack-frames (fun)
  (%do-stack-frames fun))

(ds (for-frames (,num ,f ,args) ,@body)
  `(let ((,num 0))
     (do-stack-frames
      (fun (,f _args) (def ,args (rev _args)) ,@body (incf ,num)))))

(dm backtrace ()
  (for-frames (num f args)
    (format out "[%=] %= %=\n" num f args)))

(dm frame (n|<int>)
  (for-frames (num f args)
    (when (== n num)
      (format out "[%=] %= %=\n" num f args))))

(dm frame-var (n|<int> name|<sym>)
  (esc ret
    (for-frames (num f args)
      (when (== n num) 
        (ret (elt args (pos (fun-names f) name)))))
    nul))

(dm bt ()
  (for-frames (num f args)
    (format out "[%=] %=\n" num f)))

(dc <keyboard-interrupt> (<condition>))

(df keyboard-interrupt ()
  (sig (new <keyboard-interrupt>)))

(df do-restart (restarts n)
  (unless restarts
    (error "No restarts available.\n"))
  (unless (and (> n 0) (<= n (len restarts)))
    (error "No restart #%d.\n"))
  (invoke-handler-interactively (elt restarts (- n 1)) in out))

;;  Initialization and driver loop
;;  The prompt is handled a bit differently than in the notes
(dm top-in (level top quit show-restarts? ct-env)
  (def restarts #f)
  (esc blow
    (rep loop ()
      (esc continue
        (try <condition>
          (fun (c r)
            (if (isa? c <keyboard-interrupt>)
                (format out "BREAK")
                (format out "ERROR: %s" (describe-condition c)))
            ;; (backtrace (env))
            (top-in (+ level 1) top quit #t ct-env)
            (continue #f))
          (try ((type <restart>)
                (description "Return to interpreter level %d" level))
            (fun (c r) (continue #f))
            (newline out)
            (when show-restarts?
              (format out "Type (restart N) to restart execution:\n")
              (set restarts (list-handlers <restart> out))
              (set show-restarts? #f))
            (def form (prompt-for-command-expression ct-env level "<= "))
            (if (= form (eof-object))
                (quit #f)
                (match form
                  ((quit) 
                   (quit #f))
                  ((up)
                   (blow #f))
                  ((handlers)
                   (list-handlers <condition> out))
                  ((restarts)
                   (list-handlers <restart> out))
                  ((restart ,n)
                   (do-restart restarts n))
                  ((in ,m)
                   (def new-env (runtime-environment m))
                   (set ct-env new-env))
                  ((g2c-eval)
                   (set run g2c-run))
                  ((ast-eval)
                   (set run ast-run))
                  ((auto-eval)
                   (set run auto-run))
                  ((bt)
                   (bt))
                  ((backtrace)
                   (backtrace))
                  ((frame ,n)
                   (frame n))
                  ((frame-var ,n ,name)
                   (frame-var n name))
                  (#t 
                   (def res (auto-eval form ct-env))
                   (print-result-expression
                    ct-env level "=> " res)))))))
      (loop))))

(dm top (modname|<sym>)
  (esc quit
    (try ((type <restart>)
          (description "Exit the top-level interpreter"))
      (fun (c r) (quit #f))
      (rep loop ()
        (esc top
          (top-in 0 top quit #f (runtime-environment modname)))
        (loop)))))

(df save-image (image-name|<str>)
  (unexec image-name (fun () (top 'goo/user))))

(export
  eval
  auto-eval
  load
  parse-in
  read-file
  top
  do-stack-frames
  backtrace bt frame frame-var
  save-image
  g2c-eval
  esctst)
