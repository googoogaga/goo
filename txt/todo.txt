HIGH -- SAFETY -- CORRECTNESS -- MIN FUNCTIONALITY

x TEST SUITE
x   CORE
o   LIBRARY
o TEST BOOTSTRAP AND DOCUMENT P2C
o ERROR ON WRONG NUM ARGS TO INTERP FUN 
o MORE GENSYMS PLACES!!!
o SINGLETON METHODS SHOULD HAVE PRIORITY OVER OTHERS?
o DOC IS WRONG FOR ADD-SLOT -- NEED TO DM ACCESSORS

MEDIUM -- SPEED -- FUNCTIONALITY

o ALLOW P2C TO WORK IN SEPARATE COMPILATION MODE
o INLINE SLOTS -- HARD WITH (SLOT ...)
o NEXT-METHOD
o DEBUGGABLE INTERPRETER
o   GOOD ERRORS
o     CONDITIONS FOR DISPATCH/FUNCALL PROBLEMS
o       ADDING METHOD TO FUNCTION
o       INCONGRUENCY
o       WRONG NUMBER ARGS SHOULD BE REAL CONDITION
o   RESTARTS
o   BACKTRACE
o     FOR C 
o     FOR EVAL
o INSPECTOR
o NEED MODULES AND SOMETHING LIKE LIBRARIES FOR SYSCONFIG
o MAINTAIN SOURCE LOCATION
o NARY APPLY 
o LAMBDA-LIFTING
o MAKE ENV A MAP
o REPEATED SLOTS
o MERGE AST-LINEARIZE INTO AST
o FASTER CALL
o USE ELSE AS #T IN CASE AND SELECT
o ADD RECURRING FORMAT
o ADD DEPTH AND LENGTH TO RECURRING WRITING
o REWRITE SYNTAX.PROTO AS MACROS FOR DECLARATIVE SPEC
o BIGNUMS
o NARY VERSIONS OF ARITH
o HANDLE CHANGE CLASS
o   TRACK METHODS
o CHANGE FROM (ISA (PARENT ...) (SET GETTER VALUE) ...) TO GETTER VALUE ...
x MON SHOULD BE MORE LIKE LOC TAKING FUN PARAMS
o   CHANGE SIG TO SEARCH FOR APPLICABLE TRY
o ELT-OR AS UNDERLYING SUBSTRATE
o   ELT CALLS ELT-OR WITH $unsupplied
o PRIMITIVES SHOULD HAVE TYPES IN COMPILER
o NEED COMPILATION/RUNTIME-CONTEXT OBJECTS
o ISA CAN'T BE A MACRO CAUSE NEEDS TO BE CALLED
o FINISH TUP SUPPORT
o   ADD SET TUP SYNTAX
o   ADD DV TUP SYNTAX
o   LET TUP SHOULD DO PARALLEL BINDING THOUGH
o SHOULD BE ADD-FIRST AND ADD-LAST
o PUSH AND POP MIGHT BE BETTER AS MACROS FOR WRITE BACK
o   THEY DON'T CURRENTLY WORK FOR LISTS
o SIF AS MACRO -- SIMPLIFIES IMPLEMENTATION
o CHANGE SIF FORMAT TO TAKE FOUR ARGS ???
O USE UPPERCASE FOR TYPES? INT VS <INT> 
o MULTI-COLLECTIONS
o COLLECTING MACRO
o GENERIC FUNCTIONS???
o RECONCILE COLLECTION LIB WITH COOK PAPER
o INFIX -> PREFIX CONVERTER LIKE TAGS
o REDEFINITION
o   SEMANTICS WITHOUT DEFCLASS TYPE DEFS
x   ZERO PARAM CASE
o   CLASS REDEF DEALING WITH EXISTING METHODS
o UNNAMED ARGUMENTS WITH _
o FFI
o CHANGE FROM SET! TO KEY FIELD INIT?
o MAKE PROTOCOL 
o   COLLECTIONS
o   CAN I OVERRIDE ISA?
o DON'T ALLOW DOT READING
o DON'T CONS TRAITS UNLESS YOU DIFFER FROM PARENT

LOW

o ADD FALSE-OR
o ADD TYPE-OR
o CHANGE NAME OF MAKE-SYM TO FAB-SYM OR MAYBE CAT-SYM
o CLASS-BASED VERSION
o BIND "IT" TO TEST
o USE FIP MORE AND DEPRECATE DEPENDENCE ON LISTS
o WRITE CALL ROUTINES IN PROTO
o MERGE SYNTAX INTO AST GETTING RID OF ALL THE SYNTAX FUNS USING DESTRUCTING
o AUTO GEN SEXPR-COMPILE-TIME-TAGS
o GET RID OF MACRO VAR DEFS EMITTED IN C FILE
o METHODS SHOULD BE TRACEABLE BACK TO GENERIC
o OUTPUT MACROS IN C
o CHANGE ISA SYNTAX TO REMOVE (SET ,name ,value)'s in favor of ,name ,value
o REWRITE from-*-* using macro
o WHAT ABOUT KEY-VALUE ITERATION IN FOR LOOP?
o MULTIPLE VALUES
  (def block 
    (macro ((block ?name ?form ...) env)
     (call/cc (fun (?name) ?form ...))))
  (def (values (objects ...)) 
    (block return (apply return objects)))
  (def (call-with-values producer consumer) ...)
o UNICODE
o MERGE IN SERIES OPERATORS
o CHANGE LIST TO BE VECTOR?
o FORWARD REFERENCES
o SLOTS SHOULD USE ACCESSORS AS KEYS
o PREDICATE TYPES
o CLASS NAMING CONVENTION
o USE PAT VARS IN FORMAT STRINGS
o ASYMMETRY BETWEEN DEFINE AND LOC WRT PARAMS ((FUN x y) ?body)
   (DEF (F A B) BODY)
   (LOC (((F A B) BODY) ...) BODY)
   (LET ((X EXP) ...) BODY)
o MOP
o THUNK ABBREVIATION [ form ... ] => (fun () form ...)
o GET RID OF CONTROL FORMS USING THUNKS INSTEAD?
    (def (if #f con alt) (alt)) (if x [(go)] [(stop)])
    (def (if t  con alt) (con))

It seems stange to me that Dylan has every? and any?, but not count, 
given that every? and any? can both be efficiently created from count, 
as count(coll, pred) >= 1  and  count(coll, pred) = coll.size.  Well, 
OK, perhaps every? and any? are better to have an early-out 
implementaion, but I certainly don't see how they are any more primitive 
than count().

TABLES

;;--- To-do:
;;--- Bugs:
;;---   GC-state is not taken into account.  Adding a macro that wraps
;;---     up key-searching would help organize this.
;;--- Performance:
;;---   Finish (hopefully) better hashing functions for both \== and \=.
;;---   Make a subclass for \= tables that inlines the test and hash functions.
;;---     Should we do this for \= and \== tables?
;;---   Remove "below" tests when looping through tables since we provably
;;---     must hit an empty or evacuated cell sometime.
;;---   We don't currently need to lock table during rehash because we always
;;---     create a new vector.  This is very inefficient when we are doing a
;;---     same-size rehash on behalf of the GC.  Can we do better?
;;---     except that a puthash might get lost
;;---   Another way to decide to rehash a table might be on the basis of having
;;---     collision chains that are "too long".
;;---   Rehashing a table should consider the collision chain as it rehashes.
;;---     That is when an object A is hashed to it's preferred place in the
;;---     table and there is already an object B there due to secondary 
;;---     hashing then object B should be removed to some other place in its 
;;---     collision chain.  This means that object A will end up in its 
;;---     preferred place and object B won't be much worse off.
;;---   When removing the last key in a bucket in 'remhash' it can be marked
;;---     as empty instead of vacated.
;;--- Extensions:
;;---   Implement set (0-valued) tables.


