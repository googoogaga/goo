HIGH -- SAFETY -- MIN FUNCTIONALITY

x GET RID OF BOOT CRUFT
o NEED MODULES AND SOMETHING LIKE LIBRARIES FOR SYSCONFIG
o #() fails
o CAN'T REDEFINE MACROS
o SLOT ORDER FROM LEAST TO MOST SPECIFIC
o RANGE CHECKING ON FLAT'S
o USE ELSE AS #T IN CASE AND SELECT
o ERROR ON WRONG NUM ARGS TO INTERP FUN 
o RECORD AND CHECK RETURN TYPE 
o DEBUGGABLE INTERPRETER`
o   BACKTRACE -- NEED MORE REALISTIC STACK
o   GOOD ERRORS
o     CONDITIONS FOR DISPATCH/FUNCALL PROBLEMS
o       ADDING METHOD TO FUNCTION
o       INCONGRUENCY
o       WRONG NUMBER ARGS SHOULD BE REAL CONDITION
o   RESTARTS
x TEST SUITE
x   CORE
o   LIBRARY
o INSPECTOR
o MORE GENSYMS PLACES!!!
o SINGLETON METHODS SHOULD HAVE PRIORITY OVER OTHERS?
o DOC IS WRONG FOR ADD-SLOT -- NEED TO DM ACCESSORS
---
x SVEC SHOULD BE CALLED BUF
x ADD PATCH LOADER
x TAIL CALL ANALYSIS TO AST
x ERROR IF FILE DOESN'T EXIST
x PRINT ERROR MESSAGES CORRECTLY
x MACROS AREN'T WORKING IN STANDALONE SYSTEM
x FINISH TABLE CODE
x   USE TABLES FOR SYMBOL-TABLE
x   BRING TABLES INTO COL PROTOCOL
x   NEED FIP FOR TAB'S
x GNUEMACS INTERFACE -- \progra~1\scheme48\emacs
x   EMACS PROTO MODE
x   LISTENER MODE
x RENAME ACCORDING TO DOC
x   PROTO- SHOULD BE RENAMED OBJECT-
x CALL0, CALL1, CALL2
x FORWARD DECL PRIMITIVE-CALLS
x ALLOCA GEN ARGS
x AUTOMATIC CONTAGION FOR MATH OPS
x PUT SLOT-OFFSET COMPUTATION IN GEN-CACHE
x   NEED SLOT-DESCRIPTOR INFO IN ACCESSOR
---
x RECORD NREQ IN FUNCTION PROPERTIES
---
x IMPL SIGNAL/TRY FOR P2C AND C RUNTIME
x BETTER NATIVE PRINTING 
x   SPECS FOR FUNS
x   DEFAULT FOR NON-BUILTIN OBJECTS
x SYMBOLS MIGHT NOT BEING INTERNED CORRECTLY
x CHANGE NLX'S TO USE WITH-EXIT AND WITH-CLEANUP
x HAVE CONSTANT FOR <ANY>
x USE D/M OR DM OR DEF/M FOR DEFINE-METHOD
x REWORK OBJECTIFY TO REPORT FREE VARS
    PRELOAD RUNTIME VARS
x PASS OBJECT TO FIELD INITS
x   NEED ACCESS TO OBJECT THROUGH NAME
x RUNTIME LIBRARY
x   OPTIONALS, APPLY
x BOOTSTRAP
x   RUNTIME
x   INTERPRETER
x CONDITIONS
x   BASIC SUPPORT
x   HANDLE ALL DYLAN CONDITIONS
x   DEFAULT HANDLER
x RENAME lst-from to lst-of ...
x IMPORT/EXPORT-LITERAL -> IMPORT/EXPORT
x EXPORT STRINGS NOT WORKING
x RETURN TYPES WITH =>
x ITERATIVE FUNCTIONS WITH LET
x RECURSIVE FUNCTIONS WITH LOC
x OPTIONAL ARGUMENTS
x CLONING CORRECTLY
x SCHEMA EVOLUTION DURING FIELD ADDITION
x RENAME INSTANCE? ISA?
x RENAME UNWIND-PROTECT CLN OR TIDY
x PRIMITIVES
x   CORE
x   IO
x ==
x   POINTER-ID?
x   VALUE-ID?
x READ FROM STRING
x SEQ BINDING SEMANTICS FOR LET
x MAKE BLOCK RETURN BE REAL PROTO-METHOD
x QUASIQUOTE / MACRO SYSTEM

MEDIUM

o INVERSE SYMBOL LOOKUP DOESN'T WORK IN INTERPRETER
o NARY VERSIONS OF ARITH
o HANDLE CHANGE CLASS
o   TRACK METHODS
o CHANGE FROM (ISA (PARENT ...) (SET GETTER VALUE) ...) TO GETTER VALUE ...
x MON SHOULD BE MORE LIKE LOC TAKING FUN PARAMS
o   CHANGE SIG TO SEARCH FOR APPLICABLE TRY
o ELT-OR AS UNDERLYING SUBSTRATE
o   ELT CALLS ELT-OR WITH $unsupplied
o PRIMITIVES SHOULD HAVE TYPES IN COMPILER
o NEED COMPILATION/RUNTIME-CONTEXT OBJECTS
o LOCALS-FUNCTIONS SHOULD BE AN ARGUMENT-LIST
o ISA CAN'T BE A MACRO CAUSE NEEDS TO BE CALLED
o FINISH TUP SUPPORT
o   ADD SET TUP SYNTAX
o   ADD DV TUP SYNTAX
o   LET TUP SHOULD DO PARALLEL BINDING THOUGH
o SHOULD BE ADD-FIRST AND ADD-LAST
o PUSH AND POP MIGHT BE BETTER AS MACROS FOR WRITE BACK
o   THEY DON'T CURRENTLY WORK FOR LISTS
o MIF AS MACRO -- SIMPLIFIES IMPLEMENTATION
x SHOULD WE USE GENERAL QUOTE OR SPECIAL PURPOSE BUILDERS?
o CHANGE SIF FORMAT TO TAKE FOUR ARGS ???
O USE UPPERCASE FOR TYPES? INT VS <INT> 
o MULTI-COLLECTIONS
o GENERIC FUNCTIONS???
X RENAME ENV FUNCTIONS
X   USE BINDING 
X   USE SETTER NOTATION
o RECONCILE COLLECTION LIB WITH COOK PAPER
o INFIX -> PREFIX CONVERTER LIKE TAGS
o REDEFINITION
o   SEMANTICS WITHOUT DEFCLASS TYPE DEFS
x   ZERO PARAM CASE
o   CLASS REDEF DEALING WITH EXISTING METHODS
o UNNAMED ARGUMENTS WITH _
x CLONING VECTORS WORKS HOW?
o FFI
o CHANGE FROM SET! TO KEY FIELD INIT?
o MAKE PROTOCOL 
o   COLLECTIONS
o   CAN I OVERRIDE ISA?
o BIND "IT" TO TEST

LOW

o MULTIPLE VALUES
  (def block 
    (macro ((block ?name ?form ...) env)
     (call/cc (fun (?name) ?form ...))))
  (def (values (objects ...)) 
    (block return (apply return objects)))
  (def (call-with-values producer consumer) ...)
o UNICODE
o MERGE IN SERIES OPERATORS
o CHANGE LIST TO BE VECTOR?
o FORWARD REFERENCES
o SLOTS SHOULD USE ACCESSORS AS KEYS
o PREDICATE TYPES
x CHANGE NAME TO PROTO
o CLASS NAMING CONVENTION
o UNLIMITED PRECISION INTEGERS
o USE PAT VARS IN FORMAT STRINGS
o ASYMMETRY BETWEEN DEFINE AND LOC WRT PARAMS ((FUN x y) ?body)
   (DEF (F A B) BODY)
   (LOC (((F A B) BODY) ...) BODY)
   (LET ((X EXP) ...) BODY)
x MORE EFFICIENT LOC
x RENAME SET! SET
x CHANGE FIELD TO SLOT
o MOP
o THUNK ABBREVIATION [ form ... ] => (fun () form ...)
o GET RID OF CONTROL FORMS USING THUNKS INSTEAD?
    (def (if #f con alt) (alt)) (if x [(go)] [(stop)])
    (def (if t  con alt) (con))

It seems stange to me that Dylan has every? and any?, but not count, 
given that every? and any? can both be efficiently created from count, 
as count(coll, pred) >= 1  and  count(coll, pred) = coll.size.  Well, 
OK, perhaps every? and any? are better to have an early-out 
implementaion, but I certainly don't see how they are any more primitive 
than count().
