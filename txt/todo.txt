OVERALL

NOW

x <col!> <seq!>
x packer
x shorten dir names
x move runtime into goo
x add fun-val congruency checking
x add/rename del! in tab/goo
x change add/mem? for col/set
x move arity check to sig_val_type check
use op
get rid of format
port2str macro
exported -> pub
str port
split out boot and runtime
--
extend if
seq -> do
do  -> each or all
get rid of collecting
report undefined bindings immediately after each module
change printing to avoid extra ]'s

PROTO2GOO



TYPE-INFERENCE

o TRACK GLOBAL ASSIGNMENTS
o METHOD TYPES
o FLOW SENSITIVE
o CPA

STATIC DISPATCH

o AST NODE FOR MET-CALL
o UPGRADE CALL

DYN-C 

o DEFINE NEW BINDINGS IN CODE
o LOOKUP IMPORTS THROUGH MODULE
o REFS THROUGH BINDING-BOXES

NATIVE CODE

o FIND OUT WHY IT INTERFERES WITH P2C
o TURN SPECIALS INTO CALLS
o CREATE STUB FOR CALLING VM USE FUN-VM SLOT
o GET VM FINISHED

CLASS

o CHANGE BOOTSTRAP TO MAKE CLASSES
o CHANGE ISA TO ALLOW ONLY ONE PARENT
o CHANGE ISA? TO BE THE REAL ONE
o NEED REAL-CLASS FOR REDEF
o FLATTEN OBJECTS
o CHANGE REDEF TO ERROR ON ACCESSING OBSOLETE OBJECTS

RTGC

o NEED SAFE GC POINTS
o NEED LIVE VARS
o REGISTER ROOTS
o NONINCREMENTAL TREADMILL 

HIGH -- SAFETY -- CORRECTNESS -- MIN FUNCTIONALITY

o NESTED MACROS FAIL `(mif (,',pattern))
o MAKE TUP'S READ-ONLY AND VECS
x TEST SUITE
x   CORE
o   LIBRARY
o TYPE-CHECK ISA SLOT INITS
o ERROR ON WRONG NUM ARGS TO INTERP FUN 
o MORE GENSYMS PLACES!!!
o DOC IS WRONG FOR ADD-SLOT -- NEED TO DM ACCESSORS

MEDIUM -- SPEED -- FUNCTIONALITY

o NEXT-METHOD IS A BIG AND INCONSISTENT NAME 
o DOC port-line port-column
o ISA specially processes parents
o CLOSURE NAMES HAVE PARENTS
o BOUNDP on :: vars
o DDV not available to top level
o unbound variables crash system
x (newline) crashes (w/o port)
o (== x) crashes system
o DOC HEAD/TAIL-SETTER
o gen's get redefined with new method defs in p2c-eval
o (/ int flo) doesn't work
o (times n) for (from-below 0 n)
o DOC add-to-tmp
o PRINT LOC CORRECTLY &0x
o PRINT NUL CORRECTLY
o ADD LEN-SETTER TO DOC
x (DEF-SLOT ?name ((?var ?class) => ?type) ?@body)
o (ISA ?type ?@init-args)
o CLOSE OVER TYPES IN SIGNATURES
o DOC OPF, ADD!
o DOC LOW-ELT(-SETTER)
o REP XEP'S GENERATED
o CALL-C MECHANISM
o WRAP DYNAMIC VAR ACCESSES WITH DYN
o RENAME LAB TO ESC
o IMPROVE P2C
o   DON'T OUTPUT SHADOW REGISTERS / LOOP: UNLESS USED
o   TIE REGISTERS BETWEEN NESTED PROGRAMS
o   REUSE REGISTERS IN SIBLING COMPUTATIONS
o NAMES IN TRAITS
o REMOVE SIZE FROM OBJECT VALUES (SHOULD BE IN TRAITS)
o C-D NOT WORKING
o STACK OVERFLOW CHECK
o INLINE SLOTS -- HARD WITH (SLOT ...)
o DEBUGGABLE INTERPRETER
o   GOOD ERRORS
o     CONDITIONS FOR DISPATCH/FUNCALL PROBLEMS
o       ADDING METHOD TO FUNCTION
o       INCONGRUENCY
o       WRONG NUMBER ARGS SHOULD BE REAL CONDITION
o   RESTARTS
o   BACKTRACE
o     FOR C 
o     FOR EVAL
o INSPECTOR
o MAINTAIN SOURCE LOCATION
o NARY APPLY 
o LAMBDA-LIFTING
o MAKE ENV A MAP
o REPEATED SLOTS
o MERGE AST-LINEARIZE INTO AST
o FASTER CALL
o USE ELSE AS #T IN CASE AND SELECT
o ADD RECURRING FORMAT
o REWRITE SYNTAX.PROTO AS MACROS FOR DECLARATIVE SPEC
o BIGNUMS
o NARY VERSIONS OF ARITH
o HANDLE CHANGE CLASS
o   TRACK METHODS
o CHANGE FROM (ISA (PARENT ...) (SET GETTER VALUE) ...) TO GETTER VALUE ...
x MON SHOULD BE MORE LIKE LOC TAKING FUN PARAMS
o   CHANGE SIG TO SEARCH FOR APPLICABLE TRY
o ELT-OR AS UNDERLYING SUBSTRATE
o   ELT CALLS ELT-OR WITH $unsupplied
o PRIMITIVES SHOULD HAVE TYPES IN COMPILER
o NEED COMPILATION/RUNTIME-CONTEXT OBJECTS
o ISA CAN'T BE A MACRO CAUSE NEEDS TO BE CALLED
o FINISH TUP SUPPORT
o   ADD SET TUP SYNTAX
o   ADD DV TUP SYNTAX
o   LET TUP SHOULD DO PARALLEL BINDING THOUGH
o SHOULD BE ADD-FIRST AND ADD-LAST
o PUSH AND POP MIGHT BE BETTER AS MACROS FOR WRITE BACK
o   THEY DON'T CURRENTLY WORK FOR LISTS
o CHANGE SIF FORMAT TO TAKE FOUR ARGS ???
O USE UPPERCASE FOR TYPES? INT VS <INT> 
o MULTI-COLLECTIONS
o COLLECTING MACRO
o   WITH PROTOCOL
o GENERIC FUNCTIONS???
o RECONCILE COLLECTION LIB WITH COOK PAPER
o INFIX -> PREFIX CONVERTER LIKE TAGS
o REDEFINITION
o   SEMANTICS WITHOUT DEFCLASS TYPE DEFS
x   ZERO PARAM CASE
o   CLASS REDEF DEALING WITH EXISTING METHODS
o UNNAMED ARGUMENTS WITH _
o FFI
o CHANGE FROM SET! TO KEY FIELD INIT?
o MAKE PROTOCOL 
o   COLLECTIONS
o   CAN I OVERRIDE ISA?
o DON'T ALLOW DOT READING
o DON'T CONS TRAITS UNLESS YOU DIFFER FROM PARENT

LOW

o OUTPUT-PORT -> OUT-PORT ETC
o WRITE WYSIWYG FIP
o WRITE WYSIWYG CURRY
o ADD FALSE-OR
o ADD TYPE-OR
o CHANGE NAME OF MAKE-SYM TO FAB-SYM OR MAYBE CAT-SYM
o CLASS-BASED VERSION
o BIND "IT" TO TEST
o USE FIP MORE AND DEPRECATE DEPENDENCE ON LISTS
o WRITE CALL ROUTINES IN PROTO
o MERGE SYNTAX INTO AST GETTING RID OF ALL THE SYNTAX FUNS USING DESTRUCTING
o AUTO GEN SEXPR-COMPILE-TIME-TAGS
o GET RID OF MACRO VAR DEFS EMITTED IN C FILE
o METHODS SHOULD BE TRACEABLE BACK TO GENERIC
o CHANGE ISA SYNTAX TO REMOVE (SET ,name ,value)'s in favor of ,name ,value
o REWRITE from-*-* using macro
o WHAT ABOUT KEY-VALUE ITERATION IN FOR LOOP? (USE TUP)
o MULTIPLE VALUES
  (def block 
    (macro ((block ?name ?form ...) env)
     (call/cc (fun (?name) ?form ...))))
  (def (values (objects ...)) 
    (block return (apply return objects)))
  (def (call-with-values producer consumer) ...)
o UNICODE
o MERGE IN SERIES OPERATORS
o CHANGE LIST TO BE VECTOR?
o FORWARD REFERENCES
o SLOTS SHOULD USE ACCESSORS AS KEYS
o PREDICATE TYPES
o CLASS NAMING CONVENTION
o USE PAT VARS IN FORMAT STRINGS
o ASYMMETRY BETWEEN DEFINE AND LOC WRT PARAMS ((FUN x y) ?body)
   (DEF (F A B) BODY)
   (LOC (((F A B) BODY) ...) BODY)
   (LET ((X EXP) ...) BODY)
o MOP
o THUNK ABBREVIATION [ form ... ] => (fun () form ...)
o GET RID OF CONTROL FORMS USING THUNKS INSTEAD?
    (def (if #f con alt) (alt)) (if x [(go)] [(stop)])
    (def (if t  con alt) (con))

It seems stange to me that Dylan has every? and any?, but not count, 
given that every? and any? can both be efficiently created from count, 
as count(coll, pred) >= 1  and  count(coll, pred) = coll.size.  Well, 
OK, perhaps every? and any? are better to have an early-out 
implementaion, but I certainly don't see how they are any more primitive 
than count().

TABLES

;;--- To-do:
;;--- Bugs:
;;---   GC-state is not taken into account.  Adding a macro that wraps
;;---     up key-searching would help organize this.
;;--- Performance:
;;---   Finish (hopefully) better hashing functions for both \== and \=.
;;---   Make a subclass for \= tables that inlines the test and hash functions.
;;---     Should we do this for \= and \== tables?
;;---   Remove "below" tests when looping through tables since we provably
;;---     must hit an empty or evacuated cell sometime.
;;---   We don't currently need to lock table during rehash because we always
;;---     create a new vector.  This is very inefficient when we are doing a
;;---     same-size rehash on behalf of the GC.  Can we do better?
;;---     except that a puthash might get lost
;;---   Another way to decide to rehash a table might be on the basis of having
;;---     collision chains that are "too long".
;;---   Rehashing a table should consider the collision chain as it rehashes.
;;---     That is when an object A is hashed to it's preferred place in the
;;---     table and there is already an object B there due to secondary 
;;---     hashing then object B should be removed to some other place in its 
;;---     collision chain.  This means that object A will end up in its 
;;---     preferred place and object B won't be much worse off.
;;---   When removing the last key in a bucket in 'remhash' it can be marked
;;---     as empty instead of vacated.
;;--- Extensions:
;;---   Implement set (0-valued) tables.


